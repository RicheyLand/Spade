#include "spade.h"
#include "ui_spade.h"

/// Class constructor
///
/// @param  Initial text label of element
/// @param  Parent widget of instance
RichLabel::RichLabel(const QString & text, QWidget * parent) : QLabel(parent)
{
    setText(text);
    setAttribute(Qt::WA_Hover, true);                   //  allow mouse cursor tracking of clickable label
    setMouseTracking(true);
}


/// Class destructor
RichLabel::~RichLabel()
{
}


/// handle mouse press event
///
/// @param  Qt Mouse event reference
void RichLabel::mousePressEvent(QMouseEvent * event)
{
    if (event->buttons())
        emit clicked(id);                               //  emit press signal of object
}


/// Handle mouse cursor enter event
///
/// @param  Generic Qt event handler
void RichLabel::enterEvent(QEvent * event)
{
    emit entered(id);                                   //  emit cursor enter signal of object
    event->ignore();
}


/// Handle mouse cursor leave event
///
/// @param  Generic Qt event handler
void RichLabel::leaveEvent(QEvent * event)
{
    emit leaved(id);                                    //  emit cursor leave signal of object
    event->ignore();
}


/// Class constructor
///
/// @param  Initial text label of element
/// @param  Parent widget of instance
RichPushButton::RichPushButton(const QString & text, QWidget * parent) : QPushButton(parent)
{
    setText(text);
    setAttribute(Qt::WA_Hover, true);                   //  allow mouse cursor tracking of button
    setMouseTracking(true);
}


/// Class destructor
RichPushButton::~RichPushButton()
{
}


/// Handle mouse cursor enter event
///
/// @param  Generic Qt event handler
void RichPushButton::enterEvent(QEvent * event)
{
    emit entered();                                     //  emit cursor enter signal of object
    event->ignore();
}


/// Handle mouse cursor leave event
///
/// @param  Generic Qt event handler
void RichPushButton::leaveEvent(QEvent * event)
{
    emit leaved();                                      //  emit cursor leave signal of object
    event->ignore();
}


/// Class constructor
///
/// @param  Parent widget of instance
RichTreeWidget::RichTreeWidget(QWidget * parent) : QTreeWidget(parent)
{                                                       //  initialize tree widget into desired state
    setMinimumWidth(250);
    setFrameShape(QFrame::NoFrame);
    setHeaderHidden(true);
    setColumnCount(2);
    header()->setVisible(false);
    header()->setStretchLastSection(false);
    header()->setSectionResizeMode(QHeaderView::ResizeToContents);
}


/// Handle mouse release event
///
/// @param  Qt Mouse event reference
void RichTreeWidget::mouseReleaseEvent(QMouseEvent * event)
{                                                       //  send appropriate signal when one of mouse button have been pressed
    if (event->button() == Qt::LeftButton)
        emit left_mouse_clicked(currentIndex());
    else if (event->button() == Qt::RightButton)
        emit right_mouse_clicked(currentIndex());

    QTreeWidget::mouseReleaseEvent(event);              //  use parent's method after sending signal
}


/// Class constructor
///
/// @param  Parent widget of instance
CodeEditor::CodeEditor(QWidget *parent) : QPlainTextEdit(parent)
{
    lineNumberArea = new LineNumberArea(this);
    lineNumberArea->setToolTip("Line: 0, Column 0");    //  initialize line number area tooltip content to actual coordinates of text cursor

    QString temp_path = QStandardPaths::writableLocation(QStandardPaths::TempLocation);

    if (temp_path.right(1) != "/")
        temp_path.push_back('/');
                                                        //  set default values for attributes of object
    content = "";
    actual_selection.from = 0;
    actual_selection.to = 0;
    theme = 1;
    file_path = temp_path + "untitled.txt";
    vim_active = false;
    key_press_flag = false;
    undo_redo_flag = false;
    line_change_flag = false;
    differences_index = 0;
                                                        //  connect signals sent by editor with appropriate slot methods
    connect(this, SIGNAL(blockCountChanged(int)), this, SLOT(updateLineNumberAreaWidth(int)));
    connect(this, SIGNAL(updateRequest(QRect,int)), this, SLOT(updateLineNumberArea(QRect,int)));
    connect(this, SIGNAL(cursorPositionChanged()), this, SLOT(cursor_position_changed()));
    connect(this, SIGNAL(textChanged()), this, SLOT(editor_text_changed()));
    connect(this, SIGNAL(selectionChanged()), this, SLOT(cursor_position_changed()));
    connect(this->document(), SIGNAL(undoCommandAdded()), this, SLOT(undo_command_added()));

    updateLineNumberAreaWidth(0);                       //  initialize width of line number area
}


/// Returns recommended width of line number area
int CodeEditor::lineNumberAreaWidth()
{
    int digits = 1;
    int max = qMax(1, blockCount());

    while (max >= 10)                                   //  count number of digits in bottom line of line number area
    {
        max /= 10;
        ++digits;
    }

    int space = fontMetrics().width(QLatin1Char('9')) * digits + 3;     //  calculate width of line number area by digits count and actual font width

    return space;
}


/// Method with redefined behavior of file content save
void CodeEditor::save_content()
{
    while (differences.size() - 1 > differences_index)      //  remove all items after actual step in undo history
        differences.pop_back();

    int N = differences[differences_index].size();

    for (int i = 0; i < N; i++)
    {
        if (differences[differences_index][i])
            differences[differences_index][i] = false;      //  clean all differences in actual step of undo history to indicate file save
    }

    N = actual_difference.size();

    for (int i = 0; i < N; i++)
    {
        if (actual_difference[i])
            actual_difference[i] = false;               //  clean all actual difference lines too for correct behavior of editor
    }

    update();                                           //  update widget to immediately refresh code lines area
}


/// Handle text differences check if lines swapped up
///
/// @param  Affected line integer value
/// @param  Integer value of lines which must be moved
/// @param  Boolean value to hold state of moved line
void CodeEditor::handle_swap_line_up(int line, int count, bool top_difference_value)
{                                                       //  refresh lines on actual index of differences array
    for (int i = 0; i < count; i++)                     //  mark text difference on all swapped lines
        differences[differences_index][line + i] = true;

    differences[differences_index][line + count] = top_difference_value;    //  refresh text difference value on line affected by swap
    actual_difference = differences[differences_index];     //  refresh actual differences too
}


/// Handle text differences check if lines swapped down
///
/// @param  Affected line integer value
/// @param  Integer value of lines which must be moved
/// @param  Boolean value to hold state of moved line
void CodeEditor::handle_swap_line_down(int line, int count, bool top_difference_value)
{                                                       //  refresh lines on actual index of differences array
    for (int i = 0; i < count; i++)                     //  mark text difference on all swapped lines
        differences[differences_index][line + i] = true;

    differences[differences_index][line - 1] = top_difference_value;    //  refresh text difference value on line affected by swap
    actual_difference = differences[differences_index];     //  refresh actual differences too
}


/// Slot which updates width of line number area
///
/// @param  Holds integer value of text blocks(lines)
void CodeEditor::updateLineNumberAreaWidth(int /* newBlockCount */)
{
    setViewportMargins(lineNumberAreaWidth() + fontMetrics().width(QLatin1Char('9')), 0, 0, 0);
}


/// Slot which updates line number area
///
/// @param  Rectangle value of text editor view area
/// @param  Integer value of vertical axis scroll
void CodeEditor::updateLineNumberArea(const QRect &rect, int dy)
{
    if (dy)
        lineNumberArea->scroll(0, dy);                  //  scroll editor viewport in vertical axis
    else
        lineNumberArea->update(0, rect.y(), lineNumberArea->width(), rect.height());    //  update whole line number area

    if (rect.contains(viewport()->rect()))              //  handle viewport position change of editor
        updateLineNumberAreaWidth(0);
}


/// Handle change of text editor position
void CodeEditor::cursor_position_changed()
{
    actual_selection.from = textCursor().selectionStart();  //  refresh values of text cursor selections
    actual_selection.to = textCursor().selectionEnd();
                                                        //  refresh content of line number area tooltip by actual coordinates of text cursor
    lineNumberArea->setToolTip(QString("Line: %1, Column %2").arg(textCursor().blockNumber()).arg(textCursor().columnNumber()));
}


/// Handle change of single line
///
/// @param  Holds integer value of changed line
void CodeEditor::handle_line_change(int line_index)
{
    if (undo_redo_flag)                                 //  not continue when special undo flag is active
        return;

    if (line_change_flag == false)                      //  line changes detection must be active
        return;

    if (textCursor().blockNumber() < line_index)        //  ignore following lines
        return;

    vector<bool> new_difference;

    int N = blockCount();

    for (int i = 0; i < N; i++)
        new_difference.push_back(true);

    int lines_from_top = line_index;
    int lines_from_bottom =  N - line_index - 1;
    int i = 0;

    int M = actual_difference.size();

    while (lines_from_top && lines_from_top < N && lines_from_top < M)  //  refresh actual values in differences array from top of editor
    {
        lines_from_top--;
        new_difference[lines_from_top] = actual_difference[lines_from_top];
    }

    i = 0;

    while (i < N && i < M && lines_from_bottom)         //  refresh actual values in differences array from bottom of editor
    {
        new_difference[N - 1 - i] = actual_difference[M - 1 - i];
        i++;
        lines_from_bottom--;
    }

    actual_difference = new_difference;                 //  refresh actual difference
    update();
}


/// Handle change of text editor content
void CodeEditor::editor_text_changed()
{   
    if (actual_selection.from != textCursor().selectionStart() || actual_selection.to != textCursor().selectionEnd())
    {
        actual_selection.from = textCursor().selectionStart();  //  refresh values of text cursor selections if they were changed
        actual_selection.to = textCursor().selectionEnd();
    }

    if (undo_redo_flag)                                 //  not continue when special undo flag is active
        return;

    content = document()->toPlainText();                //  save new content of text document
    line_change_flag = false;
}


/// Handle change of adding new item into undo history
void CodeEditor::undo_command_added()
{
    if (differences_index == differences.size() - 1)    //  push new item into differences array
    {
        differences[differences_index] = actual_difference;
        differences.push_back(actual_difference);
        differences_index++;
    }
    else
    {
        while (differences_index < differences.size() - 1)      //  clear all undo history items if index is not same as end of history index
            differences.pop_back();

        differences[differences_index] = actual_difference;
        differences.push_back(actual_difference);
        differences_index++;
    }

    line_change_flag = true;
    update();
}


/// Redefined method for undo operation
void CodeEditor::text_undo()
{
    if (differences_index)                              //  check if text undo is possible
    {
        undo_redo_flag = true;                          //  set undo flag to handle undo using classic behavior without calculating text editor changes
        undo();                                         //  call default undo method
        undo_redo_flag = false;
        content = document()->toPlainText();            //  refresh content variable
        differences[differences_index] = actual_difference;
        differences_index--;
        actual_difference = differences[differences_index];     //  refresh actual difference content
        update();
    }
}


/// Redefined method for redo operation
void CodeEditor::text_redo()
{
    if (differences_index < differences.size() - 1)     //  check if text redo is possible
    {
        undo_redo_flag = true;                          //  set undo flag to handle undo using classic behavior without calculating text editor changes
        redo();                                         //  call default redo method
        undo_redo_flag = false;
        content = document()->toPlainText();            //  refresh content variable
        differences_index++;
        actual_difference = differences[differences_index];     //  refresh actual difference content
        update();
    }
}


/// Event which represents resize event of text editor
///
/// @param  Overrided Qt resize event handler
void CodeEditor::resizeEvent(QResizeEvent *e)
{
    QPlainTextEdit::resizeEvent(e);

    QRect cr = contentsRect();                          //  get resize rectangle of text editor
    lineNumberArea->setGeometry(QRect(cr.left(), cr.top(), lineNumberAreaWidth(), cr.height()));    //  refresh text editor geometry using rectangle
}


/// Redefined key press event to catch advanced keyboard shortcuts
///
/// @param  Qt key press event handler
void CodeEditor::keyPressEvent(QKeyEvent * event)       //  handle special keyboard shortcuts which are not supported by editor by default
{                                                       //  if keyboard shortcut is not special, then call default parent method(QPlainTextEdit)
    if (vim_active)                                     //  Vim mode is active
    {
        if (key_press_flag)                             //  disable key press flag if it is active
        {            
            QPlainTextEdit::keyPressEvent(event);
            key_press_flag = false;
            return;
        }

        if (event->key() == Qt::Key_Home)               //  redefine reaction to key press of some keys
            QPlainTextEdit::keyPressEvent(event);
        else if (event->key() == Qt::Key_End)
            QPlainTextEdit::keyPressEvent(event);
        else if (event->key() == Qt::Key_PageUp)
            QPlainTextEdit::keyPressEvent(event);
        else if (event->key() == Qt::Key_PageDown)
            QPlainTextEdit::keyPressEvent(event);
        else if (event->key() == Qt::Key_Left || event->key() == Qt::Key_Right || event->key() == Qt::Key_R)    //  arrow keys
        {
            if (event->modifiers() & Qt::ControlModifier)   //  handle control key modifier press
                emit vim_key_press_signal(event->key(), "control");
            else
                emit vim_key_press_signal(event->key(), event->text());
        }
        else
            emit vim_key_press_signal(event->key(), event->text());
    }
    else                                                //  Vim mode is not active
    {
        if (event->key() == Qt::Key_Z)
        {
            if (event->modifiers() & Qt::ControlModifier)
            {
                if (event->modifiers() & Qt::ShiftModifier)
                    text_redo();                        //  Ctrl + Shift + Z
                else
                    text_undo();                        //  Ctrl + Z
            }
            else
                QPlainTextEdit::keyPressEvent(event);
        }
        else if (event->key() == Qt::Key_S)
        {
            if (event->modifiers() & Qt::ControlModifier)
            {
                if (event->modifiers() & Qt::ShiftModifier)
                    emit save_all_signal();             //  Ctrl + Shift + S
                else
                    emit save_signal();                 //  Ctrl + Z
            }
            else
                QPlainTextEdit::keyPressEvent(event);
        }
        else if (event->key() == Qt::Key_O)
        {
            if (event->modifiers() & Qt::ControlModifier)
                emit open_signal();                     //  Ctrl + O
            else
                QPlainTextEdit::keyPressEvent(event);
        }
        else if (event->key() == Qt::Key_N)
        {
            if (event->modifiers() & Qt::ControlModifier)
                emit new_tab_signal();                  //  Ctrl + N
            else
                QPlainTextEdit::keyPressEvent(event);
        }
        else if (event->key() == Qt::Key_W)
        {
            if (event->modifiers() & Qt::ControlModifier)
                emit close_signal();                    //  Ctrl + W
            else
                QPlainTextEdit::keyPressEvent(event);
        }
        else if (event->key() == Qt::Key_Enter || event->key() == Qt::Key_Return)
        {
            if (event->modifiers() & Qt::AltModifier)
                emit fullscreen_signal();               //  Alt + Enter
            else
                emit enter_signal();                    //  Enter
        }
        else if (event->key() == Qt::Key_Q)
        {
            if (event->modifiers() & Qt::ControlModifier)
                emit exit_signal();                     //  Ctrl + Q
            else
                QPlainTextEdit::keyPressEvent(event);
        }
        else if (event->key() == Qt::Key_R)
        {
            if (event->modifiers() & Qt::ControlModifier)
                emit run_signal();                      //  Ctrl + R
            else
                QPlainTextEdit::keyPressEvent(event);
        }
        else if (event->key() == Qt::Key_B)
        {
            if (event->modifiers() & Qt::ControlModifier)
                emit build_signal();                    //  Ctrl + B
            else
                QPlainTextEdit::keyPressEvent(event);
        }
        else if (event->key() == Qt::Key_F)
        {
            if (event->modifiers() & Qt::ControlModifier)
                emit find_signal();                     //  Ctrl + F
            else
                QPlainTextEdit::keyPressEvent(event);
        }
        else if (event->key() == Qt::Key_U)
        {
            if (event->modifiers() & Qt::ControlModifier)
                emit uppercase_signal();                //  Ctrl + U
            else
                QPlainTextEdit::keyPressEvent(event);
        }
        else if (event->key() == Qt::Key_L)
        {
            if (event->modifiers() & Qt::ControlModifier)
                emit lowercase_signal();                //  Ctrl + L
            else
                QPlainTextEdit::keyPressEvent(event);
        }
        else if (event->key() == Qt::Key_Up)
        {
            if (event->modifiers() & Qt::ControlModifier)
            {
                if (event->modifiers() & Qt::ShiftModifier)
                    emit swap_line_up_signal();         //  Ctrl + Shift + Up
                else
                    emit move_scrollbar_up_signal();    //  Ctrl + Up
            }
            else
                QPlainTextEdit::keyPressEvent(event);
        }
        else if (event->key() == Qt::Key_Down)
        {
            if (event->modifiers() & Qt::ControlModifier)
            {
                if (event->modifiers() & Qt::ShiftModifier)
                    emit swap_line_down_signal();       //  Ctrl + Shift + Down
                else
                    emit move_scrollbar_down_signal();  //  Ctrl + Down
            }
            else
                QPlainTextEdit::keyPressEvent(event);
        }
        else if (event->key() == Qt::Key_Slash)
        {
            if (event->modifiers() & Qt::ControlModifier)
                emit comment_signal();                  //  Ctrl + /
            else
                QPlainTextEdit::keyPressEvent(event);
        }
        else if (event->key() == Qt::Key_Plus)
        {
            if (event->modifiers() & Qt::ControlModifier)
            {
                if (event->modifiers() & Qt::ShiftModifier)
                    emit increase_font_size_signal();   //  Ctrl + Plus
                else
                    QPlainTextEdit::keyPressEvent(event);
            }
            else
                QPlainTextEdit::keyPressEvent(event);
        }
        else if (event->key() == Qt::Key_Minus)
        {
            if (event->modifiers() & Qt::ControlModifier)
                emit decrease_font_size_signal();       //  Ctrl + Minus
            else
                QPlainTextEdit::keyPressEvent(event);
        }
        else if (event->key() == Qt::Key_PageUp)
        {
            if (event->modifiers() & Qt::ControlModifier)
                emit move_tab_up_signal();              //  Ctrl + PageUp
            else
                QPlainTextEdit::keyPressEvent(event);
        }
        else if (event->key() == Qt::Key_PageDown)
        {
            if (event->modifiers() & Qt::ControlModifier)
                emit move_tab_down_signal();            //  Ctrl + PageDown
            else
                QPlainTextEdit::keyPressEvent(event);
        }
        else if (event->key() == Qt::Key_Tab)
        {
            if (event->modifiers() & Qt::ShiftModifier)
                emit shift_tab_signal();                //  Shift + Tab
            else
                emit tab_signal();                      //  Tab
        }
        else if (event->key() == Qt::Key_Backtab)
            emit shift_tab_signal();                    //  Shift + Tab
        else if (event->key() == Qt::Key_ParenLeft)
            emit classic_bracket_signal();              //  (
        else if (event->key() == Qt::Key_BraceLeft)
            emit block_bracket_signal();                //  {
        else if (event->key() == Qt::Key_BracketLeft)
            emit array_bracket_signal();                //  [
        else
            QPlainTextEdit::keyPressEvent(event);
    }
}


/// Event which causes repaint of line number area
///
/// @param  Qt paint event handler
void CodeEditor::lineNumberAreaPaintEvent(QPaintEvent * event)
{
    QPainter painter(lineNumberArea);                   //  apply painter object to line number area
                                                        //  fill background of line number area by the actual scheme color
    if (theme == 0)
        painter.fillRect(event->rect(), QColor(38, 38, 38));
    else if (theme == 1)
        painter.fillRect(event->rect(), QColor(253, 246, 227));
    else if (theme == 2)
        painter.fillRect(event->rect(), Qt::black);
    else if (theme == 3)
        painter.fillRect(event->rect(), QColor(242, 241, 240));
    else if (theme == 4)
        painter.fillRect(event->rect(), QColor(2, 9, 28));
    else if (theme == 5)
        painter.fillRect(event->rect(), Qt::white);

    QTextBlock block = firstVisibleBlock();
    unsigned blockNumber = block.blockNumber();         //  get actual line number of text editor
    int top = (int) blockBoundingGeometry(block).translated(contentOffset()).top();     //  get value of line numebr area top line
    int bottom = top + (int) blockBoundingRect(block).height();     //  get value of line numebr area bottom line

    vector<bool> selection;
    int from = textCursor().selectionStart();           //  get coordinates of actual text cursor selection
    int to = textCursor().selectionEnd();
    int N = content.size();
    int i = 0;
    bool select_flag = false;                           //  handle newline at end editor content using this flag

    while (i < N)                                       //  calculate which lines are affected by text cursor selection
    {
        if (i >= from && i <= to)
            select_flag = true;

        if (content[i] == '\n')                         //  detect newline character to separate lines
        {
            if (select_flag)
            {
                selection.push_back(true);
                select_flag = false;
            }
            else
                selection.push_back(false);
        }

        i++;
    }

    if (i >= from && i <= to)                           //  recognize text cursor selection on last line
        select_flag = true;

    if (select_flag)
        selection.push_back(true);
    else
        selection.push_back(false);

    if (selection.size() != (unsigned)document()->blockCount())
        return;

    while (block.isValid() && top <= event->rect().bottom())    //  iterate through all lines of text editor and refresh line number area color of lines
    {
        if (block.isVisible() && bottom >= event->rect().top())
        {
            QString number = QString::number(blockNumber + 1);

            if (selection[blockNumber])                 //  actual line is affected by text cursor selection
            {
                if (actual_difference.size())  //  handle array index overflow
                {                                       //  there is detected text difference on actual line
                    if (actual_difference.size() > blockNumber && actual_difference[blockNumber])
                    {
                        if (theme == 1 || theme == 3 || theme == 5)
                            painter.setPen(QColor(0, 110, 255));
                        else
                            painter.setPen(QColor(255, 215, 0));
                    }
                    else                                //  there is no difference on actual line
                    {
                        if (theme == 1 || theme == 3 || theme == 5)
                            painter.setPen(QColor(0, 0, 0).dark());
                        else
                            painter.setPen(QColor(255, 255, 255).light());
                    }
                }
                else                                    //  there is no difference on actual line
                {
                    if (theme == 1 || theme == 3 || theme == 5)
                        painter.setPen(QColor(0, 0, 0).dark());
                    else
                        painter.setPen(QColor(255, 255, 255).light());
                }
            }
            else                                        //  actual line is not affected by text cursor selection
            {
                if (actual_difference.size())      //  handle array index overflow
                {                                       //  there is detected text difference on actual line
                    if (actual_difference.size() > blockNumber && actual_difference[blockNumber])
                    {
                        if (theme == 0)
                            painter.setPen(QColor(255, 20, 147));
                        else if (theme == 1)
                            painter.setPen(QColor(200, 0, 0));
                        else if (theme == 2)
                            painter.setPen(QColor(255, 20, 147));
                        else if (theme == 3)
                            painter.setPen(QColor(200, 0, 0));
                        else if (theme == 4)
                            painter.setPen(QColor(255, 20, 60));
                        else
                            painter.setPen(QColor(200, 0, 0));
                    }
                    else                                //  there is no difference on actual line
                    {
                        if (theme == 0)
                            painter.setPen(QColor(109, 105, 87));
                        else if (theme == 1)
                            painter.setPen(QColor(150, 150, 150));
                        else if (theme == 2)
                            painter.setPen(QColor(255, 255, 255, 125));
                        else if (theme == 3)
                            painter.setPen(QColor(160, 160, 160));
                        else if (theme == 4)
                            painter.setPen(QColor(110, 110, 110));
                        else
                            painter.setPen(QColor(230, 190, 148));
                    }
                }
                else                                    //  there is no difference on actual line
                {
                    if (theme == 0)
                        painter.setPen(QColor(109, 105, 87));
                    else if (theme == 1)
                        painter.setPen(QColor(150, 150, 150));
                    else if (theme == 2)
                        painter.setPen(QColor(255, 255, 255, 125));
                    else if (theme == 3)
                        painter.setPen(QColor(160, 160, 160));
                    else if (theme == 4)
                        painter.setPen(QColor(110, 110, 110));
                    else
                        painter.setPen(QColor(230, 190, 148));
                }
            }
                                                        //  draw number of actual line into line number area
            painter.drawText(0, top, lineNumberArea->width(), fontMetrics().height(), Qt::AlignRight, number);
        }

        block = block.next();
        top = bottom;
        bottom = top + (int) blockBoundingRect(block).height();
        ++blockNumber;
    }
}


/// Class constructor
Tab_details::Tab_details()
{                                                       //  set default values for attributes of object
    QString temp_path = QStandardPaths::writableLocation(QStandardPaths::TempLocation);

    if (temp_path.right(1) != "/")
        temp_path.push_back('/');

    index_in_tabs = 0;
    language = plain_text;
    file_path = temp_path + "untitled.txt";
    file_name = "untitled.txt";
    font_size = 10;
    tab_width = 4;
    scroll_bars = true;
    comments = true;
    theme = 1;
    saved = true;
    custom_selections_count = 0;
}


/// Class constructor
///
/// @param  Integer value which holds index of text editor inside window
/// @param  Parent widget of instance
Spade::Spade(int _which, QWidget *parent) :
    QDialog(parent),
    ui(new Ui::Spade)
{
    ui->setupUi(this);

    if (systemInfo.windowsVersion() == QSysInfo::WV_None)   //  check if current operating system is Windows
        isWindows = false;
    else
        isWindows = true;

    setWindowFlags(Qt::Window);                         //  allow to force fullscreen mode
    which = _which;
    thread_count = QThread::idealThreadCount();

    if (thread_count < 1)
        thread_count = 4;

    fullscreen = false;                                 //  fullscreen mode is always disabled on application startup
    insert_mode = false;                                //  insert mode is always disabled on application startup

    home_path = QDir::homePath();                       //  get home path string defined by actual environment

    if (home_path.right(1) != "/")
        home_path.push_back('/');

    config_path = QStandardPaths::writableLocation(QStandardPaths::ConfigLocation);

    if (config_path.right(1) != "/")
        config_path.push_back('/');

    QDir dir(config_path + "spade");

    if (!dir.exists())
        dir.mkpath(".");

    if (which == 2)
    {
        config_file_path = config_path + "spade/" + "spade_2.conf";   //  connect with rest of path to configuration file
        language_file_path = config_path + "spade/" + "languages_2.conf";     //  connect with rest of path to language file
        projects_file_path = config_path + "spade/" + "projects_2.conf";    //  connect with rest of path to projects file
    }
    else if (which == 3)
    {
        config_file_path = config_path + "spade/" + "spade_3.conf";   //  connect with rest of path to configuration file
        language_file_path = config_path + "spade/" + "languages_3.conf";     //  connect with rest of path to language file
        projects_file_path = config_path + "spade/" + "projects_3.conf";    //  connect with rest of path to projects file
    }
    else if (which == 4)
    {
        config_file_path = config_path + "spade/" + "spade_4.conf";   //  connect with rest of path to configuration file
        language_file_path = config_path + "spade/" + "languages_4.conf";     //  connect with rest of path to language file
        projects_file_path = config_path + "spade/" + "projects_4.conf";    //  connect with rest of path to projects file
    }
    else
    {
        config_file_path = config_path + "spade/" + "spade.conf";     //  connect with rest of path to configuration file
        language_file_path = config_path + "spade/" + "languages.conf";   //  connect with rest of path to language file
        projects_file_path = config_path + "spade/" + "projects.conf";    //  connect with rest of path to projects file
    }

    setMinimumWidth(750);
    setMinimumHeight(480);

    setToolTip("");

    max_tabs = 51;                                      //  maximum number of tabs is set to 50
    max_index = max_tabs - 1;
    theme_count = 6;                                    //  there are 6 available themes

    highlighters = new RichHighlighter * [max_tabs];    //  allocate memory for syntax highlighters of all text editor tabs

    ui->tabs->tabBar()->hide();
    ui->tab_1->setLayout(ui->tab_1_v_layout);           //  set layouts from Qt Designer for all text editor tabs
    ui->tab_2->setLayout(ui->tab_2_v_layout);
    ui->tab_3->setLayout(ui->tab_3_v_layout);
    ui->tab_4->setLayout(ui->tab_4_v_layout);
    ui->tab_5->setLayout(ui->tab_5_v_layout);
    ui->tab_6->setLayout(ui->tab_6_v_layout);
    ui->tab_7->setLayout(ui->tab_7_v_layout);
    ui->tab_8->setLayout(ui->tab_8_v_layout);
    ui->tab_9->setLayout(ui->tab_9_v_layout);
    ui->tab_10->setLayout(ui->tab_10_v_layout);
    ui->tab_11->setLayout(ui->tab_11_v_layout);
    ui->tab_12->setLayout(ui->tab_12_v_layout);
    ui->tab_13->setLayout(ui->tab_13_v_layout);
    ui->tab_14->setLayout(ui->tab_14_v_layout);
    ui->tab_15->setLayout(ui->tab_15_v_layout);
    ui->tab_16->setLayout(ui->tab_16_v_layout);
    ui->tab_17->setLayout(ui->tab_17_v_layout);
    ui->tab_18->setLayout(ui->tab_18_v_layout);
    ui->tab_19->setLayout(ui->tab_19_v_layout);
    ui->tab_20->setLayout(ui->tab_20_v_layout);
    ui->tab_21->setLayout(ui->tab_21_v_layout);
    ui->tab_22->setLayout(ui->tab_22_v_layout);
    ui->tab_23->setLayout(ui->tab_23_v_layout);
    ui->tab_24->setLayout(ui->tab_24_v_layout);
    ui->tab_25->setLayout(ui->tab_25_v_layout);
    ui->tab_26->setLayout(ui->tab_26_v_layout);
    ui->tab_27->setLayout(ui->tab_27_v_layout);
    ui->tab_28->setLayout(ui->tab_28_v_layout);
    ui->tab_29->setLayout(ui->tab_29_v_layout);
    ui->tab_30->setLayout(ui->tab_30_v_layout);
    ui->tab_31->setLayout(ui->tab_31_v_layout);
    ui->tab_32->setLayout(ui->tab_32_v_layout);
    ui->tab_33->setLayout(ui->tab_33_v_layout);
    ui->tab_34->setLayout(ui->tab_34_v_layout);
    ui->tab_35->setLayout(ui->tab_35_v_layout);
    ui->tab_36->setLayout(ui->tab_36_v_layout);
    ui->tab_37->setLayout(ui->tab_37_v_layout);
    ui->tab_38->setLayout(ui->tab_38_v_layout);
    ui->tab_39->setLayout(ui->tab_39_v_layout);
    ui->tab_40->setLayout(ui->tab_40_v_layout);
    ui->tab_41->setLayout(ui->tab_41_v_layout);
    ui->tab_42->setLayout(ui->tab_42_v_layout);
    ui->tab_43->setLayout(ui->tab_43_v_layout);
    ui->tab_44->setLayout(ui->tab_44_v_layout);
    ui->tab_45->setLayout(ui->tab_45_v_layout);
    ui->tab_46->setLayout(ui->tab_46_v_layout);
    ui->tab_47->setLayout(ui->tab_47_v_layout);
    ui->tab_48->setLayout(ui->tab_48_v_layout);
    ui->tab_49->setLayout(ui->tab_49_v_layout);
    ui->tab_50->setLayout(ui->tab_50_v_layout);
    ui->help_tab->setLayout(ui->help_tab_v_layout);
    ui->scrollArea->setWidget(ui->widget);
    ui->language_tab->setLayout(ui->language_tab_v_layout);

    cursor_timer = new QTimer;
    text_change_timer = new QTimer;

    text_cursor = new QTextCursor;
    editor = new CodeEditor[max_tabs];                  //  allocate memory for all text editor tabs

    theme_color = new QPalette;

    font.setFamily("Monospace");                        //  set font family to Monospace
    font.setStyleHint(QFont::Monospace);                //  set font style hint if default font is not available
    font.setHintingPreference(QFont::PreferNoHinting);  //  set no font hinting
    font.setStyleStrategy(QFont::PreferQuality);        //  set desired style strategy for font
    font.setFixedPitch(true);                           //  set fixed pitch of font
    font.setPointSize(10);                              //  set desired font size

    for (int i = 0; i <= max_index; i++)                //  initialize all text editor tabs attributes
    {
        highlighters[i] = new RichHighlighter(editor[i].document());    //  allocate memory for all syntax highlighters of text editor tabs

        editor[i].setContextMenuPolicy(Qt::NoContextMenu);  //  default context menu is disabled for all editor tabs
        editor[i].setMinimumHeight(0);
        editor[i].setAutoFillBackground(true);
        editor[i].setFrameShape(QFrame::NoFrame);
        editor[i].setTabChangesFocus(false);
        editor[i].setUndoRedoEnabled(true);
        editor[i].setLineWrapMode(QPlainTextEdit::NoWrap);  //  disable text wrapping
        editor[i].setReadOnly(false);
        editor[i].setOverwriteMode(false);
        editor[i].setCursorWidth(2);
        editor[i].setBackgroundVisible(true);
        editor[i].setCenterOnScroll(false);
        editor[i].setAcceptDrops(false);

        editor[i].setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
        editor[i].setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded);

        editor[i].setFont(font);                        //  apply selected font for text editor
        QFontMetrics metrics(editor[i].font());         //  refresh tab width to appropriate value using font metrics
        editor[i].setTabStopWidth(4 * metrics.width(' '));
    }

    font.setPointSize(12);                              //  set desired font size for help screen text
    font.setBold(true);                                 //  font in help screen is always bold
                                                        //  initialize help screen attributes(it is still editor, but with editing disabled)
    ui->help_editor->setContextMenuPolicy(Qt::NoContextMenu);
    ui->help_editor->setMinimumHeight(0);
    ui->help_editor->setAutoFillBackground(true);
    ui->help_editor->setFrameShape(QFrame::NoFrame);
    ui->help_editor->setTabChangesFocus(false);
    ui->help_editor->setUndoRedoEnabled(false);
    ui->help_editor->setLineWrapMode(QPlainTextEdit::NoWrap);
    ui->help_editor->setReadOnly(true);                 //  help screen content cannot be modified by user
    ui->help_editor->setOverwriteMode(false);
    ui->help_editor->setTabStopWidth(40);
    ui->help_editor->setCursorWidth(2);
    ui->help_editor->setBackgroundVisible(true);
    ui->help_editor->setCenterOnScroll(false);
    ui->help_editor->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
    ui->help_editor->setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded);
    ui->help_editor->setFont(font);                     //  apply selected font for text editor
    font.setBold(false);
    ui->help_editor->setPlainText("INFORMATION\n"
        "   Press escape key to close this help screen\n"
        "\nDESCRIPTION\n"
        "   Spade is fast and lightweight cross-platform code editor with syntax highlighting\n"
        "   Editor supports many well known programming languages\n"
        "   Editor provides advanced manipulation with projects and code building\n"
        "   Editor has been made to be simple and user-friendly but it provides functionality for both beginners and advanced users\n"
        "   Interface of editor is built from many trays to provide fast and easy manipulation with opened documents\n"
        "   Interface can be hidden to allow maximum concentration to source code\n"
        "   Editor stays in same state as it was before its closing so user don't need to take care about saving files before exit\n"
        "   It is allowed to insert custom color highlighting into any opened document to give special meaning to some parts of text\n"
        "   Editor allows users to define syntax highlighting for custom programming language\n"
        "   Editor provides Vim-style editing for any opened text document and supports advanced Vim features for text manipulation\n"
        "\nHINTS\n"
        "   Line and column number will be shown when cursor enters line numbers area\n"
        "   All optional parameters of application can be paths to source files which have to be opened in editor\n"
        "   Stability problems and application crashing can be solved by removing all its configuration files\n"
        "\nKEYBOARD SHORTCUTS\n"
        "   Full screen           Alt + Enter\n"
        "   Insert mode           Insert\n"
        "   Line begin            Home\n"
        "   Line end              End\n"
        "   File begin            Ctrl + Home\n"
        "   File end              Ctrl + End\n"
        "   Select all            Ctrl + A\n"
        "   Copy                  Ctrl + C\n"
        "   Paste                 Ctrl + V\n"
        "   Cut                   Ctrl + X\n"
        "   Delete line           Ctrl + K\n"
        "   Undo                  Ctrl + Z\n"
        "   Redo                  Ctrl + Shift + Z\n"
        "   Open file             Ctrl + O\n"
        "   New tab               Ctrl + N\n"
        "   Close file            Ctrl + W\n"
        "   Save file             Ctrl + S\n"
        "   Save all              Ctrl + Shift + S\n"
        "   Find                  Ctrl + F\n"
        "   Swap lines up         Ctrl + Shift + Up\n"
        "   Swap lines down       Ctrl + Shift + Down\n"
        "   Upper case swap       Ctrl + U\n"
        "   Lower case swap       Ctrl + L\n"
        "   Toggle comment        Ctrl + /\n"
        "   Increase font size    Ctrl + Plus\n"
        "   Decrease font size    Ctrl + Minus\n"
        "   Move tab up           Ctrl + PageUp\n"
        "   Move tab down         Ctrl + PageDown\n"
        "   Move scrollbar up     Ctrl + Up\n"
        "   Move scrollbar down   Ctrl + Down\n"
        "   Run application       Ctrl + R\n"
        "   Build project         Ctrl + B\n"
        "   Exit program          Ctrl + Q\n"
        "\nVIM\n"
        "   Vim-style editing for any opened text document can be activated using appropriate button in actions menu\n"
        "   Vim-style editing is very similar to default Vim editor and all Vim commands below are supported\n"
        "   All Vim modes(command mode, insert mode, visual mode and replace mode) are supported\n"
        "\nVIM COMMANDS\n"
        "   Save changes                                 :w\n"
        "   Quit Vim editing                             :q\n"
        "   Force quit                                   :q!\n"
        "   Save changes and quit                        :wq\n"
        "   Search command                               /\n"
        "   Activate insert mode on actual character     i\n"
        "   Activate insert mode on next character       a\n"
        "   Activate insert mode on line begin           I\n"
        "   Activate insert mode on line end             A\n"
        "   Activate insert mode on next line            o\n"
        "   Activate insert mode on previous line        O\n"
        "   Activate visual mode                         v\n"
        "   Activate replace mode                        R\n"
        "   Move to end of word                          e\n"
        "   Move to next word                            w\n"
        "   Move to begin of word                        b\n"
        "   Move to end of character sequence            E\n"
        "   Move to next character sequence              W\n"
        "   Move to begin of character sequence          B\n"
        "   Move left                                    h\n"
        "   Move down                                    j\n"
        "   Move up                                      k\n"
        "   Move right                                   l\n"
        "   Move to next sentence                        )\n"
        "   Move to previous sentence                    (\n"
        "   Move to next paragraph                       }\n"
        "   Move to previous paragraph                   {\n"
        "   Move to line begin                           0\n"
        "   Move to text begin on line                   ^\n"
        "   Move to line end                             $\n"
        "   Move to specified character                  f\n"
        "   Move to specified character backwards        F\n"
        "   Move before specified character              t\n"
        "   Move before specified character backwards    T\n"
        "   Replace actual character by new character    r\n"
        "   Delete text specified by following commmand  d\n"
        "   Delete specified text and go to insert mode  c\n"
        "   Delete actual line                           dd\n"
        "   Delete actual line and go to insert mode     cc\n"
        "   Lower case convert by following commmand     gu\n"
        "   Upper case convert by following commmand     gU\n"
        "   Jump to first line of text document          gg\n"
        "   Jump to specified line of text document      Ngg\n"
        "   Jump to last line of text document           G\n"
        "   Undo command                                 u\n"
        "   Redo command                                 Ctrl + R\n"
        "   Copy selected text into register             y\n"
        "   Paste text from register into document       p\n"
        "   Replace first old part of line by new        :s/old/new\n"
        "   Replace all old parts of line by new         :s/old/new/g\n"
        "   Replace first old part of some line by new   :Ns/old/new\n"
        "   Replace all old parts of some line by new    :Ns/old/new/g\n"
        "   Replace first old part in line range by new  :M,Ns/old/new\n"
        "   Replace all old parts in line range by new   :M,Ns/old/new/g\n"
        "   Replace first old part of all lines by new   :%s/old/new\n"
        "   Replace all old parts of all lines by new    :%s/old/new/g\n"
        "   Multiplication of any following command      N\n"
        "\nABOUT\n"
        "   Version 1.8");

    init_palette(3);
    ui->help_editor->setPalette(* theme_color);         //  set color pallete for help screen

    QTextCharFormat fmt;                                //  create local text char format to allow text highlighting
    fmt.setForeground(QColor(200, 0, 0));
    * text_cursor = ui->help_editor->textCursor();
                                                        //  highlight all titles in help screen text
    text_cursor->setPosition(0, QTextCursor::MoveAnchor);
    text_cursor->setPosition(11, QTextCursor::KeepAnchor);
    text_cursor->setCharFormat(fmt);
    text_cursor->setPosition(59, QTextCursor::MoveAnchor);
    text_cursor->setPosition(70, QTextCursor::KeepAnchor);
    text_cursor->setCharFormat(fmt);
    text_cursor->setPosition(1045, QTextCursor::MoveAnchor);
    text_cursor->setPosition(1050, QTextCursor::KeepAnchor);
    text_cursor->setCharFormat(fmt);
    text_cursor->setPosition(1335, QTextCursor::MoveAnchor);
    text_cursor->setPosition(1354, QTextCursor::KeepAnchor);
    text_cursor->setCharFormat(fmt);
    text_cursor->setPosition(2533, QTextCursor::MoveAnchor);
    text_cursor->setPosition(2536, QTextCursor::KeepAnchor);
    text_cursor->setCharFormat(fmt);
    text_cursor->setPosition(2834, QTextCursor::MoveAnchor);
    text_cursor->setPosition(2846, QTextCursor::KeepAnchor);
    text_cursor->setCharFormat(fmt);
    text_cursor->setPosition(5808, QTextCursor::MoveAnchor);
    text_cursor->setPosition(5813, QTextCursor::KeepAnchor);
    text_cursor->setCharFormat(fmt);
                                                        //  add all editor tabs into appropriate layouts from Qt Designer
    ui->tab_1_v_layout->addWidget(editor);
    ui->tab_2_v_layout->addWidget(editor + 1);
    ui->tab_3_v_layout->addWidget(editor + 2);
    ui->tab_4_v_layout->addWidget(editor + 3);
    ui->tab_5_v_layout->addWidget(editor + 4);
    ui->tab_6_v_layout->addWidget(editor + 5);
    ui->tab_7_v_layout->addWidget(editor + 6);
    ui->tab_8_v_layout->addWidget(editor + 7);
    ui->tab_9_v_layout->addWidget(editor + 8);
    ui->tab_10_v_layout->addWidget(editor + 9);
    ui->tab_11_v_layout->addWidget(editor + 10);
    ui->tab_12_v_layout->addWidget(editor + 11);
    ui->tab_13_v_layout->addWidget(editor + 12);
    ui->tab_14_v_layout->addWidget(editor + 13);
    ui->tab_15_v_layout->addWidget(editor + 14);
    ui->tab_16_v_layout->addWidget(editor + 15);
    ui->tab_17_v_layout->addWidget(editor + 16);
    ui->tab_18_v_layout->addWidget(editor + 17);
    ui->tab_19_v_layout->addWidget(editor + 18);
    ui->tab_20_v_layout->addWidget(editor + 19);
    ui->tab_21_v_layout->addWidget(editor + 20);
    ui->tab_22_v_layout->addWidget(editor + 21);
    ui->tab_23_v_layout->addWidget(editor + 22);
    ui->tab_24_v_layout->addWidget(editor + 23);
    ui->tab_25_v_layout->addWidget(editor + 24);
    ui->tab_26_v_layout->addWidget(editor + 25);
    ui->tab_27_v_layout->addWidget(editor + 26);
    ui->tab_28_v_layout->addWidget(editor + 27);
    ui->tab_29_v_layout->addWidget(editor + 28);
    ui->tab_30_v_layout->addWidget(editor + 29);
    ui->tab_31_v_layout->addWidget(editor + 30);
    ui->tab_32_v_layout->addWidget(editor + 31);
    ui->tab_33_v_layout->addWidget(editor + 32);
    ui->tab_34_v_layout->addWidget(editor + 33);
    ui->tab_35_v_layout->addWidget(editor + 34);
    ui->tab_36_v_layout->addWidget(editor + 35);
    ui->tab_37_v_layout->addWidget(editor + 36);
    ui->tab_38_v_layout->addWidget(editor + 37);
    ui->tab_39_v_layout->addWidget(editor + 38);
    ui->tab_40_v_layout->addWidget(editor + 39);
    ui->tab_41_v_layout->addWidget(editor + 40);
    ui->tab_42_v_layout->addWidget(editor + 41);
    ui->tab_43_v_layout->addWidget(editor + 42);
    ui->tab_44_v_layout->addWidget(editor + 43);
    ui->tab_45_v_layout->addWidget(editor + 44);
    ui->tab_46_v_layout->addWidget(editor + 45);
    ui->tab_47_v_layout->addWidget(editor + 46);
    ui->tab_48_v_layout->addWidget(editor + 47);
    ui->tab_49_v_layout->addWidget(editor + 48);
    ui->tab_50_v_layout->addWidget(editor + 49);
    ui->help_tab_v_layout->addWidget(ui->help_editor);

    ui->class_tree->header()->setSectionResizeMode(QHeaderView::ResizeToContents);
    setLayout(ui->main_v_layout);                       //  set main layout to application

    init_interface();                                   //  initialize visual interface of text editor
    init_tabs();                                        //  initialize all tabs of text editor

    QObject::connect(ui->class_tree, SIGNAL(left_mouse_clicked(QModelIndex)), this, SLOT(class_tree_item_left_clicked(QModelIndex)));
    QObject::connect(ui->class_tree, SIGNAL(right_mouse_clicked(QModelIndex)), this, SLOT(class_tree_item_right_clicked(QModelIndex)));
                                                        //  connect timeout signals timers with appropriate methods
    QObject::connect(cursor_timer, SIGNAL(timeout()), this, SLOT(handle_cursor_timeout()));
    QObject::connect(text_change_timer, SIGNAL(timeout()), this, SLOT(handle_text_change_timeout()));

    for (int i = 0; i < max_tabs; i++)                  //  iterate through all text editor tabs
    {
        QObject::connect((editor + i)->verticalScrollBar(), SIGNAL(valueChanged(int)), this, SLOT(slider_position_changed()));  //  handle slider position change
        QObject::connect(editor + i, SIGNAL(textChanged()), this, SLOT(editor_text_changed()));     //  handle text editor content change
        QObject::connect(editor + i, SIGNAL(cursorPositionChanged()), this, SLOT(cursor_position_changed()));   //  handle cursor position change
        QObject::connect(editor + i, SIGNAL(selectionChanged()), this, SLOT(cursor_position_changed()));    //  handle text selection change
                                                        //  connect signals of special keyboard shortcuts with appropriate slots
        QObject::connect(editor + i, SIGNAL(save_signal()), this, SLOT(save_button_pressed()));
        QObject::connect(editor + i, SIGNAL(open_signal()), this, SLOT(open_button_pressed()));
        QObject::connect(editor + i, SIGNAL(new_tab_signal()), this, SLOT(new_tab_button_pressed()));
        QObject::connect(editor + i, SIGNAL(close_signal()), this, SLOT(close_tab_button_pressed()));
        QObject::connect(editor + i, SIGNAL(fullscreen_signal()), this, SLOT(fullscreen_button_pressed()));
        QObject::connect(editor + i, SIGNAL(exit_signal()), this, SLOT(exit_editor()));
        QObject::connect(editor + i, SIGNAL(save_all_signal()), this, SLOT(save_all_button_pressed()));
        QObject::connect(editor + i, SIGNAL(find_signal()), this, SLOT(find_now()));
        QObject::connect(editor + i, SIGNAL(swap_line_up_signal()), this, SLOT(swap_line_up_button_pressed()));
        QObject::connect(editor + i, SIGNAL(swap_line_down_signal()), this, SLOT(swap_line_down_button_pressed()));
        QObject::connect(editor + i, SIGNAL(uppercase_signal()), this, SLOT(upper_case_button_pressed()));
        QObject::connect(editor + i, SIGNAL(lowercase_signal()), this, SLOT(lower_case_button_pressed()));
        QObject::connect(editor + i, SIGNAL(comment_signal()), this, SLOT(toggle_comment()));
        QObject::connect(editor + i, SIGNAL(increase_font_size_signal()), this, SLOT(increase_font_size()));
        QObject::connect(editor + i, SIGNAL(decrease_font_size_signal()), this, SLOT(decrease_font_size()));
        QObject::connect(editor + i, SIGNAL(move_tab_up_signal()), this, SLOT(move_tab_up()));
        QObject::connect(editor + i, SIGNAL(move_tab_down_signal()), this, SLOT(move_tab_down()));
        QObject::connect(editor + i, SIGNAL(move_scrollbar_up_signal()), this, SLOT(move_scrollbar_up()));
        QObject::connect(editor + i, SIGNAL(move_scrollbar_down_signal()), this, SLOT(move_scrollbar_down()));
        QObject::connect(editor + i, SIGNAL(tab_signal()), this, SLOT(handle_tab_press()));
        QObject::connect(editor + i, SIGNAL(shift_tab_signal()), this, SLOT(handle_shift_tab_press()));
        QObject::connect(editor + i, SIGNAL(enter_signal()), this, SLOT(handle_enter_press()));
        QObject::connect(editor + i, SIGNAL(classic_bracket_signal()), this, SLOT(handle_classic_bracket_press()));
        QObject::connect(editor + i, SIGNAL(block_bracket_signal()), this, SLOT(handle_block_bracket_press()));
        QObject::connect(editor + i, SIGNAL(array_bracket_signal()), this, SLOT(handle_array_bracket_press()));
        QObject::connect(editor + i, SIGNAL(run_signal()), this, SLOT(run_button_pressed()));
        QObject::connect(editor + i, SIGNAL(build_signal()), this, SLOT(build_button_pressed()));

        QObject::connect(editor + i, SIGNAL(vim_key_press_signal(int,QString)), this, SLOT(vim_key_press(int,QString)));

        QObject::connect(*(highlighters + i), SIGNAL(block_signal(int)), this, SLOT(handle_block(int)));
    }

    for (int i = 0; i < theme_count; i++)               //  iterate through all theme images
    {
        QObject::connect(theme_image + i, SIGNAL(clicked(int)), this, SLOT(clickable_label_pressed(int)));      //  handle theme image press event
        QObject::connect(theme_image + i, SIGNAL(entered(int)), this, SLOT(clickable_label_entered(int)));      //  handle theme image enter event
    }
                                                        //  connect signals of file tray visual elements with appropriate slots
    QObject::connect(undo_button, SIGNAL(clicked(bool)), this, SLOT(undo_button_pressed()));
    QObject::connect(redo_button, SIGNAL(clicked(bool)), this, SLOT(redo_button_pressed()));
    QObject::connect(save_all_button, SIGNAL(clicked(bool)), this, SLOT(save_all_button_pressed()));
    QObject::connect(scroll_bars_button, SIGNAL(clicked(bool)), this, SLOT(scroll_bars_button_pressed()));
    QObject::connect(reload_button, SIGNAL(clicked(bool)), this, SLOT(reload_button_pressed()));
    QObject::connect(tab_width, SIGNAL(highlighted(int)), this, SLOT(tab_width_selected(int)));
    QObject::connect(layouts, SIGNAL(currentIndexChanged(int)), this, SLOT(layout_selected(int)));
    QObject::connect(back_button, SIGNAL(clicked(bool)), this, SLOT(back_button_pressed()));
                                                        //  connect signals of paint tray visual elements with appropriate slots
    QObject::connect(color_button, SIGNAL(clicked(bool)), this, SLOT(color_button_pressed()));
    QObject::connect(apply_button, SIGNAL(clicked(bool)), this, SLOT(apply_button_pressed()));
    QObject::connect(rubber_button, SIGNAL(clicked(bool)), this, SLOT(rubber_button_pressed()));
    QObject::connect(undo_button_2, SIGNAL(clicked(bool)), this, SLOT(undo_button_2_pressed()));
    QObject::connect(clear_button, SIGNAL(clicked(bool)), this, SLOT(clear_button_pressed()));
    QObject::connect(back_button_2, SIGNAL(clicked(bool)), this, SLOT(back_button_2_pressed()));
                                                        //  connect signals of actions tray visual elements with appropriate slots
    QObject::connect(find_button, SIGNAL(clicked(bool)), this, SLOT(find_button_pressed()));
    QObject::connect(swap_line_up_button, SIGNAL(clicked(bool)), this, SLOT(swap_line_up_button_pressed()));
    QObject::connect(swap_line_down_button, SIGNAL(clicked(bool)), this, SLOT(swap_line_down_button_pressed()));
    QObject::connect(upper_case_button, SIGNAL(clicked(bool)), this, SLOT(upper_case_button_pressed()));
    QObject::connect(lower_case_button, SIGNAL(clicked(bool)), this, SLOT(lower_case_button_pressed()));
    QObject::connect(swap_case_button, SIGNAL(clicked(bool)), this, SLOT(swap_case_button_pressed()));
    QObject::connect(bold_button, SIGNAL(clicked(bool)), this, SLOT(bold_button_pressed()));
    QObject::connect(italic_button, SIGNAL(clicked(bool)), this, SLOT(italic_button_pressed()));
    QObject::connect(vim_button, SIGNAL(clicked(bool)), this, SLOT(vim_button_pressed()));
    QObject::connect(concept_button, SIGNAL(clicked(bool)), this, SLOT(concept_button_pressed()));
    QObject::connect(help_button, SIGNAL(clicked(bool)), this, SLOT(help_button_pressed()));
    QObject::connect(back_button_3, SIGNAL(clicked(bool)), this, SLOT(back_button_3_pressed()));
                                                        //  connect signals of find tray visual elements with appropriate slots
    QObject::connect(find_previous_button, SIGNAL(clicked(bool)), this, SLOT(find_previous_button_pressed()));
    QObject::connect(find_next_button, SIGNAL(clicked(bool)), this, SLOT(find_next_button_pressed()));
    QObject::connect(find_line_edit, SIGNAL(returnPressed()), this, SLOT(find_next_button_pressed()));
    QObject::connect(replace_button, SIGNAL(clicked(bool)), this, SLOT(replace_button_pressed()));
    QObject::connect(replace_all_button, SIGNAL(clicked(bool)), this, SLOT(replace_all_button_pressed()));
    QObject::connect(replace_line_edit, SIGNAL(returnPressed()), this, SLOT(replace_button_pressed()));
    QObject::connect(regex_button, SIGNAL(clicked(bool)), this, SLOT(regex_button_pressed()));
    QObject::connect(case_button, SIGNAL(clicked(bool)), this, SLOT(case_button_pressed()));
    QObject::connect(boundary_button, SIGNAL(clicked(bool)), this, SLOT(boundary_button_pressed()));
    QObject::connect(back_button_4, SIGNAL(clicked(bool)), this, SLOT(back_button_4_pressed()));
                                                        //  connect signals of template tray visual elements with appropriate slots
    QObject::connect(template_style_button_1, SIGNAL(clicked(bool)), this, SLOT(template_style_button_1_pressed()));
    QObject::connect(template_style_button_2, SIGNAL(clicked(bool)), this, SLOT(template_style_button_2_pressed()));
    QObject::connect(template_style_button_3, SIGNAL(clicked(bool)), this, SLOT(template_style_button_3_pressed()));
    QObject::connect(template_style_button_4, SIGNAL(clicked(bool)), this, SLOT(template_style_button_4_pressed()));
    QObject::connect(template_style_button_5, SIGNAL(clicked(bool)), this, SLOT(template_style_button_5_pressed()));
    QObject::connect(template_style_button_6, SIGNAL(clicked(bool)), this, SLOT(template_style_button_6_pressed()));
    QObject::connect(template_style_button_7, SIGNAL(clicked(bool)), this, SLOT(template_style_button_7_pressed()));
    QObject::connect(template_style_button_8, SIGNAL(clicked(bool)), this, SLOT(template_style_button_8_pressed()));
    QObject::connect(template_style_button_9, SIGNAL(clicked(bool)), this, SLOT(template_style_button_9_pressed()));
    QObject::connect(template_style_button_10, SIGNAL(clicked(bool)), this, SLOT(template_style_button_10_pressed()));
    QObject::connect(back_button_5, SIGNAL(clicked(bool)), this, SLOT(back_button_5_pressed()));
                                                        //  connect signals of language tray visual elements with appropriate slots
    QObject::connect(send_horizontal_button, SIGNAL(clicked(bool)), this, SLOT(send_horizontal_button_pressed()));
    QObject::connect(send_vertical_button, SIGNAL(clicked(bool)), this, SLOT(send_vertical_button_pressed()));
    QObject::connect(send_diagonal_button, SIGNAL(clicked(bool)), this, SLOT(send_diagonal_button_pressed()));
    QObject::connect(send_all_button, SIGNAL(clicked(bool)), this, SLOT(send_all_button_pressed()));
    QObject::connect(change_button, SIGNAL(clicked(bool)), this, SLOT(change_button_pressed()));
    QObject::connect(add_button, SIGNAL(clicked(bool)), this, SLOT(add_button_pressed()));
    QObject::connect(delete_button, SIGNAL(clicked(bool)), this, SLOT(delete_button_pressed()));
    QObject::connect(back_button_6, SIGNAL(clicked(bool)), this, SLOT(back_button_6_pressed()));
                                                        //  connect signals of vim tray visual elements with appropriate slots
    QObject::connect(vim_edit, SIGNAL(returnPressed()), this, SLOT(vim_edit_accepted()));
                                                        //  connect signals of projects tray visual elements with appropriate slots
    QObject::connect(language, SIGNAL(currentIndexChanged(int)), this, SLOT(project_language_selected(int)));
    QObject::connect(new_project_button, SIGNAL(clicked(bool)), this, SLOT(new_project_button_pressed()));
    QObject::connect(open_project_button, SIGNAL(clicked(bool)), this, SLOT(open_project_button_pressed()));
    QObject::connect(source_button, SIGNAL(clicked(bool)), this, SLOT(source_button_pressed()));
    QObject::connect(delete_button_2, SIGNAL(clicked(bool)), this, SLOT(delete_button_2_pressed()));
    QObject::connect(projects, SIGNAL(currentIndexChanged(int)), this, SLOT(project_selected(int)));
    QObject::connect(class_tree_button, SIGNAL(clicked(bool)), this, SLOT(class_tree_button_pressed()));
    QObject::connect(makefile_button, SIGNAL(clicked(bool)), this, SLOT(makefile_button_pressed()));
    QObject::connect(toggle_button, SIGNAL(clicked(bool)), this, SLOT(toggle_button_pressed()));
    QObject::connect(delete_button_3, SIGNAL(clicked(bool)), this, SLOT(delete_button_3_pressed()));
    QObject::connect(run_button, SIGNAL(clicked(bool)), this, SLOT(run_button_pressed()));
    QObject::connect(build_button, SIGNAL(clicked(bool)), this, SLOT(build_button_pressed()));
    QObject::connect(clean_button, SIGNAL(clicked(bool)), this, SLOT(clean_button_pressed()));
    QObject::connect(back_button_7, SIGNAL(clicked(bool)), this, SLOT(back_button_7_pressed()));
                                                        //  connect signals of parameters tray visual elements with appropriate slots
    QObject::connect(back_button_8, SIGNAL(clicked(bool)), this, SLOT(back_button_8_pressed()));
                                                        //  connect signals of main tray visual elements with appropriate slots
    QObject::connect(files, SIGNAL(highlighted(int)), this, SLOT(file_selected(int)));
    QObject::connect(save_button, SIGNAL(clicked(bool)), this, SLOT(save_button_pressed()));
    QObject::connect(open_button, SIGNAL(clicked(bool)), this, SLOT(open_button_pressed()));
    QObject::connect(new_tab_button, SIGNAL(clicked(bool)), this, SLOT(new_tab_button_pressed()));
    QObject::connect(close_tab_button, SIGNAL(clicked(bool)), this, SLOT(close_tab_button_pressed()));
    QObject::connect(font_size, SIGNAL(highlighted(int)), this, SLOT(font_size_selected(int)));
    QObject::connect(template_button, SIGNAL(clicked(bool)), this, SLOT(template_button_pressed()));
    QObject::connect(comments_button, SIGNAL(clicked(bool)), this, SLOT(comments_button_pressed()));
    QObject::connect(paint_button, SIGNAL(clicked(bool)), this, SLOT(paint_button_pressed()));
    QObject::connect(theme_button, SIGNAL(clicked(bool)), this, SLOT(theme_button_pressed()));
    QObject::connect(languages, SIGNAL(currentIndexChanged(int)), this, SLOT(language_selected(int)));
    QObject::connect(file_button, SIGNAL(clicked(bool)), this, SLOT(file_button_pressed()));
    QObject::connect(project_button, SIGNAL(clicked(bool)), this, SLOT(project_button_pressed()));
    QObject::connect(fullscreen_button, SIGNAL(clicked(bool)), this, SLOT(fullscreen_button_pressed()));
    QObject::connect(menu_button, SIGNAL(clicked(bool)), this, SLOT(menu_button_pressed()));

    QObject::connect(files_watcher, SIGNAL(fileChanged(QString)), this, SLOT(handle_file_change(QString)));

    QObject::connect(ui->widget, SIGNAL(save_signal()), this, SLOT(language_saved()));
    QObject::connect(ui->widget, SIGNAL(cancel_signal()), this, SLOT(language_canceled()));
}


/// Try to open all command line parameters as files in text editor
void Spade::handle_parameters()
{
    open_button_pressed();
}


/// Class destructor
Spade::~Spade()
{
    delete ui;
}


/// Redefine reactions for click to particular keys
///
/// @param
/// Generic Qt key press event handler
void Spade::keyPressEvent(QKeyEvent * event)            //  recognize pressed key on keyboard
{
    if (help_flag)                                      //  help screen is active
    {
        if (event->key() == Qt::Key_Escape)             //  Escape key
        {
            ui->tabs->setCurrentIndex(active_tabs[files->currentIndex()].index_in_tabs);    //  move back to actual tab in text editor
            show_actions_tray();                        //  show actions tray

            help_flag = false;                          //  disable help flag
        }
        else if (event->key() == Qt::Key_F11)           //  F11
            fullscreen_button_pressed();
        else if (event->key() == Qt::Key_Enter || event->key() == Qt::Key_Return)
        {
            if (event->modifiers() & Qt::AltModifier)   //  Alt + Enter
                fullscreen_button_pressed();
        }
        else if (event->key() == Qt::Key_Q)             //  Alt + Q
        {
            if (event->modifiers() & Qt::ControlModifier)
                emit exit_signal();
        }
    }
    else if (language_flag)                             //  help language is active
    {
        if (event->key() == Qt::Key_Escape)             //  Escape key
            language_canceled();
        else if (event->key() == Qt::Key_F11)           //  F11
            fullscreen_button_pressed();
        else if (event->key() == Qt::Key_Enter || event->key() == Qt::Key_Return)
        {
            if (event->modifiers() & Qt::AltModifier)   //  Alt + Enter
                fullscreen_button_pressed();
        }
        else if (event->key() == Qt::Key_Q)             //  Alt + Q
        {
            if (event->modifiers() & Qt::ControlModifier)
                emit exit_signal();
        }
    }
    else                                                //  help screen is not active
    {
        if (event->key() == Qt::Key_Escape)             //  Escape
        {
            if (vim_tray_visible)
            {
                int index = active_tabs[files->currentIndex()].index_in_tabs;

                if (editor[index].vim_active)
                {
                    vim_prefix->hide();
                    vim_edit->clear();
                    vim_edit->setReadOnly(true);
                    editor[index].setOverwriteMode(true);
                    editor[index].setReadOnly(false);
                    editor[index].setFocus();
                }
                else
                {
                    vim_prefix->hide();
                    vim_edit->clear();
                    vim_edit->setReadOnly(true);
                    editor[index].setOverwriteMode(true);
                    editor[index].setReadOnly(false);
                    editor[index].setFocus();
                    vim_visual_flag = false;                    //  disable Vim visual flag
                    vim_replace_flag = false;                   //  disable Vim replace flag

                    editor[index].vim_active = true;

                    * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                    text_cursor->setPosition(text_cursor->position() - 1);
                    editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                }
            }
            else
            {
                if (interface_visible)                      //  show appropriate active tray if visual interface is visible
                {
                    if (theme_tray_visible)
                        hide_theme_tray();
                    else if (file_tray_visible)
                        hide_file_tray();
                    else if (paint_tray_visible)
                        hide_paint_tray();
                    else if (actions_tray_visible)
                        hide_actions_tray();
                    else if (find_tray_visible)
                        hide_find_tray();
                    else if (template_tray_visible)
                        hide_template_tray();
                    else if (language_tray_visible)
                        hide_language_tray();
                    else if (projects_tray_visible)
                        hide_projects_tray();
                    else if (parameters_tray_visible)
                        hide_parameters_tray();
                    else
                        hide_tray();
                }
                else                                        //  hide appropriate active tray if visual interface is not visible
                {
                    if (theme_tray_visible)
                        show_theme_tray();
                    else if (file_tray_visible)
                        show_file_tray();
                    else if (paint_tray_visible)
                        show_paint_tray();
                    else if (actions_tray_visible)
                        show_actions_tray();
                    else if (find_tray_visible)
                        show_find_tray();
                    else if (template_tray_visible)
                        show_template_tray();
                    else if (language_tray_visible)
                        show_language_tray();
                    else if (projects_tray_visible)
                        show_projects_tray();
                    else if (parameters_tray_visible)
                        show_parameters_tray();
                    else
                        show_tray();
                }

                interface_visible = !interface_visible;     //  toggle interface visibility
            }
        }
        else if (event->key() == Qt::Key_F1)            //  F1
        {                                               //  map F1 key to appropriate push button in active tray to allow key shortcut
            if (interface_visible)
            {
                if (tray_visible)
                    save_button_pressed();
                else if (projects_tray_visible)
                    new_project_button_pressed();
                else if (language_tray_visible)
                    send_horizontal_button_pressed();
                else if (template_tray_visible)
                    template_style_button_1_pressed();
                else if (find_tray_visible)
                    find_previous_button_pressed();
                else if (actions_tray_visible)
                    find_button_pressed();
                else if (paint_tray_visible)
                    color_button_pressed();
                else if (file_tray_visible)
                    undo_button_pressed();
            }
        }
        else if (event->key() == Qt::Key_F2)            //  F2
        {                                               //  map F2 key to appropriate push button in active tray to allow key shortcut
            if (interface_visible)
            {
                if (tray_visible)
                    open_button_pressed();
                else if (projects_tray_visible)
                    open_project_button_pressed();
                else if (language_tray_visible)
                    send_vertical_button_pressed();
                else if (template_tray_visible)
                    template_style_button_2_pressed();
                else if (find_tray_visible)
                    find_next_button_pressed();
                else if (actions_tray_visible)
                    swap_line_up_button_pressed();
                else if (paint_tray_visible)
                    apply_button_pressed();
                else if (file_tray_visible)
                    redo_button_pressed();
            }
        }
        else if (event->key() == Qt::Key_F3)            //  F3
        {                                               //  map F3 key to appropriate push button in active tray to allow key shortcut
            if (interface_visible)
            {
                if (tray_visible)
                    new_tab_button_pressed();
                else if (projects_tray_visible)
                    source_button_pressed();
                else if (language_tray_visible)
                    send_diagonal_button_pressed();
                else if (template_tray_visible)
                    template_style_button_3_pressed();
                else if (find_tray_visible)
                    replace_button_pressed();
                else if (actions_tray_visible)
                    swap_line_down_button_pressed();
                else if (paint_tray_visible)
                    rubber_button_pressed();
                else if (file_tray_visible)
                    save_all_button_pressed();
            }
        }
        else if (event->key() == Qt::Key_F4)            //  F4
        {                                               //  map F4 key to appropriate push button in active tray to allow key shortcut
            if (interface_visible)
            {
                if (tray_visible)
                    close_tab_button_pressed();
                else if (projects_tray_visible)
                    delete_button_2_pressed();
                else if (language_tray_visible)
                    send_all_button_pressed();
                else if (template_tray_visible)
                    template_style_button_4_pressed();
                else if (find_tray_visible)
                    replace_all_button_pressed();
                else if (actions_tray_visible)
                    upper_case_button_pressed();    //  convert selected text into uppercase text
                else if (paint_tray_visible)
                    undo_button_2_pressed();
                else if (file_tray_visible)
                    scroll_bars_button_pressed();
            }
        }
        else if (event->key() == Qt::Key_F5)            //  F5
        {                                               //  map F5 key to appropriate push button in active tray to allow key shortcut
            if (interface_visible)
            {
                if (tray_visible)
                    template_button_pressed();
                else if (projects_tray_visible)
                    class_tree_button_pressed();
                else if (language_tray_visible)
                    change_button_pressed();
                else if (template_tray_visible)
                    template_style_button_5_pressed();
                else if (find_tray_visible)
                    regex_button_pressed();
                else if (actions_tray_visible)
                    lower_case_button_pressed();    //  convert selected text into lowercase text
                else if (paint_tray_visible)
                    clear_button_pressed();
                else if (file_tray_visible)
                    reload_button_pressed();
            }
        }
        else if (event->key() == Qt::Key_F6)            //  F6
        {                                               //  map F6 key to appropriate push button in active tray to allow key shortcut
            if (interface_visible)
            {
                if (tray_visible)
                    comments_button_pressed();
                else if (projects_tray_visible)
                    makefile_button_pressed();                  //  new Makefile needs to be generated to allow project compilation
                else if (language_tray_visible)
                    add_button_pressed();
                else if (template_tray_visible)
                    template_style_button_6_pressed();
                else if (find_tray_visible)
                    case_button_pressed();
                else if (actions_tray_visible)
                    swap_case_button_pressed();
            }
        }
        else if (event->key() == Qt::Key_F7)            //  F7
        {                                               //  map F7 key to appropriate push button in active tray to allow key shortcut
            if (interface_visible)
            {
                if (tray_visible)
                    paint_button_pressed();
                else if (projects_tray_visible)
                    toggle_button_pressed();
                else if (language_tray_visible)
                    delete_button_pressed();
                else if (template_tray_visible)
                    template_style_button_7_pressed();
                else if (find_tray_visible)
                    boundary_button_pressed();
                else if (actions_tray_visible)
                    bold_button_pressed();
            }
        }
        else if (event->key() == Qt::Key_F8)            //  F8
        {                                               //  map F8 key to appropriate push button in active tray to allow key shortcut
            if (interface_visible)
            {
                if (tray_visible)
                    theme_button_pressed();
                else if (projects_tray_visible)
                    delete_button_3_pressed();
                else if (template_tray_visible)
                    template_style_button_8_pressed();
                else if (actions_tray_visible)
                    italic_button_pressed();
            }
        }
        else if (event->key() == Qt::Key_F9)            //  F9
        {                                               //  map F9 key to appropriate push button in active tray to allow key shortcut
            if (interface_visible)
            {
                if (tray_visible)
                    file_button_pressed();
                else if (projects_tray_visible)
                    run_button_pressed();
                else if (template_tray_visible)
                    template_style_button_9_pressed();
                else if (actions_tray_visible)
                    vim_button_pressed();
            }
        }
        else if (event->key() == Qt::Key_F10)           //  F10
        {                                               //  map F10 key to appropriate push button in active tray to allow key shortcut
            if (interface_visible)
            {
                if (tray_visible)
                    project_button_pressed();
                else if (projects_tray_visible)
                    build_button_pressed();
                else if (template_tray_visible)
                    template_style_button_10_pressed();
                else if (actions_tray_visible)
                    concept_button_pressed();
            }
        }
        else if (event->key() == Qt::Key_F11)           //  F11
        {                                               //  map F11 key to appropriate push button in active tray to allow key shortcut
            if (interface_visible)
            {
                if (actions_tray_visible)
                    help_button_pressed();
                else if (projects_tray_visible)
                    clean_button_pressed();
                else
                    fullscreen_button_pressed();
            }
            else
                fullscreen_button_pressed();
        }
        else if (event->key() == Qt::Key_F12)           //  F12
        {                                               //  map F12 key to appropriate push button in active tray to allow key shortcut
            if (interface_visible)
            {
                if (tray_visible)
                    menu_button_pressed();
                else if (parameters_tray_visible)
                    back_button_8_pressed();
                else if (projects_tray_visible)
                    back_button_7_pressed();
                else if (language_tray_visible)
                    back_button_6_pressed();
                else if (template_tray_visible)
                    back_button_5_pressed();
                else if (find_tray_visible)
                    back_button_4_pressed();
                else if (actions_tray_visible)
                    back_button_3_pressed();
                else if (paint_tray_visible)
                    back_button_2_pressed();
                else if (file_tray_visible)
                    back_button_pressed();
            }
        }
        else if (event->key() == Qt::Key_Insert)        //  Insert
        {                                               //  toggle insert mode of actual text editor tab
            int index = active_tabs[files->currentIndex()].index_in_tabs;
            insert_mode = !insert_mode;
            editor[index].setOverwriteMode(insert_mode);
        }
    }

    event->ignore();
}


/// Initialize all color palettes
///
/// @param
/// Integer value which represents color theme
void Spade::init_palette(int theme)
{
    if (theme == 0)                                     //  first theme is active
    {
        theme_color->setColor(QPalette::Background, QColor(38, 38, 38));    //  set background color for editor
        theme_color->setColor(QPalette::Highlight, Qt::white);          //  set highlight color for editor
        theme_color->setColor(QPalette::HighlightedText, Qt::black);    //  set highlighted text color for editor
        theme_color->setColor(QPalette::Base, QColor(38, 38, 38));      //  set base color for editor
        theme_color->setColor(QPalette::Text, Qt::white);               //  set text color for editor
    }
    else if (theme == 1)                                //  second theme is active
    {
        theme_color->setColor(QPalette::Background, QColor(253, 246, 227));     //  set background color for editor
        theme_color->setColor(QPalette::Highlight, Qt::black);          //  set highlight color for editor
        theme_color->setColor(QPalette::HighlightedText, Qt::white);    //  set highlighted text color for editor
        theme_color->setColor(QPalette::Base, QColor(253, 246, 227));   //  set base color for editor
        theme_color->setColor(QPalette::Text, Qt::black);               //  set text color for editor
    }
    else if (theme == 2)                                //  third theme is active
    {
        theme_color->setColor(QPalette::Background, Qt::black);         //  set background color for editor
        theme_color->setColor(QPalette::Highlight, Qt::white);          //  set highlight color for editor
        theme_color->setColor(QPalette::HighlightedText, Qt::black);    //  set highlighted text color for editor
        theme_color->setColor(QPalette::Base, Qt::black);               //  set base color for editor
        theme_color->setColor(QPalette::Text, Qt::white);               //  set text color for editor
    }
    else if (theme == 3)                                //  fourth theme is active
    {
        theme_color->setColor(QPalette::Background, QColor(242, 241, 240));     //  set background color for editor
        theme_color->setColor(QPalette::Highlight, Qt::black);          //  set highlight color for editor
        theme_color->setColor(QPalette::HighlightedText, Qt::white);    //  set highlighted text color for editor
        theme_color->setColor(QPalette::Base, QColor(242, 241, 240));   //  set base color for editor
        theme_color->setColor(QPalette::Text, Qt::black);               //  set text color for editor
    }
    else if (theme == 4)                                //  fifth theme is active
    {
        theme_color->setColor(QPalette::Background, QColor(2, 9, 28));  //  set background color for editor
        theme_color->setColor(QPalette::Highlight, Qt::white);          //  set highlight color for editor
        theme_color->setColor(QPalette::HighlightedText, Qt::black);    //  set highlighted text color for editor
        theme_color->setColor(QPalette::Base, QColor(2, 9, 28));        //  set base color for editor
        theme_color->setColor(QPalette::Text, QColor(35, 235, 195));    //  set text color for editor
    }
    else if (theme == 5)                                //  sixth theme is active
    {
        theme_color->setColor(QPalette::Background, Qt::white);         //  set background color for editor
        theme_color->setColor(QPalette::Highlight, Qt::black);          //  set highlight color for editor
        theme_color->setColor(QPalette::HighlightedText, Qt::white);    //  set highlighted text color for editor
        theme_color->setColor(QPalette::Base, Qt::white);               //  set base color for editor
        theme_color->setColor(QPalette::Text, QColor(90, 90, 90));      //  set text color for editor
    }
}


/// Initialize visual interface of text editor
void Spade::init_interface()
{                                                       //  allocate memory for all trays horizontal layouts
    file_tray_h_layout = new QHBoxLayout;
    paint_tray_h_layout = new QHBoxLayout;
    actions_tray_h_layout = new QHBoxLayout;
    find_tray_h_layout = new QHBoxLayout;
    template_tray_h_layout = new QHBoxLayout;
    language_tray_h_layout = new QHBoxLayout;
    vim_tray_h_layout = new QHBoxLayout;
    projects_tray_h_layout = new QHBoxLayout;
    parameters_tray_h_layout = new QHBoxLayout;
    tray_h_layout = new QHBoxLayout;
                                                        //  allocate memory for all theme images and its pixmaps
    theme_image = new RichLabel[theme_count];
    theme_pixmap = new QPixmap[theme_count];
                                                        //  allocate memory for all icons
    bold_off_icon = new QIcon(":/resources/bold_off.png");
    bold_on_icon = new QIcon(":/resources/bold_on.png");
    boundary_off_icon = new QIcon(":/resources/boundary_off.png");
    boundary_on_icon = new QIcon(":/resources/boundary_on.png");
    build_icon = new QIcon(":/resources/build.png");
    class_off_icon = new QIcon(":/resources/class_off.png");
    class_on_icon = new QIcon(":/resources/class_on.png");
    class_icon = new QIcon(":/resources/class.png");
    close_icon = new QIcon(":/resources/close.png");
    code_icon = new QIcon(":/resources/code.png");
    comments_off_icon = new QIcon(":/resources/comments_off.png");
    comments_on_icon = new QIcon(":/resources/comments_on.png");
    concept_icon = new QIcon(":/resources/concept.png");
    down_icon = new QIcon(":/resources/down.png");
    diagonal_icon_1 = new QIcon(":/resources/diagonal_1.png");
    diagonal_icon_2 = new QIcon(":/resources/diagonal_2.png");
    diagonal_icon_3 = new QIcon(":/resources/diagonal_3.png");
    diagonal_icon_4 = new QIcon(":/resources/diagonal_4.png");
    enum_icon = new QIcon(":/resources/enum.png");
    file_icon = new QIcon(":/resources/file.png");
    find_icon = new QIcon(":/resources/find.png");
    folder_icon = new QIcon(":/resources/folder.png");
    fullscreen_off_icon = new QIcon(":/resources/fullscreen_off.png");
    fullscreen_on_icon = new QIcon(":/resources/fullscreen_on.png");
    help_icon = new QIcon(":/resources/help.png");
    home_icon = new QIcon(":/resources/home.png");
    italic_off_icon = new QIcon(":/resources/italic_off.png");
    italic_on_icon = new QIcon(":/resources/italic_on.png");
    lower_icon = new QIcon(":/resources/lower.png");
    menu_icon = new QIcon(":/resources/menu.png");
    new_tab_icon = new QIcon(":/resources/new_tab.png");
    paint_icon = new QIcon(":/resources/paint.png");
    private_attribute_icon = new QIcon(":/resources/private_attribute.png");
    private_method_icon = new QIcon(":/resources/private_method.png");
    project_icon = new QIcon(":/resources/project.png");
    protected_attribute_icon = new QIcon(":/resources/protected_attribute.png");
    protected_method_icon = new QIcon(":/resources/protected_method.png");
    public_attribute_icon = new QIcon(":/resources/public_attribute.png");
    public_method_icon = new QIcon(":/resources/public_method.png");
    redo_icon = new QIcon(":/resources/redo.png");
    regex_icon = new QIcon(":/resources/regex.png");
    reload_icon = new QIcon(":/resources/reload.png");
    replace_all_icon = new QIcon(":/resources/replace_all.png");
    replace_icon = new QIcon(":/resources/replace.png");
    rubber_icon = new QIcon(":/resources/rubber.png");
    save_icon = new QIcon(":/resources/save.png");
    scroll_bars_off_icon = new QIcon(":/resources/scroll_bars_off.png");
    scroll_bars_on_icon = new QIcon(":/resources/scroll_bars_on.png");
    static_private_attribute_icon = new QIcon(":/resources/static_private_attribute.png");
    static_private_method_icon = new QIcon(":/resources/static_private_method.png");
    static_protected_attribute_icon = new QIcon(":/resources/static_protected_attribute.png");
    static_protected_method_icon = new QIcon(":/resources/static_protected_method.png");
    static_public_attribute_icon = new QIcon(":/resources/static_public_attribute.png");
    static_public_method_icon = new QIcon(":/resources/static_public_method.png");
    struct_icon = new QIcon(":/resources/struct.png");
    swap_icon = new QIcon(":/resources/swap.png");
    text_icon = new QIcon(":/resources/text.png");
    theme_icon = new QIcon(":/resources/theme.png");
    undo_icon = new QIcon(":/resources/undo.png");
    upper_icon = new QIcon(":/resources/upper.png");
    up_icon = new QIcon(":/resources/up.png");
    vim_icon = new QIcon(":/resources/vim.png");
    warning_icon = new QIcon(":/resources/warning.png");
    yes_icon = new QIcon(":/resources/yes.png");
                                                        //  allocate memory for all visual elements in file tray
    undo_button = new QPushButton;
    redo_button = new QPushButton;
    save_all_button = new QPushButton;
    scroll_bars_button = new QPushButton;
    reload_button = new QPushButton;
    tab_width = new QComboBox;
    layouts = new QComboBox;
    back_button = new QPushButton;
                                                        //  allocate memory for all visual elements in paint tray
    color_pixmap = new QPixmap(18, 18);
    color_button = new QPushButton;
    apply_button = new QPushButton;
    rubber_button = new QPushButton;
    undo_button_2 = new QPushButton;
    clear_button = new QPushButton;
    back_button_2 = new QPushButton;
                                                        //  allocate memory for all visual elements in actions tray
    find_button = new QPushButton;
    swap_line_up_button = new QPushButton;
    swap_line_down_button = new QPushButton;
    upper_case_button = new QPushButton;
    lower_case_button = new QPushButton;
    swap_case_button = new QPushButton;
    bold_button = new QPushButton;
    italic_button = new QPushButton;
    vim_button = new QPushButton;
    concept_button = new QPushButton;
    help_button = new QPushButton;
    back_button_3 = new QPushButton;
                                                        //  allocate memory for all visual elements in find tray
    find_previous_button = new QPushButton;
    find_next_button = new QPushButton;
    find_line_edit = new QLineEdit;
    replace_button = new QPushButton;
    replace_all_button = new QPushButton;
    replace_line_edit = new QLineEdit;
    regex_button = new QPushButton;
    case_button = new QPushButton;
    boundary_button = new QPushButton;
    back_button_4 = new QPushButton;
                                                        //  allocate memory for all visual elements in template tray
    template_style_button_1 = new QPushButton;
    template_style_button_2 = new QPushButton;
    template_style_button_3 = new QPushButton;
    template_style_button_4 = new QPushButton;
    template_style_button_5 = new QPushButton;
    template_style_button_6 = new QPushButton;
    template_style_button_7 = new QPushButton;
    template_style_button_8 = new QPushButton;
    template_style_button_9 = new QPushButton;
    template_style_button_10 = new QPushButton;
    template_count = new QComboBox;
    back_button_5 = new QPushButton;
                                                        //  allocate memory for all visual elements in language tray
    custom_languages = new QComboBox;
    send_horizontal_button = new QPushButton;
    send_vertical_button = new QPushButton;
    send_diagonal_button = new QPushButton;
    send_all_button = new QPushButton;
    change_button = new QPushButton;
    add_button = new QPushButton;
    delete_button = new QPushButton;
    back_button_6 = new QPushButton;
                                                        //  allocate memory for all visual elements in vim tray
    vim_prefix = new QLineEdit;
    vim_edit = new QLineEdit;
    vim_coordinates = new QLineEdit;
    vim_position = new QLineEdit;
                                                        //  allocate memory for all visual elements in projects tray
    language = new QComboBox;
    new_project_button = new QPushButton;
    open_project_button = new QPushButton;
    source_button = new QPushButton;
    delete_button_2 = new QPushButton;
    projects = new QComboBox;
    class_tree_button = new QPushButton;
    makefile_button = new QPushButton;
    toggle_button = new QPushButton;
    delete_button_3 = new QPushButton;
    source_files = new QComboBox;
    run_button = new QPushButton;
    build_button = new QPushButton;
    clean_button = new QPushButton;
    back_button_7 = new QPushButton;
                                                        //  allocate memory for all visual elements in parameters tray
    run_parameters = new QLineEdit;
    compile_parameters = new QLineEdit;
    make_parameters = new QLineEdit;
    terminal_name = new QLineEdit;
    back_button_8 = new QPushButton;
                                                        //  allocate memory for all visual elements in main tray
    files = new QComboBox;
    save_button = new QPushButton;
    file_dialog = new QFileDialog;
    open_button = new QPushButton;
    new_tab_button = new QPushButton;
    close_tab_button = new QPushButton;
    font_size = new QComboBox;
    template_button = new QPushButton;
    comments_button = new QPushButton;
    paint_button = new QPushButton;
    theme_button = new QPushButton;
    languages = new QComboBox;
    file_button = new QPushButton;
    project_button = new QPushButton;
    fullscreen_button = new QPushButton;
    menu_button = new QPushButton;

    files_watcher = new QFileSystemWatcher;             //  allocate memory for file system watcher

    theme_pixmap[0].load(":/resources/theme_1.png");    //  load concrete images into theme images pixmaps
    theme_pixmap[1].load(":/resources/theme_2.png");
    theme_pixmap[2].load(":/resources/theme_3.png");
    theme_pixmap[3].load(":/resources/theme_4.png");
    theme_pixmap[4].load(":/resources/theme_5.png");
    theme_pixmap[5].load(":/resources/theme_6.png");

    for (int i = 0; i < theme_count; i++)               //  initialize all theme images
    {
        theme_image[i].id = i;
        theme_image[i].setMinimumSize(250, 176);
        theme_image[i].setMaximumSize(250, 176);
        theme_image[i].setPixmap(theme_pixmap[i]);
        theme_image[i].setScaledContents(false);
    }
                                                        //  initialize all visual elements in file tray
    undo_button->setIcon(* undo_icon);
    undo_button->setIconSize(QSize(30, 30));
    undo_button->setMinimumSize(30, 30);
    undo_button->setMaximumSize(30, 30);
    undo_button->setToolTip("Undo (F1)");
    undo_button->setDisabled(true);
    redo_button->setIcon(* redo_icon);
    redo_button->setIconSize(QSize(30, 30));
    redo_button->setMinimumSize(30, 30);
    redo_button->setMaximumSize(30, 30);
    redo_button->setToolTip("Redo (F2)");
    redo_button->setDisabled(true);
    save_all_button->setIcon(* save_icon);
    save_all_button->setIconSize(QSize(30, 30));
    save_all_button->setMinimumSize(30, 30);
    save_all_button->setMaximumSize(30, 30);
    save_all_button->setToolTip("Save all opened files (F3)");
    scroll_bars_button->setIcon(* scroll_bars_on_icon);
    scroll_bars_button->setIconSize(QSize(30, 30));
    scroll_bars_button->setMinimumSize(30, 30);
    scroll_bars_button->setMaximumSize(30, 30);
    scroll_bars_button->setToolTip("Toggle visibility of scroll bars (F4)");
    reload_button->setIcon(* reload_icon);
    reload_button->setIconSize(QSize(30, 30));
    reload_button->setMinimumSize(30, 30);
    reload_button->setMaximumSize(30, 30);
    reload_button->setToolTip("Reload content of file (F5)");
    tab_width->setMinimumSize(50, 30);
    tab_width->setMaximumSize(50, 30);
    tab_width->setMaxVisibleItems(30);
    tab_width->setMaxCount(8);
    tab_width->addItem("1");
    tab_width->addItem("2");
    tab_width->addItem("3");
    tab_width->addItem("4");
    tab_width->addItem("5");
    tab_width->addItem("6");
    tab_width->addItem("7");
    tab_width->addItem("8");
    tab_width->setCurrentIndex(3);
    tab_width->setToolTip("Tab width");
    layouts->setMinimumSize(100, 30);
    layouts->setMaximumSize(100, 30);
    layouts->setMaxVisibleItems(4);
    layouts->setMaxCount(4);
    layouts->addItem("Grid");
    layouts->addItem("Rows");
    layouts->addItem("Columns");
    layouts->addItem("Single");
    layouts->setCurrentIndex(3);
    layouts->setToolTip("Layout");
    back_button->setIcon(* home_icon);
    back_button->setIconSize(QSize(30, 30));
    back_button->setMinimumSize(30, 30);
    back_button->setMaximumSize(30, 30);
    back_button->setToolTip("Move back to tray (F12)");
                                                        //  initialize all visual elements in paint tray
    color.setRgb(255, 0, 0, 50);                        //  set default color of icon on color push button
    color_pixmap->fill(color);
    color_button->setIcon(QIcon(* color_pixmap));
    color_button->setIconSize(QSize(18, 18));
    color_button->setMinimumSize(30, 30);
    color_button->setMaximumSize(30, 30);
    color_button->setToolTip("Actual color of custom highlighting (F1)");
    apply_button->setIcon(* paint_icon);
    apply_button->setIconSize(QSize(30, 30));
    apply_button->setMinimumSize(30, 30);
    apply_button->setMaximumSize(30, 30);
    apply_button->setToolTip("Apply custom highlight in range of actual selection in text (F2)");
    rubber_button->setIcon(* rubber_icon);
    rubber_button->setIconSize(QSize(30, 30));
    rubber_button->setMinimumSize(30, 30);
    rubber_button->setMaximumSize(30, 30);
    rubber_button->setToolTip("Remove any custom highlight by inserting text cursor into its range (F3)");
    undo_button_2->setIcon(* undo_icon);
    undo_button_2->setIconSize(QSize(30, 30));
    undo_button_2->setMinimumSize(30, 30);
    undo_button_2->setMaximumSize(30, 30);
    undo_button_2->setToolTip("Remove last custom highlight from text (F4)");
    clear_button->setIcon(* close_icon);
    clear_button->setIconSize(QSize(30, 30));
    clear_button->setMinimumSize(30, 30);
    clear_button->setMaximumSize(30, 30);
    clear_button->setToolTip("Remove all custom highlights from text (F5)");
    back_button_2->setIcon(* home_icon);
    back_button_2->setIconSize(QSize(30, 30));
    back_button_2->setMinimumSize(30, 30);
    back_button_2->setMaximumSize(30, 30);
    back_button_2->setToolTip("Move back to tray (F12)");
                                                        //  initialize all visual elements in actions tray
    find_button->setIcon(* find_icon);
    find_button->setIconSize(QSize(30, 30));
    find_button->setMinimumSize(30, 30);
    find_button->setMaximumSize(30, 30);
    find_button->setToolTip("Find text patterns in actual document content (F1)");
    swap_line_up_button->setIcon(* up_icon);
    swap_line_up_button->setIconSize(QSize(30, 30));
    swap_line_up_button->setMinimumSize(30, 30);
    swap_line_up_button->setMaximumSize(30, 30);
    swap_line_up_button->setToolTip("Swap selected lines up (F2)");
    swap_line_down_button->setIcon(* down_icon);
    swap_line_down_button->setIconSize(QSize(30, 30));
    swap_line_down_button->setMinimumSize(30, 30);
    swap_line_down_button->setMaximumSize(30, 30);
    swap_line_down_button->setToolTip("Swap selected lines down (F3)");
    upper_case_button->setIcon(* upper_icon);
    upper_case_button->setIconSize(QSize(30, 30));
    upper_case_button->setMinimumSize(30, 30);
    upper_case_button->setMaximumSize(30, 30);
    upper_case_button->setToolTip("Convert all characters in selected text to upper case (F4)");
    lower_case_button->setIcon(* lower_icon);
    lower_case_button->setIconSize(QSize(30, 30));
    lower_case_button->setMinimumSize(30, 30);
    lower_case_button->setMaximumSize(30, 30);
    lower_case_button->setToolTip("Convert all characters in selected text to lower case (F5)");
    swap_case_button->setIcon(* swap_icon);
    swap_case_button->setIconSize(QSize(30, 30));
    swap_case_button->setMinimumSize(30, 30);
    swap_case_button->setMaximumSize(30, 30);
    swap_case_button->setToolTip("Swap case of all characters in selected text (F6)");
    bold_button->setIcon(* bold_off_icon);
    bold_button->setIconSize(QSize(30, 30));
    bold_button->setMinimumSize(30, 30);
    bold_button->setMaximumSize(30, 30);
    bold_button->setToolTip("Enable or disable bold font for all opened documents (F7)");
    italic_button->setIcon(* italic_off_icon);
    italic_button->setIconSize(QSize(30, 30));
    italic_button->setMinimumSize(30, 30);
    italic_button->setMaximumSize(30, 30);
    italic_button->setToolTip("Enable or disable italic font for all opened documents (F8)");
    vim_button->setIcon(* vim_icon);
    vim_button->setIconSize(QSize(30, 30));
    vim_button->setMinimumSize(30, 30);
    vim_button->setMaximumSize(30, 30);
    vim_button->setToolTip("Open Vim-style editing for actual document (F9)");
    concept_button->setIcon(* concept_icon);
    concept_button->setIconSize(QSize(30, 30));
    concept_button->setMinimumSize(30, 30);
    concept_button->setMaximumSize(30, 30);
    concept_button->setToolTip("Create syntax highlighting for your own programming language (F10)");
    help_button->setIcon(* help_icon);
    help_button->setIconSize(QSize(30, 30));
    help_button->setMinimumSize(30, 30);
    help_button->setMaximumSize(30, 30);
    help_button->setToolTip("Show help window (F11)");
    back_button_3->setIcon(* home_icon);
    back_button_3->setIconSize(QSize(30, 30));
    back_button_3->setMinimumSize(30, 30);
    back_button_3->setMaximumSize(30, 30);
    back_button_3->setToolTip("Move back to tray (F12)");
                                                        //  initialize all visual elements in find tray
    find_previous_button->setIcon(* undo_icon);
    find_previous_button->setIconSize(QSize(30, 30));
    find_previous_button->setMinimumSize(30, 30);
    find_previous_button->setMaximumSize(30, 30);
    find_previous_button->setToolTip("Find previous occurrence of pattern in document (F1)");
    find_next_button->setIcon(* redo_icon);
    find_next_button->setIconSize(QSize(30, 30));
    find_next_button->setMinimumSize(30, 30);
    find_next_button->setMaximumSize(30, 30);
    find_next_button->setToolTip("Find next occurrence of pattern in document (F2)");
    find_line_edit->setMinimumHeight(30);
    find_line_edit->setMaximumHeight(30);
    find_line_edit->setToolTip("Pattern which will be searched in the text");
    find_line_edit->setPlaceholderText("Search pattern");
    replace_button->setIcon(* replace_icon);
    replace_button->setIconSize(QSize(30, 30));
    replace_button->setMinimumSize(30, 30);
    replace_button->setMaximumSize(30, 30);
    replace_button->setToolTip("Replace highlighted pattern with another text (F3)");
    replace_all_button->setIcon(* replace_all_icon);
    replace_all_button->setIconSize(QSize(30, 30));
    replace_all_button->setMinimumSize(30, 30);
    replace_all_button->setMaximumSize(30, 30);
    replace_all_button->setToolTip("Replace all occurrences of pattern with another text (F4)");
    replace_line_edit->setMinimumHeight(30);
    replace_line_edit->setMaximumHeight(30);
    replace_line_edit->setToolTip("Text pattern which will replace found occurrences");
    replace_line_edit->setPlaceholderText("Replace pattern");
    regex_button->setIcon(* text_icon);
    regex_button->setIconSize(QSize(30, 30));
    regex_button->setMinimumSize(30, 30);
    regex_button->setMaximumSize(30, 30);
    regex_button->setToolTip("Toggle between classic text searching or searching using regular expression (F5)");
    case_button->setIcon(* upper_icon);
    case_button->setIconSize(QSize(30, 30));
    case_button->setMinimumSize(30, 30);
    case_button->setMaximumSize(30, 30);
    case_button->setToolTip("Enable or disable case sensitive searching (F6)");
    boundary_button->setIcon(* boundary_off_icon);
    boundary_button->setIconSize(QSize(30, 30));
    boundary_button->setMinimumSize(30, 30);
    boundary_button->setMaximumSize(30, 30);
    boundary_button->setToolTip("Enable or disable searching whole words (F7)");
    back_button_4->setIcon(* home_icon);
    back_button_4->setIconSize(QSize(30, 30));
    back_button_4->setMinimumSize(30, 30);
    back_button_4->setMaximumSize(30, 30);
    back_button_4->setToolTip("Move back to tray (F12)");
                                                        //  initialize all visual elements in template tray
    template_style_button_1->setText("1");
    template_style_button_1->setMinimumSize(50, 30);
    template_style_button_1->setMaximumSize(50, 30);
    template_style_button_1->setToolTip("First code template which can be inserted into the text (F1)");
    template_style_button_2->setText("1.");
    template_style_button_2->setMinimumSize(50, 30);
    template_style_button_2->setMaximumSize(50, 30);
    template_style_button_2->setToolTip("Second code template which can be inserted into the text (F2)");
    template_style_button_3->setText("1)");
    template_style_button_3->setMinimumSize(50, 30);
    template_style_button_3->setMaximumSize(50, 30);
    template_style_button_3->setToolTip("Third code template which can be inserted into the text (F3)");
    template_style_button_4->setText("a");
    template_style_button_4->setMinimumSize(50, 30);
    template_style_button_4->setMaximumSize(50, 30);
    template_style_button_4->setToolTip("Fourth code template which can be inserted into the text (F4)");
    template_style_button_5->setText("a)");
    template_style_button_5->setMinimumSize(50, 30);
    template_style_button_5->setMaximumSize(50, 30);
    template_style_button_5->setToolTip("Fifth code template which can be inserted into the text (F5)");
    template_style_button_6->setText("A");
    template_style_button_6->setMinimumSize(50, 30);
    template_style_button_6->setMaximumSize(50, 30);
    template_style_button_6->setToolTip("Sixth code template which can be inserted into the text (F6)");
    template_style_button_7->setText("A)");
    template_style_button_7->setMinimumSize(50, 30);
    template_style_button_7->setMaximumSize(50, 30);
    template_style_button_7->setToolTip("Seventh code template which can be inserted into the text (F7)");
    template_style_button_8->setText(">");
    template_style_button_8->setMinimumSize(50, 30);
    template_style_button_8->setMaximumSize(50, 30);
    template_style_button_8->setToolTip("Eighth code template which can be inserted into the text (F8)");
    template_style_button_9->setText("-");
    template_style_button_9->setMinimumSize(50, 30);
    template_style_button_9->setMaximumSize(50, 30);
    template_style_button_9->setToolTip("Ninth code template which can be inserted into the text (F9)");
    template_style_button_10->setText("->");
    template_style_button_10->setMinimumSize(50, 30);
    template_style_button_10->setMaximumSize(50, 30);
    template_style_button_10->setToolTip("Last code template which can be inserted into the text (F10)");
    template_count->setMinimumSize(50, 30);
    template_count->setMaximumSize(50, 30);
    template_count->setMaxVisibleItems(26);
    template_count->setMaxCount(26);
    for (int i = 1; i <= 26; i++)
        template_count->addItem(QString("%1").arg(i));
    template_count->setCurrentIndex(4);
    template_count->setToolTip("Value of code variable or number of items in template");
    back_button_5->setIcon(* home_icon);
    back_button_5->setIconSize(QSize(30, 30));
    back_button_5->setMinimumSize(30, 30);
    back_button_5->setMaximumSize(30, 30);
    back_button_5->setToolTip("Move back to tray (F12)");
                                                        //  initialize all visual elements in language tray
    if (which == 1)
    {
        send_horizontal_button->setIcon(* redo_icon);
        send_vertical_button->setIcon(* down_icon);
        send_diagonal_button->setIcon(* diagonal_icon_1);
    }
    else if (which == 2)
    {
        send_horizontal_button->setIcon(* undo_icon);
        send_vertical_button->setIcon(* down_icon);
        send_diagonal_button->setIcon(* diagonal_icon_2);
    }
    else if (which == 3)
    {
        send_horizontal_button->setIcon(* redo_icon);
        send_vertical_button->setIcon(* up_icon);
        send_diagonal_button->setIcon(* diagonal_icon_3);
    }
    else
    {
        send_horizontal_button->setIcon(* undo_icon);
        send_vertical_button->setIcon(* up_icon);
        send_diagonal_button->setIcon(* diagonal_icon_4);
    }
    send_horizontal_button->setIconSize(QSize(30, 30));
    send_horizontal_button->setMinimumSize(30, 30);
    send_horizontal_button->setMaximumSize(30, 30);
    send_horizontal_button->setToolTip("Send selected custom language to editor in horizontal direction (F1)");
    send_vertical_button->setIconSize(QSize(30, 30));
    send_vertical_button->setMinimumSize(30, 30);
    send_vertical_button->setMaximumSize(30, 30);
    send_vertical_button->setToolTip("Send selected custom language to editor in vertical direction (F2)");
    send_diagonal_button->setIconSize(QSize(30, 30));
    send_diagonal_button->setMinimumSize(30, 30);
    send_diagonal_button->setMaximumSize(30, 30);
    send_diagonal_button->setToolTip("Send selected custom language to editor in diagonal direction (F3)");
    send_all_button->setIcon(* replace_all_icon);
    send_all_button->setIconSize(QSize(30, 30));
    send_all_button->setMinimumSize(30, 30);
    send_all_button->setMaximumSize(30, 30);
    send_all_button->setToolTip("Send selected custom language to editors in all directions (F4)");
    custom_languages->setMinimumSize(230, 30);
    custom_languages->setMaximumSize(230, 30);
    custom_languages->setToolTip("List of all custom languages");
    change_button->setIcon(* regex_icon);
    change_button->setIconSize(QSize(30, 30));
    change_button->setMinimumSize(30, 30);
    change_button->setMaximumSize(30, 30);
    change_button->setToolTip("Modify selected custom language (F5)");
    add_button->setIcon(* file_icon);
    add_button->setIconSize(QSize(30, 30));
    add_button->setMinimumSize(30, 30);
    add_button->setMaximumSize(30, 30);
    add_button->setToolTip("Create new custom language (F6)");
    delete_button->setIcon(* close_icon);
    delete_button->setIconSize(QSize(30, 30));
    delete_button->setMinimumSize(30, 30);
    delete_button->setMaximumSize(30, 30);
    delete_button->setToolTip("Delete selected custom language (F7)");
    back_button_6->setIcon(* home_icon);
    back_button_6->setIconSize(QSize(30, 30));
    back_button_6->setMinimumSize(30, 30);
    back_button_6->setMaximumSize(30, 30);
    back_button_6->setToolTip("Move back to tray (F12)");
                                                        //  initialize all visual elements in vim tray
    QPalette palette;
    palette.setColor(QPalette::Base, back_button_6->palette().color(QWidget::backgroundRole()));
    vim_prefix->setMinimumSize(20, 30);
    vim_prefix->setMaximumSize(20, 30);
    vim_prefix->setReadOnly(true);
    vim_prefix->setAlignment(Qt::AlignRight);
    vim_prefix->setFrame(false);
    vim_prefix->setAutoFillBackground(true);
    vim_prefix->setPalette(palette);
    vim_prefix->hide();
    vim_edit->setMinimumSize(300, 30);
    vim_edit->setReadOnly(true);
    vim_edit->setFrame(false);
    vim_edit->setAutoFillBackground(true);
    vim_edit->setPalette(palette);
    vim_character_queue = "";
    vim_find_pattern = "";
    vim_coordinates->setMinimumSize(150, 30);
    vim_coordinates->setMaximumSize(150, 30);
    vim_coordinates->setReadOnly(true);
    vim_coordinates->setFrame(false);
    vim_coordinates->setAutoFillBackground(true);
    vim_coordinates->setPalette(palette);
    vim_position->setMinimumSize(50, 30);
    vim_position->setMaximumSize(50, 30);
    vim_position->setReadOnly(true);
    vim_position->setAlignment(Qt::AlignRight);
    vim_position->setFrame(false);
    vim_position->setAutoFillBackground(true);
    vim_position->setPalette(palette);
                                                        //  initialize all visual elements in projects tray
    language->setMinimumSize(105, 30);
    language->setMaximumSize(105, 30);
    language->setMaxVisibleItems(1000);
    language->setMaxCount(1000);
    language->addItem("C");
    language->addItem("C++");
    language->addItem("Java");
    language->addItem("PHP");
    language->addItem("Plain text");
    language->addItem("Python");
    language->setToolTip("Project language");
    new_project_button->setIcon(* folder_icon);
    new_project_button->setIconSize(QSize(30, 30));
    new_project_button->setMinimumSize(30, 30);
    new_project_button->setMaximumSize(30, 30);
    new_project_button->setToolTip("Select location of new project file (F1)");
    open_project_button->setIcon(* file_icon);
    open_project_button->setIconSize(QSize(30, 30));
    open_project_button->setMinimumSize(30, 30);
    open_project_button->setMaximumSize(30, 30);
    open_project_button->setToolTip("Select location of existing project file (F2)");
    source_button->setIcon(* new_tab_icon);
    source_button->setIconSize(QSize(30, 30));
    source_button->setMinimumSize(30, 30);
    source_button->setMaximumSize(30, 30);
    source_button->setToolTip("Add files to project (F3)");
    source_button->setEnabled(false);
    delete_button_2->setIcon(* close_icon);
    delete_button_2->setIconSize(QSize(30, 30));
    delete_button_2->setMinimumSize(30, 30);
    delete_button_2->setMaximumSize(30, 30);
    delete_button_2->setToolTip("Delete selected project from editor (F4)");
    delete_button_2->setEnabled(false);
    projects->setMinimumSize(10, 30);
    projects->setMaximumSize(16777215, 30);
    projects->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Preferred);
    projects->setMaxVisibleItems(1000);
    projects->setMaxCount(1000);
    projects->addItem("Single file");
    projects->setToolTip("Empty project with single file only");
    projects->setItemData(0, "Empty project with single file only", Qt::ToolTipRole);
    class_tree_button->setIcon(* class_off_icon);
    class_tree_button->setIconSize(QSize(30, 30));
    class_tree_button->setMinimumSize(30, 30);
    class_tree_button->setMaximumSize(30, 30);
    class_tree_button->setToolTip("Toggle class tree visibility (F5)");
    makefile_button->setIcon(* code_icon);
    makefile_button->setIconSize(QSize(30, 30));
    makefile_button->setMinimumSize(30, 30);
    makefile_button->setMaximumSize(30, 30);
    makefile_button->setToolTip("Generate new Makefile for actual project (F6)");
    makefile_button->setEnabled(false);
    toggle_button->setIcon(* swap_icon);
    toggle_button->setIconSize(QSize(30, 30));
    toggle_button->setMinimumSize(30, 30);
    toggle_button->setMaximumSize(30, 30);
    toggle_button->setToolTip("Set parameters of Makefile and executable (F7)");
    delete_button_3->setIcon(* close_icon);
    delete_button_3->setIconSize(QSize(30, 30));
    delete_button_3->setMinimumSize(30, 30);
    delete_button_3->setMaximumSize(30, 30);
    delete_button_3->setToolTip("Remove selected file from project (F8)");
    delete_button_3->setEnabled(false);
    source_files->setMinimumSize(10, 30);
    source_files->setMaximumSize(16777215, 30);
    source_files->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Preferred);
    source_files->setMaxVisibleItems(1000);
    source_files->setMaxCount(1000);
    run_button->setIcon(* project_icon);
    run_button->setIconSize(QSize(30, 30));
    run_button->setMinimumSize(30, 30);
    run_button->setMaximumSize(30, 30);
    run_button->setToolTip("Build and run (F9)");
    build_button->setIcon(* build_icon);
    build_button->setIconSize(QSize(30, 30));
    build_button->setMinimumSize(30, 30);
    build_button->setMaximumSize(30, 30);
    build_button->setToolTip("Build (F10)");
    build_button->setEnabled(false);
    clean_button->setIcon(* rubber_icon);
    clean_button->setIconSize(QSize(30, 30));
    clean_button->setMinimumSize(30, 30);
    clean_button->setMaximumSize(30, 30);
    clean_button->setToolTip("Clean all (F11)");
    clean_button->setEnabled(false);
    back_button_7->setIcon(* home_icon);
    back_button_7->setIconSize(QSize(30, 30));
    back_button_7->setMinimumSize(30, 30);
    back_button_7->setMaximumSize(30, 30);
    back_button_7->setToolTip("Move back to tray (F12)");
                                                        //  initialize all visual elements in parameters tray
    run_parameters->setMinimumSize(50, 30);
    run_parameters->setToolTip("Program paramaters");
    run_parameters->setPlaceholderText("Program paramaters");
    compile_parameters->setMinimumSize(50, 30);
    compile_parameters->setToolTip("Compiler parameters");
    compile_parameters->setPlaceholderText("Compiler parameters");
    make_parameters->setMinimumSize(50, 30);
    make_parameters->setToolTip("Makefile parameters");
    make_parameters->setPlaceholderText("Makefile parameters");
    terminal_name->setMinimumSize(50, 30);
    terminal_name->setToolTip("Default terminal emulation application");
    terminal_name->setPlaceholderText("Default terminal");
    terminal_name->setText("gnome-terminal");
    back_button_8->setIcon(* home_icon);
    back_button_8->setIconSize(QSize(30, 30));
    back_button_8->setMinimumSize(30, 30);
    back_button_8->setMaximumSize(30, 30);
    back_button_8->setToolTip("Move back to tray (F12)");
                                                        //  initialize all visual elements in main tray
    files->setMinimumSize(10, 30);
    files->setMaxVisibleItems(max_tabs);
    files->setMaxCount(max_tabs);
    save_button->setIcon(* save_icon);
    save_button->setIconSize(QSize(30, 30));
    save_button->setMinimumSize(30, 30);
    save_button->setMaximumSize(30, 30);
    save_button->setToolTip("Save changes into file (F1)");
    open_button->setIcon(* file_icon);
    open_button->setIconSize(QSize(30, 30));
    open_button->setMinimumSize(30, 30);
    open_button->setMaximumSize(30, 30);
    open_button->setToolTip("Open new files in new tabs (F2)");
    new_tab_button->setIcon(* new_tab_icon);
    new_tab_button->setIconSize(QSize(30, 30));
    new_tab_button->setMinimumSize(30, 30);
    new_tab_button->setMaximumSize(30, 30);
    new_tab_button->setToolTip("Open new empty tab (F3)");
    close_tab_button->setIcon(* close_icon);
    close_tab_button->setIconSize(QSize(30, 30));
    close_tab_button->setMinimumSize(30, 30);
    close_tab_button->setMaximumSize(30, 30);
    close_tab_button->setToolTip("Close actual file (F4)");
    font_size->setMinimumSize(50, 30);
    font_size->setMaximumSize(50, 30);
    font_size->setMaxVisibleItems(30);
    font_size->setMaxCount(30);
    font_size->addItem("6");
    font_size->addItem("7");
    font_size->addItem("8");
    font_size->addItem("9");
    font_size->addItem("10");
    font_size->addItem("11");
    font_size->addItem("12");
    font_size->addItem("13");
    font_size->addItem("14");
    font_size->addItem("15");
    font_size->addItem("16");
    font_size->addItem("17");
    font_size->addItem("18");
    font_size->addItem("20");
    font_size->addItem("22");
    font_size->addItem("24");
    font_size->addItem("26");
    font_size->addItem("28");
    font_size->addItem("32");
    font_size->addItem("36");
    font_size->addItem("40");
    font_size->addItem("44");
    font_size->addItem("48");
    font_size->addItem("54");
    font_size->addItem("60");
    font_size->addItem("66");
    font_size->addItem("72");
    font_size->addItem("80");
    font_size->addItem("88");
    font_size->addItem("96");
    font_size->setCurrentIndex(4);
    font_size->setToolTip("Font size");
    template_button->setIcon(* code_icon);
    template_button->setIconSize(QSize(30, 30));
    template_button->setMinimumSize(30, 30);
    template_button->setMaximumSize(30, 30);
    template_button->setToolTip("Select template of code which will be inserted into the document (F5)");
    comments_button->setIcon(* comments_on_icon);
    comments_button->setIconSize(QSize(30, 30));
    comments_button->setMinimumSize(30, 30);
    comments_button->setMaximumSize(30, 30);
    comments_button->setToolTip("Toggle visibility of comments in document (F6)");
    paint_button->setIcon(* paint_icon);
    paint_button->setIconSize(QSize(30, 30));
    paint_button->setMinimumSize(30, 30);
    paint_button->setMaximumSize(30, 30);
    paint_button->setToolTip("Insert custom highlighting into the text (F7)");
    theme_button->setIcon(* theme_icon);
    theme_button->setIconSize(QSize(30, 30));
    theme_button->setMinimumSize(30, 30);
    theme_button->setMaximumSize(30, 30);
    theme_button->setToolTip("Select color scheme of actual tab (F8)");
    languages->setMinimumSize(105, 30);
    languages->setMaximumSize(105, 30);
    languages->setMaxVisibleItems(1000);                //  this limit will be increased when more languages will be supported
    languages->setMaxCount(1000);
    languages->addItem("C");
    languages->addItem("C++");
    languages->addItem("Java");
    languages->addItem("PHP");
    languages->addItem("Plain text");
    languages->addItem("Python");
    languages->setCurrentIndex(1);
    languages->setToolTip("Language highlighting");
    file_button->setIcon(* folder_icon);
    file_button->setIconSize(QSize(30, 30));
    file_button->setMinimumSize(30, 30);
    file_button->setMaximumSize(30, 30);
    file_button->setToolTip("Open files menu (F9)");
    project_button->setIcon(* project_icon);
    project_button->setIconSize(QSize(30, 30));
    project_button->setMinimumSize(30, 30);
    project_button->setMaximumSize(30, 30);
    project_button->setToolTip("Manage projects (F10)");
    fullscreen_button->setIcon(* fullscreen_off_icon);
    fullscreen_button->setIconSize(QSize(30, 30));
    fullscreen_button->setMinimumSize(30, 30);
    fullscreen_button->setMaximumSize(30, 30);
    fullscreen_button->setToolTip("Toggle fullscreen view (F11)");
    menu_button->setIcon(* menu_icon);
    menu_button->setIconSize(QSize(30, 30));
    menu_button->setMinimumSize(30, 30);
    menu_button->setMaximumSize(30, 30);
    menu_button->setToolTip("Open menu with actions (F12)");
                                                        //  disable focus of all visual elements in file tray
    undo_button->setFocusPolicy(Qt::NoFocus);
    redo_button->setFocusPolicy(Qt::NoFocus);
    save_all_button->setFocusPolicy(Qt::NoFocus);
    scroll_bars_button->setFocusPolicy(Qt::NoFocus);
    reload_button->setFocusPolicy(Qt::NoFocus);
    tab_width->setFocusPolicy(Qt::NoFocus);
    layouts->setFocusPolicy(Qt::NoFocus);
    back_button->setFocusPolicy(Qt::NoFocus);
                                                        //  disable focus of all visual elements in paint tray
    color_button->setFocusPolicy(Qt::NoFocus);
    apply_button->setFocusPolicy(Qt::NoFocus);
    rubber_button->setFocusPolicy(Qt::NoFocus);
    undo_button_2->setFocusPolicy(Qt::NoFocus);
    clear_button->setFocusPolicy(Qt::NoFocus);
    back_button_2->setFocusPolicy(Qt::NoFocus);
                                                        //  disable focus of all visual elements in actions tray
    find_button->setFocusPolicy(Qt::NoFocus);
    swap_line_up_button->setFocusPolicy(Qt::NoFocus);
    swap_line_down_button->setFocusPolicy(Qt::NoFocus);
    upper_case_button->setFocusPolicy(Qt::NoFocus);
    lower_case_button->setFocusPolicy(Qt::NoFocus);
    swap_case_button->setFocusPolicy(Qt::NoFocus);
    bold_button->setFocusPolicy(Qt::NoFocus);
    italic_button->setFocusPolicy(Qt::NoFocus);
    vim_button->setFocusPolicy(Qt::NoFocus);
    concept_button->setFocusPolicy(Qt::NoFocus);
    help_button->setFocusPolicy(Qt::NoFocus);
    back_button_3->setFocusPolicy(Qt::NoFocus);
                                                        //  disable focus of all visual elements in find tray
    find_previous_button->setFocusPolicy(Qt::NoFocus);
    find_next_button->setFocusPolicy(Qt::NoFocus);
    replace_button->setFocusPolicy(Qt::NoFocus);
    replace_all_button->setFocusPolicy(Qt::NoFocus);
    regex_button->setFocusPolicy(Qt::NoFocus);
    case_button->setFocusPolicy(Qt::NoFocus);
    boundary_button->setFocusPolicy(Qt::NoFocus);
    back_button_4->setFocusPolicy(Qt::NoFocus);
                                                        //  disable focus of all visual elements in template tray
    template_style_button_1->setFocusPolicy(Qt::NoFocus);
    template_style_button_2->setFocusPolicy(Qt::NoFocus);
    template_style_button_3->setFocusPolicy(Qt::NoFocus);
    template_style_button_4->setFocusPolicy(Qt::NoFocus);
    template_style_button_5->setFocusPolicy(Qt::NoFocus);
    template_style_button_6->setFocusPolicy(Qt::NoFocus);
    template_style_button_7->setFocusPolicy(Qt::NoFocus);
    template_style_button_8->setFocusPolicy(Qt::NoFocus);
    template_style_button_9->setFocusPolicy(Qt::NoFocus);
    template_style_button_10->setFocusPolicy(Qt::NoFocus);
    back_button_5->setFocusPolicy(Qt::NoFocus);
                                                        //  disable focus of all visual elements in language tray
    send_horizontal_button->setFocusPolicy(Qt::NoFocus);
    send_vertical_button->setFocusPolicy(Qt::NoFocus);
    send_diagonal_button->setFocusPolicy(Qt::NoFocus);
    send_all_button->setFocusPolicy(Qt::NoFocus);
    custom_languages->setFocusPolicy(Qt::NoFocus);
    change_button->setFocusPolicy(Qt::NoFocus);
    add_button->setFocusPolicy(Qt::NoFocus);
    delete_button->setFocusPolicy(Qt::NoFocus);
    back_button_6->setFocusPolicy(Qt::NoFocus);
                                                        //  disable focus of all visual elements in vim tray
    vim_prefix->setFocusPolicy(Qt::NoFocus);
    vim_edit->setFocusPolicy(Qt::NoFocus);
    vim_coordinates->setFocusPolicy(Qt::NoFocus);
    vim_position->setFocusPolicy(Qt::NoFocus);
                                                        //  disable focus of all visual elements in projects tray
    language->setFocusPolicy(Qt::NoFocus);
    new_project_button->setFocusPolicy(Qt::NoFocus);
    open_project_button->setFocusPolicy(Qt::NoFocus);
    source_button->setFocusPolicy(Qt::NoFocus);
    delete_button_2->setFocusPolicy(Qt::NoFocus);
    projects->setFocusPolicy(Qt::NoFocus);
    class_tree_button->setFocusPolicy(Qt::NoFocus);
    makefile_button->setFocusPolicy(Qt::NoFocus);
    toggle_button->setFocusPolicy(Qt::NoFocus);
    delete_button_3->setFocusPolicy(Qt::NoFocus);
    source_files->setFocusPolicy(Qt::NoFocus);
    run_button->setFocusPolicy(Qt::NoFocus);
    build_button->setFocusPolicy(Qt::NoFocus);
    clean_button->setFocusPolicy(Qt::NoFocus);
    back_button_7->setFocusPolicy(Qt::NoFocus);
                                                        //  disable focus of all visual elements in parameters tray
    back_button_8->setFocusPolicy(Qt::NoFocus);
                                                        //  disable focus of all visual elements in main tray
    files->setFocusPolicy(Qt::NoFocus);
    save_button->setFocusPolicy(Qt::NoFocus);
    open_button->setFocusPolicy(Qt::NoFocus);
    new_tab_button->setFocusPolicy(Qt::NoFocus);
    close_tab_button->setFocusPolicy(Qt::NoFocus);
    font_size->setFocusPolicy(Qt::NoFocus);
    template_button->setFocusPolicy(Qt::NoFocus);
    comments_button->setFocusPolicy(Qt::NoFocus);
    paint_button->setFocusPolicy(Qt::NoFocus);
    theme_button->setFocusPolicy(Qt::NoFocus);
    languages->setFocusPolicy(Qt::NoFocus);
    file_button->setFocusPolicy(Qt::NoFocus);
    project_button->setFocusPolicy(Qt::NoFocus);
    fullscreen_button->setFocusPolicy(Qt::NoFocus);
    menu_button->setFocusPolicy(Qt::NoFocus);

    for (int i = 0; i < 3; i++)                         //  add first three theme images into first theme tray layout
        ui->theme_tray_h_layout_1->addWidget(theme_image + i);

    for (int i = 3; i < theme_count; i++)               //  add rest three theme images into first theme tray layout
        ui->theme_tray_h_layout_2->addWidget(theme_image + i);
                                                        //  add all visual elements in file tray into file tray layout
    file_tray_h_layout->addWidget(undo_button);
    file_tray_h_layout->addWidget(redo_button);
    file_tray_h_layout->addWidget(save_all_button);
    file_tray_h_layout->addWidget(scroll_bars_button);
    file_tray_h_layout->addWidget(reload_button);
    file_tray_h_layout->addWidget(tab_width);
    file_tray_h_layout->addWidget(layouts);
    file_tray_h_layout->addWidget(back_button);
                                                        //  add all visual elements in paint tray into paint tray layout
    paint_tray_h_layout->addWidget(color_button);
    paint_tray_h_layout->addWidget(apply_button);
    paint_tray_h_layout->addWidget(rubber_button);
    paint_tray_h_layout->addWidget(undo_button_2);
    paint_tray_h_layout->addWidget(clear_button);
    paint_tray_h_layout->addWidget(back_button_2);
                                                        //  add all visual elements in actions tray into actions tray layout
    actions_tray_h_layout->addWidget(find_button);
    actions_tray_h_layout->addWidget(swap_line_up_button);
    actions_tray_h_layout->addWidget(swap_line_down_button);
    actions_tray_h_layout->addWidget(upper_case_button);
    actions_tray_h_layout->addWidget(lower_case_button);
    actions_tray_h_layout->addWidget(swap_case_button);
    actions_tray_h_layout->addWidget(bold_button);
    actions_tray_h_layout->addWidget(italic_button);
    actions_tray_h_layout->addWidget(vim_button);
    actions_tray_h_layout->addWidget(concept_button);
    actions_tray_h_layout->addWidget(help_button);
    actions_tray_h_layout->addWidget(back_button_3);
                                                        //  add all visual elements in find tray into find tray layout
    find_tray_h_layout->addWidget(find_previous_button);
    find_tray_h_layout->addWidget(find_next_button);
    find_tray_h_layout->addWidget(find_line_edit);
    find_tray_h_layout->addWidget(replace_button);
    find_tray_h_layout->addWidget(replace_all_button);
    find_tray_h_layout->addWidget(replace_line_edit);
    find_tray_h_layout->addWidget(regex_button);
    find_tray_h_layout->addWidget(case_button);
    find_tray_h_layout->addWidget(boundary_button);
    find_tray_h_layout->addWidget(back_button_4);
                                                        //  add all visual elements in file tray into template tray layout
    template_tray_h_layout->addWidget(template_style_button_1);
    template_tray_h_layout->addWidget(template_style_button_2);
    template_tray_h_layout->addWidget(template_style_button_3);
    template_tray_h_layout->addWidget(template_style_button_4);
    template_tray_h_layout->addWidget(template_style_button_5);
    template_tray_h_layout->addWidget(template_style_button_6);
    template_tray_h_layout->addWidget(template_style_button_7);
    template_tray_h_layout->addWidget(template_style_button_8);
    template_tray_h_layout->addWidget(template_style_button_9);
    template_tray_h_layout->addWidget(template_style_button_10);
    template_tray_h_layout->addWidget(template_count);
    template_tray_h_layout->addWidget(back_button_5);
                                                        //  add all visual elements in file tray into language tray layout
    language_tray_h_layout->addWidget(send_horizontal_button);
    language_tray_h_layout->addWidget(send_vertical_button);
    language_tray_h_layout->addWidget(send_diagonal_button);
    language_tray_h_layout->addWidget(send_all_button);
    language_tray_h_layout->addWidget(custom_languages);
    language_tray_h_layout->addWidget(change_button);
    language_tray_h_layout->addWidget(add_button);
    language_tray_h_layout->addWidget(delete_button);
    language_tray_h_layout->addWidget(back_button_6);
                                                        //  add all visual elements in file tray into vim tray layout
    vim_tray_h_layout->addWidget(vim_prefix);
    vim_tray_h_layout->addWidget(vim_edit);
    vim_tray_h_layout->addWidget(vim_coordinates);
    vim_tray_h_layout->addWidget(vim_position);
                                                        //  add all visual elements in projects tray into main tray layout
    projects_tray_h_layout->addWidget(language);
    projects_tray_h_layout->addWidget(new_project_button);
    projects_tray_h_layout->addWidget(open_project_button);
    projects_tray_h_layout->addWidget(source_button);
    projects_tray_h_layout->addWidget(delete_button_2);
    projects_tray_h_layout->addWidget(projects);
    projects_tray_h_layout->addWidget(class_tree_button);
    projects_tray_h_layout->addWidget(makefile_button);
    projects_tray_h_layout->addWidget(toggle_button);
    projects_tray_h_layout->addWidget(delete_button_3);
    projects_tray_h_layout->addWidget(source_files);
    projects_tray_h_layout->addWidget(run_button);
    projects_tray_h_layout->addWidget(build_button);
    projects_tray_h_layout->addWidget(clean_button);
    projects_tray_h_layout->addWidget(back_button_7);
                                                        //  add all visual elements in file tray into parameters tray layout
    parameters_tray_h_layout->addWidget(run_parameters);
    parameters_tray_h_layout->addWidget(compile_parameters);
    parameters_tray_h_layout->addWidget(make_parameters);
    parameters_tray_h_layout->addWidget(terminal_name);
    parameters_tray_h_layout->addWidget(back_button_8);
                                                        //  add all visual elements in file tray into main tray layout
    tray_h_layout->addWidget(files);
    tray_h_layout->addWidget(save_button);
    tray_h_layout->addWidget(open_button);
    tray_h_layout->addWidget(new_tab_button);
    tray_h_layout->addWidget(close_tab_button);
    tray_h_layout->addWidget(font_size);
    tray_h_layout->addWidget(template_button);
    tray_h_layout->addWidget(comments_button);
    tray_h_layout->addWidget(paint_button);
    tray_h_layout->addWidget(theme_button);
    tray_h_layout->addWidget(languages);
    tray_h_layout->addWidget(file_button);
    tray_h_layout->addWidget(project_button);
    tray_h_layout->addWidget(fullscreen_button);
    tray_h_layout->addWidget(menu_button);
                                                        //  set default spacing for main layouts of all trays of visual interface
    file_tray_h_layout->setSpacing(2);
    paint_tray_h_layout->setSpacing(2);
    actions_tray_h_layout->setSpacing(2);
    find_tray_h_layout->setSpacing(2);
    template_tray_h_layout->setSpacing(2);
    language_tray_h_layout->setSpacing(2);
    vim_tray_h_layout->setSpacing(2);
    projects_tray_h_layout->setSpacing(2);
    parameters_tray_h_layout->setSpacing(2);
    tray_h_layout->setSpacing(2);
    tray_h_layout->setContentsMargins(2, 2, 2, 2);

    for (int i = 0; i < 3; i++)                         //  set vertical alignment for first three theme images
        ui->theme_tray_h_layout_1->setAlignment(theme_image + i, Qt::AlignVCenter);

    for (int i = 3; i < theme_count; i++)               //  set vertical alignment for rest three theme images
        ui->theme_tray_h_layout_2->setAlignment(theme_image + i, Qt::AlignVCenter);

    ui->theme_tray_h_layout_1->setAlignment(Qt::AlignHCenter | Qt::AlignVCenter);   //  center all theme images in first theme tray layout
    ui->theme_tray_h_layout_2->setAlignment(Qt::AlignHCenter | Qt::AlignVCenter);   //  center all theme images in second theme tray layout
                                                        //  set vertical alignment for all visual elements in file tray
    file_tray_h_layout->setAlignment(undo_button, Qt::AlignVCenter);
    file_tray_h_layout->setAlignment(redo_button, Qt::AlignVCenter);
    file_tray_h_layout->setAlignment(save_all_button, Qt::AlignVCenter);
    file_tray_h_layout->setAlignment(scroll_bars_button, Qt::AlignVCenter);
    file_tray_h_layout->setAlignment(reload_button, Qt::AlignVCenter);
    file_tray_h_layout->setAlignment(tab_width, Qt::AlignVCenter);
    file_tray_h_layout->setAlignment(layouts, Qt::AlignVCenter);
    file_tray_h_layout->setAlignment(back_button, Qt::AlignVCenter);
    file_tray_h_layout->setAlignment(Qt::AlignVCenter | Qt::AlignHCenter);  //  center all visual elements in file tray layout
                                                        //  set vertical alignment for all visual elements in paint tray
    paint_tray_h_layout->setAlignment(color_button, Qt::AlignVCenter);
    paint_tray_h_layout->setAlignment(apply_button, Qt::AlignVCenter);
    paint_tray_h_layout->setAlignment(rubber_button, Qt::AlignVCenter);
    paint_tray_h_layout->setAlignment(undo_button_2, Qt::AlignVCenter);
    paint_tray_h_layout->setAlignment(clear_button, Qt::AlignVCenter);
    paint_tray_h_layout->setAlignment(back_button_2, Qt::AlignVCenter);
    paint_tray_h_layout->setAlignment(Qt::AlignVCenter | Qt::AlignHCenter);     //  center all visual elements in paint tray layout
                                                        //  set vertical alignment for all visual elements in actions tray
    actions_tray_h_layout->setAlignment(find_button, Qt::AlignVCenter);
    actions_tray_h_layout->setAlignment(swap_line_up_button, Qt::AlignVCenter);
    actions_tray_h_layout->setAlignment(swap_line_down_button, Qt::AlignVCenter);
    actions_tray_h_layout->setAlignment(upper_case_button, Qt::AlignVCenter);
    actions_tray_h_layout->setAlignment(lower_case_button, Qt::AlignVCenter);
    actions_tray_h_layout->setAlignment(swap_case_button, Qt::AlignVCenter);
    actions_tray_h_layout->setAlignment(bold_button, Qt::AlignVCenter);
    actions_tray_h_layout->setAlignment(italic_button, Qt::AlignVCenter);
    actions_tray_h_layout->setAlignment(vim_button, Qt::AlignVCenter);
    actions_tray_h_layout->setAlignment(concept_button, Qt::AlignVCenter);
    actions_tray_h_layout->setAlignment(help_button, Qt::AlignVCenter);
    actions_tray_h_layout->setAlignment(back_button_3, Qt::AlignVCenter);
    actions_tray_h_layout->setAlignment(Qt::AlignVCenter | Qt::AlignHCenter);   //  center all visual elements in main actions layout
                                                        //  set vertical alignment for all visual elements in find tray
    find_tray_h_layout->setAlignment(find_previous_button, Qt::AlignVCenter);
    find_tray_h_layout->setAlignment(find_next_button, Qt::AlignVCenter);
    find_tray_h_layout->setAlignment(find_line_edit, Qt::AlignVCenter);
    find_tray_h_layout->setAlignment(replace_button, Qt::AlignVCenter);
    find_tray_h_layout->setAlignment(replace_all_button, Qt::AlignVCenter);
    find_tray_h_layout->setAlignment(replace_line_edit, Qt::AlignVCenter);
    find_tray_h_layout->setAlignment(regex_button, Qt::AlignVCenter);
    find_tray_h_layout->setAlignment(case_button, Qt::AlignVCenter);
    find_tray_h_layout->setAlignment(boundary_button, Qt::AlignVCenter);
    find_tray_h_layout->setAlignment(back_button_4, Qt::AlignVCenter);
    find_tray_h_layout->setAlignment(Qt::AlignVCenter | Qt::AlignHCenter);  //  center all visual elements in find tray layout
                                                        //  set vertical alignment for all visual elements in template tray
    template_tray_h_layout->setAlignment(template_style_button_1, Qt::AlignVCenter);
    template_tray_h_layout->setAlignment(template_style_button_2, Qt::AlignVCenter);
    template_tray_h_layout->setAlignment(template_style_button_3, Qt::AlignVCenter);
    template_tray_h_layout->setAlignment(template_style_button_4, Qt::AlignVCenter);
    template_tray_h_layout->setAlignment(template_style_button_5, Qt::AlignVCenter);
    template_tray_h_layout->setAlignment(template_style_button_6, Qt::AlignVCenter);
    template_tray_h_layout->setAlignment(template_style_button_7, Qt::AlignVCenter);
    template_tray_h_layout->setAlignment(template_style_button_8, Qt::AlignVCenter);
    template_tray_h_layout->setAlignment(template_style_button_9, Qt::AlignVCenter);
    template_tray_h_layout->setAlignment(template_style_button_10, Qt::AlignVCenter);
    template_tray_h_layout->setAlignment(template_count, Qt::AlignVCenter);
    template_tray_h_layout->setAlignment(back_button_5, Qt::AlignVCenter);
    template_tray_h_layout->setAlignment(Qt::AlignVCenter | Qt::AlignHCenter);  //  center all visual elements in template tray layout
                                                        //  set vertical alignment for all visual elements in language tray
    language_tray_h_layout->setAlignment(send_horizontal_button, Qt::AlignVCenter);
    language_tray_h_layout->setAlignment(send_vertical_button, Qt::AlignVCenter);
    language_tray_h_layout->setAlignment(send_diagonal_button, Qt::AlignVCenter);
    language_tray_h_layout->setAlignment(send_all_button, Qt::AlignVCenter);
    language_tray_h_layout->setAlignment(custom_languages, Qt::AlignVCenter);
    language_tray_h_layout->setAlignment(change_button, Qt::AlignVCenter);
    language_tray_h_layout->setAlignment(add_button, Qt::AlignVCenter);
    language_tray_h_layout->setAlignment(delete_button, Qt::AlignVCenter);
    language_tray_h_layout->setAlignment(back_button_6, Qt::AlignVCenter);
    language_tray_h_layout->setAlignment(Qt::AlignVCenter | Qt::AlignHCenter);  //  center all visual elements in language tray layout
                                                        //  set vertical alignment for all visual elements in vim tray
    vim_tray_h_layout->setAlignment(vim_prefix, Qt::AlignVCenter);
    vim_tray_h_layout->setAlignment(vim_edit, Qt::AlignVCenter);
    vim_tray_h_layout->setAlignment(vim_coordinates, Qt::AlignVCenter);
    vim_tray_h_layout->setAlignment(vim_position, Qt::AlignVCenter);
    vim_tray_h_layout->setAlignment(Qt::AlignVCenter | Qt::AlignHCenter);  //  center all visual elements in vim tray layout
                                                        //  set vertical alignment for all visual elements in projects tray
    projects_tray_h_layout->setAlignment(language, Qt::AlignVCenter);
    projects_tray_h_layout->setAlignment(new_project_button, Qt::AlignVCenter);
    projects_tray_h_layout->setAlignment(open_project_button, Qt::AlignVCenter);
    projects_tray_h_layout->setAlignment(source_button, Qt::AlignVCenter);
    projects_tray_h_layout->setAlignment(delete_button_2, Qt::AlignVCenter);
    projects_tray_h_layout->setAlignment(projects, Qt::AlignVCenter);
    projects_tray_h_layout->setAlignment(class_tree_button, Qt::AlignVCenter);
    projects_tray_h_layout->setAlignment(makefile_button, Qt::AlignVCenter);
    projects_tray_h_layout->setAlignment(toggle_button, Qt::AlignVCenter);
    projects_tray_h_layout->setAlignment(delete_button_3, Qt::AlignVCenter);
    projects_tray_h_layout->setAlignment(source_files, Qt::AlignVCenter);
    projects_tray_h_layout->setAlignment(run_button, Qt::AlignVCenter);
    projects_tray_h_layout->setAlignment(build_button, Qt::AlignVCenter);
    projects_tray_h_layout->setAlignment(clean_button, Qt::AlignVCenter);
    projects_tray_h_layout->setAlignment(back_button_7, Qt::AlignVCenter);
    projects_tray_h_layout->setAlignment(Qt::AlignVCenter | Qt::AlignHCenter);  //  center all visual elements in vim tray layout
                                                        //  set vertical alignment for all visual elements in parameters tray
    parameters_tray_h_layout->setAlignment(run_parameters, Qt::AlignVCenter);
    parameters_tray_h_layout->setAlignment(compile_parameters, Qt::AlignVCenter);
    parameters_tray_h_layout->setAlignment(make_parameters, Qt::AlignVCenter);
    parameters_tray_h_layout->setAlignment(terminal_name, Qt::AlignVCenter);
    parameters_tray_h_layout->setAlignment(back_button_8, Qt::AlignVCenter);
    parameters_tray_h_layout->setAlignment(Qt::AlignVCenter | Qt::AlignHCenter);  //  center all visual elements in parameters tray layout
                                                        //  set vertical alignment for all visual elements in main tray
    tray_h_layout->setAlignment(files, Qt::AlignVCenter);
    tray_h_layout->setAlignment(save_button, Qt::AlignVCenter);
    tray_h_layout->setAlignment(open_button, Qt::AlignVCenter);
    tray_h_layout->setAlignment(new_tab_button, Qt::AlignVCenter);
    tray_h_layout->setAlignment(close_tab_button, Qt::AlignVCenter);
    tray_h_layout->setAlignment(template_button, Qt::AlignVCenter);
    tray_h_layout->setAlignment(comments_button, Qt::AlignVCenter);
    tray_h_layout->setAlignment(paint_button, Qt::AlignVCenter);
    tray_h_layout->setAlignment(theme_button, Qt::AlignVCenter);
    tray_h_layout->setAlignment(languages, Qt::AlignVCenter);
    tray_h_layout->setAlignment(file_button, Qt::AlignVCenter);
    tray_h_layout->setAlignment(project_button, Qt::AlignVCenter);
    tray_h_layout->setAlignment(fullscreen_button, Qt::AlignVCenter);
    tray_h_layout->setAlignment(menu_button, Qt::AlignVCenter);
    tray_h_layout->setAlignment(Qt::AlignVCenter);      //  vertical center all visual elements in main tray layout

    ui->main_v_layout->addLayout(file_tray_h_layout);   //  add file tray layout into main vertical layout
    ui->main_v_layout->addLayout(paint_tray_h_layout);  //  add paint tray layout into main vertical layout
    ui->main_v_layout->addLayout(actions_tray_h_layout);    //  add actions tray layout into main vertical layout
    ui->main_v_layout->addLayout(find_tray_h_layout);   //  add find tray layout into main vertical layout
    ui->main_v_layout->addLayout(template_tray_h_layout);   //  add template tray layout into main vertical layout
    ui->main_v_layout->addLayout(language_tray_h_layout);   //  add language tray layout into main vertical layout
    ui->main_v_layout->addLayout(vim_tray_h_layout);    //  add vim tray layout into main vertical layout
    ui->main_v_layout->addLayout(projects_tray_h_layout);   //  add projects tray layout into main vertical layout
    ui->main_v_layout->addLayout(parameters_tray_h_layout); //  add parameters tray layout into main vertical layout
    ui->main_v_layout->addLayout(tray_h_layout);        //  add main tray layout into main vertical layout

    hide_theme_tray();                                  //  hide all trays of visual interface except main tray, which will be active on startup
    hide_file_tray();
    hide_paint_tray();
    hide_actions_tray();
    hide_find_tray();
    hide_template_tray();
    hide_language_tray();
    hide_vim_tray();
    hide_projects_tray();
    hide_parameters_tray();

    ui->class_tree->hide();
    ui->line->hide();

    bold_flag = false;                                  //  bold font in editors is disabled by default
    italic_flag = false;                                //  italic font in editors is disabled by default
    regex_flag = false;                                 //  all advanced search settings are disabled by default
    case_flag = false;
    boundary_flag = false;

    interface_visible = true;                           //  visual interface is visible by default
    theme_tray_visible = false;
    file_tray_visible = false;
    paint_tray_visible = false;
    actions_tray_visible = false;
    find_tray_visible = false;
    template_tray_visible = false;
    language_tray_visible = false;
    vim_tray_visible = false;
    projects_tray_visible = false;
    parameters_tray_visible = false;
    tray_visible = true;                                //  main tray is active and visible on startup
    help_flag = false;
    language_flag = false;
    class_tree_visible = false;
}


/// Initialize all tabs of text editor
void Spade::init_tabs()
{
    QFile projects_file(projects_file_path);

    if (projects_file.open(QFile::ReadOnly | QFile::Text))  //  it is possible to open projects file
    {
        QTextStream fin(&projects_file);

        QString content = fin.readAll();                //  load content from projects file
        QStringList parts = content.split(char(29));

        int parts_len = parts.size();

        if (parts_len)
        {
            if (parts[0].size())
                terminal_name->setText(parts[0]);

            for (int i = 1; i < parts_len; i++)
            {
                if (parts[i].size() && parts[i].right(4) == ".pro")     //  find all project files
                {
                    QString path = parts[i];
                    int projects_len = active_projects.size();
                    bool found = false;

                    for (int j = 0; j < projects_len; j++)
                    {
                        if (active_projects[j].path == path)    //  do not open same project twice
                        {
                            found = true;
                            break;
                        }
                    }

                    if (found)
                        continue;

                    QString name = get_filename_from_file_path(path);

                    projects->addItem(name);
                    projects->setItemData(projects->count() - 1, path, Qt::ToolTipRole);

                    Project_details new_project;        //  create new project object
                    new_project.name = name;
                    new_project.path = path;
                    active_projects.push_back(new_project);

                    QString content = "";

                    QFile file(path);

                    if (file.open(QFile::ReadOnly | QFile::Text))
                    {
                        QTextStream fin(&file);
                        content = fin.readAll();        //  get content of file from disk
                        file.close();
                    }

                    int N = content.size();

                    if (N)                              //  iterate through loaded content until length of content is reached
                    {
                        int k = 0;
                        QString temp = "";

                        while (k < N && content[k] != char(29))     //  parse bold flag value from content of language file
                        {
                            temp.push_back(content[k]);
                            k++;
                        }

                        if (temp.size())
                        {
                            active_projects[active_projects.size() - 1].language = temp.toInt();

                            k++;                        //  ignore separating character with ASCII value 29
                            temp.clear();

                            while (k < N && content[k] != char(29))     //  parse bold flag value from content of language file
                            {
                                temp.push_back(content[k]);
                                k++;
                            }

                            active_projects[active_projects.size() - 1].run_arguments = temp;

                            k++;                        //  ignore separating character with ASCII value 29
                            temp.clear();

                            while (k < N && content[k] != char(29))     //  parse bold flag value from content of language file
                            {
                                temp.push_back(content[k]);
                                k++;
                            }

                            active_projects[active_projects.size() - 1].compile_arguments = temp;

                            k++;                        //  ignore separating character with ASCII value 29
                            temp.clear();

                            while (k < N && content[k] != char(29))     //  parse bold flag value from content of language file
                            {
                                temp.push_back(content[k]);
                                k++;
                            }

                            active_projects[active_projects.size() - 1].make_arguments = temp;

                            k++;                        //  ignore separating character with ASCII value 29
                            temp.clear();

                            while (true)
                            {
                                while (k < N && content[k] != char(29))     //  parse bold flag value from content of language file
                                {
                                    temp.push_back(content[k]);
                                    k++;
                                }

                                if (temp.size() == 0)
                                    break;

                                QFile source_file(temp);

                                if (source_file.open(QFile::ReadOnly | QFile::Text))
                                {
                                    active_projects[active_projects.size() - 1].files.push_back(temp);
                                    source_file.close();
                                }

                                k++;                    //  ignore separating character with ASCII value 29
                                temp.clear();
                            }
                        }
                    }

                    source_files->setCurrentIndex(0);
                    projects->setCurrentIndex(0);
                }
            }
        }

        projects_file.close();                          //  close projects file
    }

    QFile language_file(language_file_path);

    if (language_file.open(QFile::ReadOnly | QFile::Text))  //  it is possible to open language file
    {
        QTextStream fin(&language_file);

        QString content = fin.readAll();                //  load content from language file

        int N = content.size();

        if (N)                                          //  iterate through loaded content until length of content is reached
        {
            int i = 0;
            QString temp = "";

            while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
            {
                temp.push_back(content[i]);
                i++;
            }

            int language_count = atoi(temp.toUtf8().constData());

            i++;                                        //  ignore separating character with ASCII value 29
            temp.clear();

            for (int j = 0; j < language_count; j++)
            {
                Language user_language;

                int elements_len = 0;
                int comments_len = 0;
                bool multiline_flag = false;

                while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                {
                    temp.push_back(content[i]);
                    i++;
                }

                user_language.name = temp;

                i++;                                    //  ignore separating character with ASCII value 29
                temp.clear();

                while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                {
                    temp.push_back(content[i]);
                    i++;
                }

                elements_len = atoi(temp.toUtf8().constData());

                i++;                                    //  ignore separating character with ASCII value 29
                temp.clear();

                while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                {
                    temp.push_back(content[i]);
                    i++;
                }

                comments_len = atoi(temp.toUtf8().constData());

                i++;                                    //  ignore separating character with ASCII value 29
                temp.clear();

                while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                {
                    temp.push_back(content[i]);
                    i++;
                }

                multiline_flag = atoi(temp.toUtf8().constData());

                i++;                                    //  ignore separating character with ASCII value 29
                temp.clear();

                for (int k = 0; k < elements_len; k++)
                {
                    SubElement subElement;

                    while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                    {
                        temp.push_back(content[i]);
                        i++;
                    }

                    subElement.regex = temp;

                    i++;                                //  ignore separating character with ASCII value 29
                    temp.clear();

                    while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                    {
                        temp.push_back(content[i]);
                        i++;
                    }

                    subElement.color_1 = atoi(temp.toUtf8().constData());

                    i++;                                //  ignore separating character with ASCII value 29
                    temp.clear();

                    while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                    {
                        temp.push_back(content[i]);
                        i++;
                    }

                    subElement.color_2 = atoi(temp.toUtf8().constData());

                    i++;                                //  ignore separating character with ASCII value 29
                    temp.clear();

                    while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                    {
                        temp.push_back(content[i]);
                        i++;
                    }

                    subElement.color_3 = atoi(temp.toUtf8().constData());

                    i++;                                //  ignore separating character with ASCII value 29
                    temp.clear();

                    while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                    {
                        temp.push_back(content[i]);
                        i++;
                    }

                    subElement.color_4 = atoi(temp.toUtf8().constData());

                    i++;                                //  ignore separating character with ASCII value 29
                    temp.clear();

                    while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                    {
                        temp.push_back(content[i]);
                        i++;
                    }

                    subElement.color_5 = atoi(temp.toUtf8().constData());

                    i++;                                //  ignore separating character with ASCII value 29
                    temp.clear();

                    while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                    {
                        temp.push_back(content[i]);
                        i++;
                    }

                    subElement.color_6 = atoi(temp.toUtf8().constData());

                    i++;                                //  ignore separating character with ASCII value 29
                    temp.clear();

                    user_language.subElements.push_back(subElement);
                }

                for (int k = 0; k < comments_len; k++)
                {
                    Comment new_comment;

                    while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                    {
                        temp.push_back(content[i]);
                        i++;
                    }

                    new_comment.from = temp;

                    i++;                                //  ignore separating character with ASCII value 29
                    temp.clear();

                    while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                    {
                        temp.push_back(content[i]);
                        i++;
                    }

                    new_comment.color_1 = atoi(temp.toUtf8().constData());

                    i++;                                //  ignore separating character with ASCII value 29
                    temp.clear();

                    while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                    {
                        temp.push_back(content[i]);
                        i++;
                    }

                    new_comment.color_2 = atoi(temp.toUtf8().constData());

                    i++;                                //  ignore separating character with ASCII value 29
                    temp.clear();

                    while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                    {
                        temp.push_back(content[i]);
                        i++;
                    }

                    new_comment.color_3 = atoi(temp.toUtf8().constData());

                    i++;                                //  ignore separating character with ASCII value 29
                    temp.clear();

                    while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                    {
                        temp.push_back(content[i]);
                        i++;
                    }

                    new_comment.color_4 = atoi(temp.toUtf8().constData());

                    i++;                                //  ignore separating character with ASCII value 29
                    temp.clear();

                    while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                    {
                        temp.push_back(content[i]);
                        i++;
                    }

                    new_comment.color_5 = atoi(temp.toUtf8().constData());

                    i++;                                //  ignore separating character with ASCII value 29
                    temp.clear();

                    while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                    {
                        temp.push_back(content[i]);
                        i++;
                    }

                    new_comment.color_6 = atoi(temp.toUtf8().constData());

                    i++;                                //  ignore separating character with ASCII value 29
                    temp.clear();

                    user_language.comments.push_back(new_comment);
                }

                if (multiline_flag)
                {
                    while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                    {
                        temp.push_back(content[i]);
                        i++;
                    }

                    user_language.multiline_comment_from = temp;

                    i++;                                //  ignore separating character with ASCII value 29
                    temp.clear();

                    while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                    {
                        temp.push_back(content[i]);
                        i++;
                    }

                    user_language.multiline_comment_to = temp;

                    i++;                                //  ignore separating character with ASCII value 29
                    temp.clear();

                    while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                    {
                        temp.push_back(content[i]);
                        i++;
                    }

                    user_language.multiline_comment_color_1 = atoi(temp.toUtf8().constData());

                    i++;                                //  ignore separating character with ASCII value 29
                    temp.clear();

                    while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                    {
                        temp.push_back(content[i]);
                        i++;
                    }

                    user_language.multiline_comment_color_2 = atoi(temp.toUtf8().constData());

                    i++;                                //  ignore separating character with ASCII value 29
                    temp.clear();

                    while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                    {
                        temp.push_back(content[i]);
                        i++;
                    }

                    user_language.multiline_comment_color_3 = atoi(temp.toUtf8().constData());

                    i++;                                //  ignore separating character with ASCII value 29
                    temp.clear();

                    while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                    {
                        temp.push_back(content[i]);
                        i++;
                    }

                    user_language.multiline_comment_color_4 = atoi(temp.toUtf8().constData());

                    i++;                                //  ignore separating character with ASCII value 29
                    temp.clear();

                    while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                    {
                        temp.push_back(content[i]);
                        i++;
                    }

                    user_language.multiline_comment_color_5 = atoi(temp.toUtf8().constData());

                    i++;                                //  ignore separating character with ASCII value 29
                    temp.clear();

                    while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                    {
                        temp.push_back(content[i]);
                        i++;
                    }

                    user_language.multiline_comment_color_6 = atoi(temp.toUtf8().constData());

                    i++;                                //  ignore separating character with ASCII value 29
                    temp.clear();
                }

                user_languages.push_back(user_language);
                custom_languages->addItem(user_language.name);
                languages->addItem(user_language.name);
            }
        }

        language_file.close();                          //  close language file
    }

    int actual = 0;

    QFile config_file(config_file_path);

    if (config_file.open(QFile::ReadOnly | QFile::Text))    //  it is possible to open configuration file
    {
        QTextStream fin(&config_file);

        QString content = fin.readAll();                //  load content from configuration file

        int N = content.size();

        if (N)                                          //  iterate through loaded content until length of content is reached
        {
            int i = 0;
            QString temp = "";

            while (i < N && content[i] != char(29))     //  parse bold flag value from content of configuration file
            {
                temp.push_back(content[i]);
                i++;
            }

            bold_flag = atoi(temp.toUtf8().constData());

            i++;                                        //  ignore separating character with ASCII value 29
            temp.clear();

            while (i < N && content[i] != char(29))     //  parse bold flag value from content of configuration file
            {
                temp.push_back(content[i]);
                i++;
            }

            italic_flag = atoi(temp.toUtf8().constData());  //  parse italic flag value from content of configuration file

            i++;                                        //  ignore separating character with ASCII value 29
            temp.clear();

            while (i < N && content[i] != char(29))     //  parse bold flag value from content of configuration file
            {
                temp.push_back(content[i]);
                i++;
            }

            regex_flag = atoi(temp.toUtf8().constData());

            i++;                                        //  ignore separating character with ASCII value 29
            temp.clear();

            while (i < N && content[i] != char(29))     //  parse bold flag value from content of configuration file
            {
                temp.push_back(content[i]);
                i++;
            }

            case_flag = atoi(temp.toUtf8().constData());

            i++;                                        //  ignore separating character with ASCII value 29
            temp.clear();

            while (i < N && content[i] != char(29))     //  parse bold flag value from content of configuration file
            {
                temp.push_back(content[i]);
                i++;
            }

            boundary_flag = atoi(temp.toUtf8().constData());

            i++;                                        //  ignore separating character with ASCII value 29
            temp.clear();

            while (i < N && content[i] != char(29))
            {
                temp.push_back(content[i]);
                i++;
            }

            actual = atoi(temp.toUtf8().constData());   //  parse actual tab index value from content of configuration file

            i++;                                        //  ignore separating character with ASCII value 29
            temp.clear();

            while (i < N && content[i] != char(29))
            {
                temp.push_back(content[i]);
                i++;
            }

            color.setRed(atoi(temp.toUtf8().constData()));      //  parse red part of RGB value for paint button from content of configuration file

            i++;                                        //  ignore separating character with ASCII value 29
            temp.clear();

            while (i < N && content[i] != char(29))
            {
                temp.push_back(content[i]);
                i++;
            }

            color.setGreen(atoi(temp.toUtf8().constData()));    //  parse green part of RGB value for paint button from content of configuration file

            i++;                                        //  ignore separating character with ASCII value 29
            temp.clear();

            while (i < N && content[i] != char(29))
            {
                temp.push_back(content[i]);
                i++;
            }

            color.setBlue(atoi(temp.toUtf8().constData()));     //  parse blue part of RGB value for paint button from content of configuration file

            i++;                                        //  ignore separating character with ASCII value 29
            temp.clear();

            while (i < N && content[i] != char(29))
            {
                temp.push_back(content[i]);
                i++;
            }

            color.setAlpha(atoi(temp.toUtf8().constData()));    //  parse alpha part of RGB value for paint button from content of configuration file

            i++;                                        //  ignore separating character with ASCII value 29
            temp.clear();

            color_pixmap->fill(color);                  //  refresh color icon of color push button
            color_button->setIcon(QIcon(* color_pixmap));
            color_button->setIconSize(QSize(18, 18));

            while (true)                                //  number of active tabs on last exit of program is unknown now
            {                                           //  it is required to stop infinite loop manually when content searching reach end
                if (i >= N)
                    break;

                Tab_details new_tab;                    //  create new temporary tab details object for loading next tab description from content

                while (i < N && content[i] != char(29))
                {
                    temp.push_back(content[i]);
                    i++;
                }

                new_tab.index_in_tabs = atoi(temp.toUtf8().constData());    //  parse index in tabs value from content of configuration file

                i++;                                    //  ignore separating character with ASCII value 29
                temp.clear();

                while (i < N && content[i] != char(29))
                {
                    temp.push_back(content[i]);
                    i++;
                }

                new_tab.language = atoi(temp.toUtf8().constData());     //  parse language value from content of configuration file

                if (new_tab.language >= languages->count())
                    new_tab.language = plain_text;      //  handle usage of non-existing language

                i++;                                    //  ignore separating character with ASCII value 29
                temp.clear();

                while (i < N && content[i] != char(29))
                {
                    temp.push_back(content[i]);
                    i++;
                }

                new_tab.file_path = temp;               //  parse file path from content of configuration file

                i++;                                    //  ignore separating character with ASCII value 29
                temp.clear();

                while (i < N && content[i] != char(29))
                {
                    temp.push_back(content[i]);
                    i++;
                }

                new_tab.file_name = temp;               //  parse file name from content of configuration file

                i++;                                    //  ignore separating character with ASCII value 29
                temp.clear();

                while (i < N && content[i] != char(29))
                {
                    temp.push_back(content[i]);
                    i++;
                }

                new_tab.font_size = atoi(temp.toUtf8().constData());    //  parse font size value from content of configuration file

                i++;                                    //  ignore separating character with ASCII value 29
                temp.clear();

                while (i < N && content[i] != char(29))
                {
                    temp.push_back(content[i]);
                    i++;
                }

                new_tab.scroll_bars = atoi(temp.toUtf8().constData());  //  parse scroll bars flag value from content of configuration file

                i++;                                    //  ignore separating character with ASCII value 29
                temp.clear();

                while (i < N && content[i] != char(29))
                {
                    temp.push_back(content[i]);
                    i++;
                }

                new_tab.comments = atoi(temp.toUtf8().constData());     //  parse comments flag value from content of configuration file

                i++;                                    //  ignore separating character with ASCII value 29
                temp.clear();

                while (i < N && content[i] != char(29))
                {
                    temp.push_back(content[i]);
                    i++;
                }

                new_tab.theme = atoi(temp.toUtf8().constData());    //  parse theme value from content of configuration file

                i++;                                    //  ignore separating character with ASCII value 29
                temp.clear();

                while (i < N && content[i] != char(29))
                {
                    temp.push_back(content[i]);
                    i++;
                }

                editor[new_tab.index_in_tabs].content = temp;   //  parse text content of tab from content of configuration file

                int temp_len = temp.size();
                int j = 0;
                vector<bool> differences;

                while (j < temp_len)                    //  calculate number of line from loaded content of tab
                {
                    if (temp[j] == '\n')
                        differences.push_back(false);   //  initialize differences array with first element with clear line without text changes

                    j++;
                }

                differences.push_back(false);

                editor[new_tab.index_in_tabs].differences.push_back(differences);   //  push created differences array element into array
                editor[new_tab.index_in_tabs].actual_difference = differences;      //  set actual difference content
                editor[new_tab.index_in_tabs].setPlainText(temp);   //  set loaded content into text editor

                i++;                                    //  ignore separating character with ASCII value 29
                temp.clear();

                while (i < N && content[i] != char(29))     //  load string pattern with RGB values for custom highlights in content
                {
                    temp.push_back(content[i]);
                    i++;
                }

                int len = temp.size();

                if (len)                                //  there is at least one custom highlight
                {
                    for (int j = 0; j < len; j++)       //  iterate through loaded string pattern
                    {
                        if (j < len && temp[j] != '|')
                        {
                            QString part = "";          //  holds part string with description of one custom highlight

                            part += temp[j];
                            j++;

                            while (j < len && temp[j] != '|')   //  load part string content until | character which represents separator
                            {
                                part += temp[j];
                                j++;
                            }

                            int part_len = part.size();
                            QString string_red = "";    //  create string for all parts of RGB value and highlight position
                            QString string_green = "";
                            QString string_blue = "";
                            QString string_alpha = "";
                            QString string_from = "";
                            QString string_to = "";

                            int k = 0;

                            while (part[k] != ' ')      //  load red part of actual RGB value from loaded pattern
                            {
                                string_red.push_back(part[k]);
                                k++;
                            }

                            k++;

                            while (part[k] != ' ')      //  load green part of actual RGB value from loaded pattern
                            {
                                string_green.push_back(part[k]);
                                k++;
                            }

                            k++;

                            while (part[k] != ' ')      //  load blue part of actual RGB value from loaded pattern
                            {
                                string_blue.push_back(part[k]);
                                k++;
                            }

                            k++;

                            while (part[k] != ' ')      //  load alpha part of actual RGB value from loaded pattern
                            {
                                string_alpha.push_back(part[k]);
                                k++;
                            }

                            k++;

                            while (part[k] != ' ')      //  load starting position of actual custom highlight from loaded pattern
                            {
                                string_from.push_back(part[k]);
                                k++;
                            }

                            k++;

                            while (k < part_len)        //  load ending position of actual custom highlight from loaded pattern
                            {
                                string_to.push_back(part[k]);
                                k++;
                            }

                            int red = atoi(string_red.toUtf8().constData());    //  convert RGB value part into integer
                            int green = atoi(string_green.toUtf8().constData());
                            int blue = atoi(string_blue.toUtf8().constData());

                            QTextEdit::ExtraSelection selection;    //  apply loaded custom highlight into text editor content
                            selection.cursor = editor[new_tab.index_in_tabs].textCursor();
                            selection.format.setBackground(QColor(red, green, blue, atoi(string_alpha.toUtf8().constData())));
                            selection.cursor.setPosition(atoi(string_from.toUtf8().constData()), QTextCursor::MoveAnchor);
                            selection.cursor.setPosition(atoi(string_to.toUtf8().constData()), QTextCursor::KeepAnchor);
                            new_tab.extra_selections.push_back(selection);  //  push custom highlight into extra selections vector
                            new_tab.custom_selections_count++;      //  increase extra selections counter
                        }
                    }
                }

                if (new_tab.file_path != "New tab")
                {
                    if (check_file_path(new_tab.file_path) == false)    //  check validity of loaded file path
                    {
                        QString file_content = "";
                        QFile temp_file(new_tab.file_path);

                        if (temp_file.open(QFile::ReadOnly | QFile::Text))  //  file with loaded path can be opened
                        {
                            QTextStream fin(&temp_file);
                            file_content = fin.readAll();
                            temp_file.close();
                                                        //  check if loaded content is same with content saved in opened file and set save flag value
                            if (file_content == temp)
                                new_tab.saved = true;
                            else
                                new_tab.saved = false;
                        }

                        active_tabs.push_back(new_tab);     //  push loaded tab into active tabs vector
                        files_watcher->addPath(new_tab.file_path);
                    }
                }
                else
                    active_tabs.push_back(new_tab);     //  push loaded tab into active tabs vector
                                                        //  file which cannot be opened will not be in active tabs, because of file system watcher
                i++;                                    //  ignore separating character with ASCII value 29
                temp.clear();

                while (i < N && content[i] != char(29))
                {
                    temp.push_back(content[i]);
                    i++;
                }

                int from = atoi(temp.toUtf8().constData());     //  parse cursor selection start value from content of configuration file
                editor[new_tab.index_in_tabs].actual_selection.from = from;

                i++;                                    //  ignore separating character with ASCII value 29
                temp.clear();

                while (i < N && content[i] != char(29))
                {
                    temp.push_back(content[i]);
                    i++;
                }

                int to = atoi(temp.toUtf8().constData());   //  parse cursor selection end value from content of configuration file
                editor[new_tab.index_in_tabs].actual_selection.to = to;

                if (from != to)                         //  activate selection in loaded range in text editor tab
                {
                    * text_cursor = editor[new_tab.index_in_tabs].textCursor();
                    text_cursor->setPosition(from);
                    text_cursor->setPosition(to, QTextCursor::KeepAnchor);
                    editor[new_tab.index_in_tabs].setTextCursor(* text_cursor);
                }
                else                                    //  selection is only alone cursor, so set cursor position
                {
                    * text_cursor = editor[new_tab.index_in_tabs].textCursor();
                    text_cursor->movePosition(QTextCursor::Right, QTextCursor::MoveAnchor, atoi(temp.toUtf8().constData()));
                    editor[new_tab.index_in_tabs].setTextCursor(* text_cursor);
                }

                i++;                                    //  ignore separating character with ASCII value 29
                temp.clear();

                while (i < N && content[i] != char(29))
                {
                    temp.push_back(content[i]);
                    i++;
                }
                                                        //  parse vertical scroll bar position value from content of configuration file
                editor[new_tab.index_in_tabs].verticalScrollBar()->setValue(atoi(temp.toUtf8().constData()));

                i++;                                    //  ignore separating character with ASCII value 29
                temp.clear();

                while (i < N && content[i] != char(29))
                {
                    temp.push_back(content[i]);
                    i++;
                }
                                                        //  parse vertical scroll bar position value from content of configuration file
                editor[new_tab.index_in_tabs].horizontalScrollBar()->setValue(atoi(temp.toUtf8().constData()));

                i++;                                    //  ignore separating character with ASCII value 29
                temp.clear();
            }
        }

        config_file.close();
    }

    int N = active_tabs.size();                         //  get number of active tabs

    if (N)                                              //  at least one tab of text editor is opened
    {
        for (int i = 0; i < N; i++)                     //  iterate through all tabs of text editor
        {
            QString file_content = "";
            QFile file(active_tabs[i].file_path);

            if (file.open(QFile::ReadOnly | QFile::Text))	//  read file content from disk
            {
                QTextStream fin(&file);
                file_content = fin.readAll();
                file.close();
            }
                                                        //  check if content of text editor tab is same as content saved on disk
            if (file_content != editor[active_tabs[i].index_in_tabs].document()->toPlainText())
                active_tabs[i].saved = false;
            else
                active_tabs[i].saved = true;

            if (active_tabs[i].language <= python)      //  refresh highlighting of concrete syntax highlighter
                highlighters[active_tabs[i].index_in_tabs]->applyRules(nullptr, active_tabs[i].language, active_tabs[i].comments, active_tabs[i].theme);
            else
            {
                int language_index = active_tabs[i].language - builtInLanguages;
                highlighters[active_tabs[i].index_in_tabs]->applyRules(&(user_languages[language_index]), active_tabs[i].language, active_tabs[i].comments, active_tabs[i].theme);
            }

            files->addItem(active_tabs[i].file_name);       //  insert details about tab into files combobox
            files->setItemData(i, active_tabs[i].file_path, Qt::ToolTipRole);
            files->setToolTip(active_tabs[i].file_path);

            font.setPointSize(active_tabs[i].font_size);
            editor[active_tabs[i].index_in_tabs].setFont(font);     //  refresh font size in text editor tab
            QFontMetrics metrics(editor[active_tabs[i].index_in_tabs].font());  //  refresh tab width to appropriate value using font metrics
            editor[active_tabs[i].index_in_tabs].setTabStopWidth(active_tabs[i].tab_width * metrics.width(' '));
            editor[active_tabs[i].index_in_tabs].theme = active_tabs[i].theme;  //  load theme value into text editor object
            editor[active_tabs[i].index_in_tabs].file_path = active_tabs[i].file_path;  //  load file path into text editor object

            if (active_tabs[i].scroll_bars)             //  toggle scroll bars visibility in actual tab
            {
                editor[i].setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
                editor[i].setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded);
            }
            else
            {
                editor[i].setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
                editor[i].setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
            }

            init_palette(active_tabs[i].theme);         //  set color scheme of font for actual tab
            editor[active_tabs[i].index_in_tabs].setPalette(* theme_color);     //  set color palette for actual tab
            refresh_extra_selections(i);                //  refresh all extra selection in actual tab
        }

        if (bold_flag)                                  //  set bold font if it is active
        {
            bold_flag = false;
            bold_button_pressed();
        }

        if (italic_flag)                                //  set italic font if it is active
        {
            italic_flag = false;
            italic_button_pressed();
        }

        if (regex_flag)                                 //  set bold font if it is active
        {
            regex_flag = false;
            regex_button_pressed();
        }

        if (case_flag)                                  //  set bold font if it is active
        {
            case_flag = false;
            case_button_pressed();
        }

        if (boundary_flag)                              //  set bold font if it is active
        {
            boundary_flag = false;
            boundary_button_pressed();
        }

        files->setCurrentIndex(actual);                 //  set actual tab in files combo box
        editor_text_changed();
        file_selected(actual);                          //  move to actual tab in text editor
    }
    else                                                //  there is no active tab, so open one temporary plain text file
    {
        Tab_details temp;                               //  create temporary tab details object
        temp.file_path = "New tab";
        temp.file_name = "untitled";

        active_tabs.push_back(temp);                    //  push loaded tab into active tabs vector

        files->addItem(temp.file_name);                 //  insert details about tab into files combobox
        files->setItemData(0, temp.file_path, Qt::ToolTipRole);
        files->setToolTip(temp.file_path);
        files->setCurrentIndex(0);

        editor_text_changed();
        init_palette(1);

        vector<bool> differences;
        differences.push_back(false);                   //  initialize differences array with one element
        editor[0].differences.push_back(differences);   //  push new element into differences array
        editor[0].actual_difference = differences;      //  initialize actual difference with new element
        editor[0].setPalette(* theme_color);            //  set text editor palette
        refresh_extra_selections(0);                    //  refresh extra highlights in text editor tab
        file_selected(0);
    }
}


/// Show theme tray in bottom navigation bar
void Spade::show_theme_tray()
{                                                       //  show all theme images
    for (int i = 0; i < theme_count; i++)
        theme_image[i].show();
}


/// Show file tray in bottom navigation bar
void Spade::show_file_tray()
{                                                       //  show all visual elements in file tray and refresh content margin of file tray layout
    undo_button->show();
    redo_button->show();
    save_all_button->show();
    scroll_bars_button->show();
    reload_button->show();
    tab_width->show();
    layouts->show();
    back_button->show();
    file_tray_h_layout->setContentsMargins(2, 2, 2, 2);
}


/// Show paint tray in bottom navigation bar
void Spade::show_paint_tray()
{                                                       //  show all visual elements in paint tray and refresh content margin of paint tray layout
    color_button->show();
    apply_button->show();
    rubber_button->show();
    undo_button_2->show();
    clear_button->show();
    back_button_2->show();
    paint_tray_h_layout->setContentsMargins(2, 2, 2, 2);
}


/// Show actions tray in bottom navigation bar
void Spade::show_actions_tray()
{                                                       //  show all visual elements in actions tray and refresh content margin of actions tray layout
    find_button->show();
    swap_line_up_button->show();
    swap_line_down_button->show();
    upper_case_button->show();
    lower_case_button->show();
    swap_case_button->show();
    bold_button->show();
    italic_button->show();
    vim_button->show();
    concept_button->show();
    help_button->show();
    back_button_3->show();
    actions_tray_h_layout->setContentsMargins(2, 2, 2, 2);
}


/// Show find tray in bottom navigation bar
void Spade::show_find_tray()
{                                                       //  show all visual elements in find tray and refresh content margin of find tray layout
    find_previous_button->show();
    find_next_button->show();
    find_line_edit->show();
    replace_button->show();
    replace_all_button->show();
    replace_line_edit->show();
    regex_button->show();
    case_button->show();
    boundary_button->show();
    back_button_4->show();
    find_tray_h_layout->setContentsMargins(2, 2, 2, 2);
    find_line_edit->setFocus();

    QString content = editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText();

    int from = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().selectionStart();
    int to = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().selectionEnd();

    if (from != to)                                     //  insert single line content selected by cursor into find lind edit
    {
        if (from > to)
        {
            int temp = from;
            from = to;
            to = temp;
        }

        QString selected_text = "";

        for (int i = from; i < to; i++)
        {
            if (selected_text[i] == '\n')               //  selected text cannot contain newline characters
                return;

            selected_text.push_back(content[i]);
        }

        find_line_edit->setText(selected_text);
    }
}


/// Show template tray in bottom navigation bar
void Spade::show_template_tray()
{                                                       //  show all visual elements in template tray and refresh margin of template tray layout
    template_style_button_1->show();
    template_style_button_2->show();
    template_style_button_3->show();
    template_style_button_4->show();
    template_style_button_5->show();
    template_style_button_6->show();
    template_style_button_7->show();
    template_style_button_8->show();
    template_style_button_9->show();
    template_style_button_10->show();

    switch (active_tabs[files->currentIndex()].language)    //  refresh content of template tray buttons by the active language
    {
        case c99:                                       //  code templates for C99 language
            template_style_button_1->setText("If");
            template_style_button_1->setMinimumSize(35, 30);
            template_style_button_1->setMaximumSize(35, 30);
            template_style_button_2->setText("Test");
            template_style_button_2->setMinimumSize(50, 30);
            template_style_button_2->setMaximumSize(50, 30);
            template_style_button_3->setText("Switch");
            template_style_button_3->setMinimumSize(65, 30);
            template_style_button_3->setMaximumSize(65, 30);
            template_style_button_4->setText("For");
            template_style_button_4->setMinimumSize(40, 30);
            template_style_button_4->setMaximumSize(40, 30);
            template_style_button_5->setText("While");
            template_style_button_5->setMinimumSize(60, 30);
            template_style_button_5->setMaximumSize(60, 30);
            template_style_button_6->setText("Do While");
            template_style_button_6->setMinimumSize(85, 30);
            template_style_button_6->setMaximumSize(85, 30);
            template_style_button_7->setText("Function");
            template_style_button_7->setMinimumSize(75, 30);
            template_style_button_7->setMaximumSize(75, 30);
            template_style_button_8->setText("Struct");
            template_style_button_8->setMinimumSize(60, 30);
            template_style_button_8->setMaximumSize(60, 30);
            template_style_button_9->setText("Union");
            template_style_button_9->setMinimumSize(60, 30);
            template_style_button_9->setMaximumSize(60, 30);
            template_style_button_10->setText("Enum");
            template_style_button_10->setMinimumSize(60, 30);
            template_style_button_10->setMaximumSize(60, 30);

            break;
        case cplusplus:                                 //  code templates for C++ language
            template_style_button_1->setText("If");
            template_style_button_1->setMinimumSize(35, 30);
            template_style_button_1->setMaximumSize(35, 30);
            template_style_button_2->setText("Test");
            template_style_button_2->setMinimumSize(50, 30);
            template_style_button_2->setMaximumSize(50, 30);
            template_style_button_3->setText("Switch");
            template_style_button_3->setMinimumSize(65, 30);
            template_style_button_3->setMaximumSize(65, 30);
            template_style_button_4->setText("For");
            template_style_button_4->setMinimumSize(40, 30);
            template_style_button_4->setMaximumSize(40, 30);
            template_style_button_5->setText("While");
            template_style_button_5->setMinimumSize(60, 30);
            template_style_button_5->setMaximumSize(60, 30);
            template_style_button_6->setText("Do While");
            template_style_button_6->setMinimumSize(85, 30);
            template_style_button_6->setMaximumSize(85, 30);
            template_style_button_7->setText("Method");
            template_style_button_7->setMinimumSize(75, 30);
            template_style_button_7->setMaximumSize(75, 30);
            template_style_button_8->setText("Class");
            template_style_button_8->setMinimumSize(55, 30);
            template_style_button_8->setMaximumSize(55, 30);
            template_style_button_9->setText("Hierarchy");
            template_style_button_9->setMinimumSize(85, 30);
            template_style_button_9->setMaximumSize(85, 30);
            template_style_button_10->setText("Template");
            template_style_button_10->setMinimumSize(85, 30);
            template_style_button_10->setMaximumSize(85, 30);

            break;
        case java:                                      //  code templates for Java language
            template_style_button_1->setText("If");
            template_style_button_1->setMinimumSize(35, 30);
            template_style_button_1->setMaximumSize(35, 30);
            template_style_button_2->setText("Test");
            template_style_button_2->setMinimumSize(50, 30);
            template_style_button_2->setMaximumSize(50, 30);
            template_style_button_3->setText("Switch");
            template_style_button_3->setMinimumSize(65, 30);
            template_style_button_3->setMaximumSize(65, 30);
            template_style_button_4->setText("For");
            template_style_button_4->setMinimumSize(40, 30);
            template_style_button_4->setMaximumSize(40, 30);
            template_style_button_5->setText("While");
            template_style_button_5->setMinimumSize(60, 30);
            template_style_button_5->setMaximumSize(60, 30);
            template_style_button_6->setText("Do While");
            template_style_button_6->setMinimumSize(85, 30);
            template_style_button_6->setMaximumSize(85, 30);
            template_style_button_7->setText("Method");
            template_style_button_7->setMinimumSize(75, 30);
            template_style_button_7->setMaximumSize(75, 30);
            template_style_button_8->setText("Class");
            template_style_button_8->setMinimumSize(55, 30);
            template_style_button_8->setMaximumSize(55, 30);
            template_style_button_9->setText("Hierarchy");
            template_style_button_9->setMinimumSize(85, 30);
            template_style_button_9->setMaximumSize(85, 30);
            template_style_button_10->setText("Interface");
            template_style_button_10->setMinimumSize(85, 30);
            template_style_button_10->setMaximumSize(85, 30);

            break;
        case php:                                       //  code templates for PHP language
            template_style_button_1->setText("If");
            template_style_button_1->setMinimumSize(35, 30);
            template_style_button_1->setMaximumSize(35, 30);
            template_style_button_2->setText("Test");
            template_style_button_2->setMinimumSize(50, 30);
            template_style_button_2->setMaximumSize(50, 30);
            template_style_button_3->setText("Switch");
            template_style_button_3->setMinimumSize(65, 30);
            template_style_button_3->setMaximumSize(65, 30);
            template_style_button_4->setText("For");
            template_style_button_4->setMinimumSize(40, 30);
            template_style_button_4->setMaximumSize(40, 30);
            template_style_button_5->setText("While");
            template_style_button_5->setMinimumSize(60, 30);
            template_style_button_5->setMaximumSize(60, 30);
            template_style_button_6->setText("Do While");
            template_style_button_6->setMinimumSize(85, 30);
            template_style_button_6->setMaximumSize(85, 30);
            template_style_button_7->setText("Method");
            template_style_button_7->setMinimumSize(75, 30);
            template_style_button_7->setMaximumSize(75, 30);
            template_style_button_8->setText("Class");
            template_style_button_8->setMinimumSize(55, 30);
            template_style_button_8->setMaximumSize(55, 30);
            template_style_button_9->setText("Hierarchy");
            template_style_button_9->setMinimumSize(85, 30);
            template_style_button_9->setMaximumSize(85, 30);
            template_style_button_10->setText("Interface");
            template_style_button_10->setMinimumSize(85, 30);
            template_style_button_10->setMaximumSize(85, 30);

            break;
        case plain_text:                                //  code templates for plain text document
            template_style_button_1->setText("1");
            template_style_button_1->setMinimumSize(50, 30);
            template_style_button_1->setMaximumSize(50, 30);
            template_style_button_2->setText("1.");
            template_style_button_2->setMinimumSize(50, 30);
            template_style_button_2->setMaximumSize(50, 30);
            template_style_button_3->setText("1)");
            template_style_button_3->setMinimumSize(50, 30);
            template_style_button_3->setMaximumSize(50, 30);
            template_style_button_4->setText("a");
            template_style_button_4->setMinimumSize(50, 30);
            template_style_button_4->setMaximumSize(50, 30);
            template_style_button_5->setText("a)");
            template_style_button_5->setMinimumSize(50, 30);
            template_style_button_5->setMaximumSize(50, 30);
            template_style_button_6->setText("A");
            template_style_button_6->setMinimumSize(50, 30);
            template_style_button_6->setMaximumSize(50, 30);
            template_style_button_7->setText("A)");
            template_style_button_7->setMinimumSize(50, 30);
            template_style_button_7->setMaximumSize(50, 30);
            template_style_button_8->setText(">");
            template_style_button_8->setMinimumSize(50, 30);
            template_style_button_8->setMaximumSize(50, 30);
            template_style_button_9->setText("-");
            template_style_button_9->setMinimumSize(50, 30);
            template_style_button_9->setMaximumSize(50, 30);
            template_style_button_10->setText("->");
            template_style_button_10->setMinimumSize(50, 30);
            template_style_button_10->setMaximumSize(50, 30);

            break;
        default:                                        //  code templates for Python language
            template_style_button_1->setText("If");
            template_style_button_1->setMinimumSize(35, 30);
            template_style_button_1->setMaximumSize(35, 30);
            template_style_button_2->setText("Test");
            template_style_button_2->setMinimumSize(50, 30);
            template_style_button_2->setMaximumSize(50, 30);
            template_style_button_3->setText("Options");
            template_style_button_3->setMinimumSize(75, 30);
            template_style_button_3->setMaximumSize(75, 30);
            template_style_button_4->setText("For");
            template_style_button_4->setMinimumSize(40, 30);
            template_style_button_4->setMaximumSize(40, 30);
            template_style_button_5->setText("While");
            template_style_button_5->setMinimumSize(60, 30);
            template_style_button_5->setMaximumSize(60, 30);
            template_style_button_6->setText("Function");
            template_style_button_6->setMinimumSize(80, 30);
            template_style_button_6->setMaximumSize(80, 30);
            template_style_button_7->setText("Method");
            template_style_button_7->setMinimumSize(75, 30);
            template_style_button_7->setMaximumSize(75, 30);
            template_style_button_8->setText("Class");
            template_style_button_8->setMinimumSize(55, 30);
            template_style_button_8->setMaximumSize(55, 30);
            template_style_button_9->setText("Hierarchy");
            template_style_button_9->setMinimumSize(85, 30);
            template_style_button_9->setMaximumSize(85, 30);
            template_style_button_10->setText("Except");
            template_style_button_10->setMinimumSize(70, 30);
            template_style_button_10->setMaximumSize(70, 30);

            break;
    }

    template_count->show();
    back_button_5->show();
    template_tray_h_layout->setContentsMargins(2, 2, 2, 2);
}


/// Show language tray in bottom navigation bar
void Spade::show_language_tray()                        //  show all visual elements in template tray and refresh margin of language tray layout
{
    send_horizontal_button->show();
    send_vertical_button->show();
    send_diagonal_button->show();
    send_all_button->show();
    custom_languages->show();
    change_button->show();
    add_button->show();
    delete_button->show();
    back_button_6->show();
    language_tray_h_layout->setContentsMargins(2, 2, 2, 2);
}


/// Show Vim tray in bottom navigation bar
void Spade::show_vim_tray()                             //  show all visual elements in template tray and refresh margin of vim tray layout
{
    vim_edit->setText("");
    vim_edit->show();
    vim_coordinates->setText("");
    vim_coordinates->show();
    vim_position->setText("");
    vim_position->show();
    vim_tray_h_layout->setContentsMargins(2, 2, 2, 2);
    vim_visual_flag = false;                    //  disable Vim visual flag
    vim_replace_flag = false;                   //  disable Vim replace flag
}


/// Show projects tray in bottom navigation bar
void Spade::show_projects_tray()                        //  show all visual elements in template tray and refresh margin of projects tray layout
{
    language->show();
    new_project_button->show();
    open_project_button->show();
    source_button->show();
    delete_button_2->show();
    projects->show();
    class_tree_button->show();
    makefile_button->show();
    toggle_button->show();
    delete_button_3->show();
    source_files->show();
    run_button->show();
    build_button->show();
    clean_button->show();
    back_button_7->show();
    projects_tray_h_layout->setContentsMargins(2, 2, 2, 2);
}


/// Show parameters tray in bottom navigation bar
void Spade::show_parameters_tray()                      //  show all visual elements in template tray and refresh margin of parameters tray layout
{
    run_parameters->show();
    compile_parameters->show();
    make_parameters->show();
    terminal_name->show();
    back_button_8->show();
    parameters_tray_h_layout->setContentsMargins(2, 2, 2, 2);
}


/// Show main tray in bottom navigation bar
void Spade::show_tray()
{                                                       //  show all visual elements in main tray and refresh content margin of main tray layout
    files->show();
    save_button->show();
    open_button->show();
    new_tab_button->show();
    close_tab_button->show();
    font_size->show();
    template_button->show();
    comments_button->show();
    paint_button->show();
    theme_button->show();
    languages->show();
    file_button->show();
    project_button->show();
    fullscreen_button->show();
    menu_button->show();
    tray_h_layout->setContentsMargins(2, 2, 2, 2);
}


/// Hide theme tray in bottom navigation bar
void Spade::hide_theme_tray()
{                                                       //  hide all theme images
    for (int i = 0; i < theme_count; i++)
        theme_image[i].hide();
}


/// Hide file tray in bottom navigation bar
void Spade::hide_file_tray()
{                                                       //  hide all visual elements in file tray and refresh content margin of file tray layout
    undo_button->hide();
    redo_button->hide();
    save_all_button->hide();
    scroll_bars_button->hide();
    reload_button->hide();
    tab_width->hide();
    layouts->hide();
    back_button->hide();
    file_tray_h_layout->setContentsMargins(0, 0, 0, 0);
}


/// Hide paint tray in bottom navigation bar
void Spade::hide_paint_tray()
{                                                       //  hide all visual elements in paint tray and refresh content margin of paint tray layout
    color_button->hide();
    apply_button->hide();
    rubber_button->hide();
    undo_button_2->hide();
    clear_button->hide();
    back_button_2->hide();
    paint_tray_h_layout->setContentsMargins(0, 0, 0, 0);
}


/// Hide actions tray in bottom navigation bar
void Spade::hide_actions_tray()
{                                                       //  hide all visual elements in actions tray and refresh content margin of actions tray layout
    find_button->hide();
    swap_line_up_button->hide();
    swap_line_down_button->hide();
    upper_case_button->hide();
    lower_case_button->hide();
    swap_case_button->hide();
    bold_button->hide();
    italic_button->hide();
    vim_button->hide();
    concept_button->hide();
    help_button->hide();
    back_button_3->hide();
    actions_tray_h_layout->setContentsMargins(0, 0, 0, 0);
}


/// Hide find tray in bottom navigation bar
void Spade::hide_find_tray()
{                                                       //  hide all visual elements in find tray and refresh content margin of find tray layout
    find_previous_button->hide();
    find_next_button->hide();
    find_line_edit->hide();
    replace_button->hide();
    replace_all_button->hide();
    replace_line_edit->hide();
    regex_button->hide();
    case_button->hide();
    boundary_button->hide();
    back_button_4->hide();
    find_tray_h_layout->setContentsMargins(0, 0, 0, 0);
}


/// Hide template tray in bottom navigation bar
void Spade::hide_template_tray()
{                                                       //  hide all visual elements in template tray and refresh content margin of template tray layout
    template_style_button_1->hide();
    template_style_button_2->hide();
    template_style_button_3->hide();
    template_style_button_4->hide();
    template_style_button_5->hide();
    template_style_button_6->hide();
    template_style_button_7->hide();
    template_style_button_8->hide();
    template_style_button_9->hide();
    template_style_button_10->hide();

    template_count->hide();
    back_button_5->hide();
    template_tray_h_layout->setContentsMargins(0, 0, 0, 0);
}


/// Hide language tray in bottom navigation bar
void Spade::hide_language_tray()                        //  hide all visual elements in main tray and refresh content margin of language tray layout
{
    send_horizontal_button->hide();
    send_vertical_button->hide();
    send_diagonal_button->hide();
    send_all_button->hide();
    custom_languages->hide();
    change_button->hide();
    add_button->hide();
    delete_button->hide();
    back_button_6->hide();
    language_tray_h_layout->setContentsMargins(0, 0, 0, 0);
}


/// Hide Vim tray in bottom navigation bar
void Spade::hide_vim_tray()                             //  hide all visual elements in main tray and refresh content margin of vim tray layout
{
    vim_edit->setText("");
    vim_edit->hide();
    vim_coordinates->setText("");
    vim_coordinates->hide();
    vim_position->setText("");
    vim_position->hide();
    vim_tray_h_layout->setContentsMargins(0, 0, 0, 0);
    vim_visual_flag = false;                    //  disable Vim visual flag
    vim_replace_flag = false;                   //  disable Vim replace flag
}


/// Hide projects tray in bottom navigation bar
void Spade::hide_projects_tray()                        //  hide all visual elements in main tray and refresh content margin of projects tray layout
{
    language->hide();
    new_project_button->hide();
    open_project_button->hide();
    source_button->hide();
    delete_button_2->hide();
    projects->hide();
    class_tree_button->hide();
    makefile_button->hide();
    toggle_button->hide();
    delete_button_3->hide();
    source_files->hide();
    run_button->hide();
    build_button->hide();
    clean_button->hide();
    back_button_7->hide();
    projects_tray_h_layout->setContentsMargins(0, 0, 0, 0);
}


/// Hide parameters tray in bottom navigation bar
void Spade::hide_parameters_tray()                      //  hide all visual elements in main tray and refresh content margin of parameters tray layout
{
    run_parameters->hide();
    compile_parameters->hide();
    make_parameters->hide();
    terminal_name->hide();
    back_button_8->hide();
    parameters_tray_h_layout->setContentsMargins(0, 0, 0, 0);
}


/// Hide main tray in bottom navigation bar
void Spade::hide_tray()                                 //  hide all visual elements in main tray and refresh content margin of main tray layout
{
    files->hide();
    save_button->hide();
    open_button->hide();
    new_tab_button->hide();
    close_tab_button->hide();
    font_size->hide();
    template_button->hide();
    comments_button->hide();
    paint_button->hide();
    theme_button->hide();
    languages->hide();
    file_button->hide();
    project_button->hide();
    fullscreen_button->hide();
    menu_button->hide();
    tray_h_layout->setContentsMargins(0, 0, 0, 0);
}


/// Recognize language text file by file extension or by parsing file content
///
/// @param String parameter which represents file name
int Spade::recognize_language(QString & file_name)
{                                                       //  check filename extension and recognize language type by its construction
    if (file_name.endsWith(".c") || file_name.endsWith(".C"))
        return c99;

    if (file_name.endsWith(".h") || file_name.endsWith(".H") || file_name.endsWith(".hxx") || file_name.endsWith(".h++") || file_name.endsWith(".cpp") ||
        file_name.endsWith(".cxx") || file_name.endsWith(".c++") || file_name.endsWith(".hh") || file_name.endsWith(".cc"))
        return cplusplus;

    if (file_name.endsWith(".dpj") || file_name.endsWith(".java") || file_name.endsWith(".jar") || file_name.endsWith(".jsp"))
        return java;

    if (file_name.endsWith(".PHP") || file_name.endsWith(".PHTML") || file_name.endsWith(".PHP3") || file_name.endsWith(".PHP4") ||
        file_name.endsWith(".PHP5") || file_name.endsWith(".PHP7 ") || file_name.endsWith(".PHPS") ||
        file_name.endsWith(".php") || file_name.endsWith(".phtml") || file_name.endsWith(".php3") || file_name.endsWith(".php4") ||
        file_name.endsWith(".php5") || file_name.endsWith(".php7 ") || file_name.endsWith(".phps"))
        return php;

    if (file_name.endsWith(".py3") || file_name.endsWith(".py"))
        return python;

    return plain_text;
}


/// Check if file path is valid
///
/// @param  String parameter which represents file path
bool Spade::check_file_path(QString & path)
{
    if (path.size() >= 2)
    {
        if (path[0] == '~')                             //  transfer tilde character at beginning of file path into home directory string
            path = home_path + path.mid(1);

        if (isWindows == false)
        {
            if (path[0] != '/' || path[path.size() - 1] == '/')     //  file path cannot be directory
                return true;
        }

        QFileInfo check_file(path);                     //  get file info by actual file path

        if (check_file.exists())                        //  file exists
        {
            if (check_file.isFile())                    //  regular file
                return false;                           //  success
            else if (check_file.isDir())                //  directory
                return true;                            //  failure
        }
        else                                            //  file not exists
        {
            QString filename = "";

            while (path.size() && path[path.size() - 1] != '/')     //  remove file name from file path
            {
                filename = path[path.size() - 1] + filename;
                path.chop(1);
            }

            QDir dir(QDir::root());

            if (dir.mkpath(path))                       //  try to create desired directory with its subdirectories
            {
                path += filename;                       //  push filename back into file path

                ofstream fout;
                fout.open(path.toUtf8().constData(), ios::out);

                if (fout)                               //  just create desired file if it is not exists
                {
                    fout.close();
                    return false;                       //  success
                }
            }
        }
    }

    return true;                                        //  failure
}


/// Remove trailing file extension from filename or file path
///
/// @param  String parameter which represents file path
QString Spade::remove_file_extension(QString & path)
{
    QString name = path;

    while (true)
    {
        if (name.size())
        {
            if (name.right(1) == ".")
            {
                name.chop(1);
                break;
            }
            else
                name.chop(1);
        }
        else
            break;
    }

    return name;
}


/// Get just filename from full path to file
///
/// @param  String parameter which represents file path
QString Spade::get_filename_from_file_path(QString & path)
{                                                       //  get file name from file path
    QString filename = "";

    int i = path.size() - 1;

    if (path.right(1) == "/")
        i--;

    while (path.size() && path[i] != '/')
    {
        filename = path[i] + filename;
        i--;
    }

    return filename;
}


/// Get just directory from full path to file
///
/// @param  String parameter which represents file path
QString Spade::get_directory_from_file_path(QString & path)
{                                                       //  get file name from file path
    QString directory = path;

    if (directory.right(1) == "/")
    {
        directory.chop(1);
        return directory;
    }

    while (directory.size() && directory[directory.size() - 1] != '/')
        directory.chop(1);

    return directory;
}


/// Remove all comments and quotation from source code string
///
/// @param  Desired string content
/// @param  Language of content
void Spade::remove_comments_and_quotation(QString & content, int & language)
{                                                       //  remove all comments and quotation from source code string
    int N = content.size();                             //  get size of argument string

    if (language == c99 || language == cplusplus || language == java)   //  active language of actual text editor tab is C99 or C++ or Java
    {
        for (int i = 0; i < N; i++)                     //  iterate through all characters of argument string
        {
            if (i && content.mid(i - 1, 2) == "//")     //  single line comment found in string
            {
                content[i - 1] = content[i] = ' ';
                i++;

                while (i < N && content[i] != '\n')     //  replace all characters of single line comment by space characters
                {
                    content[i] = ' ';
                    i++;
                }
            }
            else if (content[i] == '"')                 //  string literal found in string

            {
                int from = i;

                while (i < N)
                {
                    if (content[i] == '\n')
                        break;
                    else if (i + 1 < N && content[i + 1] == '"' && content[i] != '\\')  //  handle escaped quotes characters
                    {
                        content[i] = ' ';
                        i++;
                        break;
                    }

                    content[i] = ' ';                   //  replace all characters of single line comment by space characters
                    i++;
                }

                content[from] = '"';
            }
            else if (content[i] == '\'')                //  character literal found in string
            {
                int from = i;

                while (i < N)
                {
                    if (content[i] == '\n')
                        break;
                    else if (i + 1 < N && content[i + 1] == '\'' && content[i] != '\\')     //  handle escaped quotes characters
                    {
                        content[i] = ' ';
                        i++;
                        break;
                    }

                    content[i] = ' ';                   //  replace all characters of single line comment by space characters
                    i++;
                }

                content[from] = '\'';
            }
            else if (i && content.mid(i - 1, 2) == "/*")   //  multi line comment found in string
            {
                content[i - 1] = content[i] = ' ';
                i++;

                while (i < N)
                {
                    if (i + 1 < N && content.mid(i, 2) == "*/")
                    {
                        content[i] = ' ';
                        i++;
                        content[i] = ' ';
                        break;
                    }

                    content[i] = ' ';
                    i++;
                }
            }
        }
    }
    else if (language == php)                           //  active language of actual text editor tab is C99 or C++ or Java
    {
        for (int i = 0; i < N; i++)                     //  iterate through all characters of argument string
        {
            if (content[i] == '#')                      //  single line comment found in string
            {
                content[i] = ' ';
                i++;

                while (i < N && content[i] != '\n')
                {
                    content[i] = ' ';                   //  replace all characters of single line comment by space characters
                    i++;
                }
            }
            else if (i && content.mid(i - 1, 2) == "//")     //  single line comment found in string
            {
                content[i - 1] = content[i] = ' ';
                i++;

                while (i < N && content[i] != '\n')     //  replace all characters of single line comment by space characters
                {
                    content[i] = ' ';
                    i++;
                }
            }
            else if (content[i] == '"')                 //  string literal found in string

            {
                int from = i;

                while (i < N)
                {
                    if (content[i] == '\n')
                        break;
                    else if (i + 1 < N && content[i + 1] == '"' && content[i] != '\\')  //  handle escaped quotes characters
                    {
                        content[i] = ' ';
                        i++;
                        break;
                    }

                    content[i] = ' ';                   //  replace all characters of single line comment by space characters
                    i++;
                }

                content[from] = '"';
            }
            else if (content[i] == '\'')                //  character literal found in string
            {
                int from = i;

                while (i < N)
                {
                    if (content[i] == '\n')
                        break;
                    else if (i + 1 < N && content[i + 1] == '\'' && content[i] != '\\')     //  handle escaped quotes characters
                    {
                        content[i] = ' ';
                        i++;
                        break;
                    }

                    content[i] = ' ';                   //  replace all characters of single line comment by space characters
                    i++;
                }

                content[from] = '\'';
            }
            else if (i && content.mid(i - 1, 2) == "/*")   //  multi line comment found in string
            {
                content[i - 1] = content[i] = ' ';
                i++;

                while (i < N)
                {
                    if (i + 1 < N && content.mid(i, 2) == "*/")
                    {
                        content[i] = ' ';
                        i++;
                        content[i] = ' ';
                        break;
                    }

                    content[i] = ' ';
                    i++;
                }
            }
        }
    }
    else if (language == python)                        //  active language of actual text editor tab is Python
    {
        for (int i = 0; i < N; i++)                     //  iterate through all characters of argument string
        {
            if (content[i] == '#')
            {
                content[i] = ' ';
                i++;

                while (i < N && content[i] != '\n')
                {
                    content[i] = ' ';                   //  replace all characters of single line comment by space characters
                    i++;
                }
            }
            else if (i + 2 < N && content.mid(i, 3) == "'''")
            {
                content[i] = content[i + 1] = content[i + 2] = ' ';
                i += 3;

                while (i < N)
                {
                    if (i + 2 < N && content.mid(i, 3) == "'''")
                    {
                        content[i] = ' ';
                        i++;
                        content[i] = ' ';
                        i++;
                        content[i] = ' ';
                        break;
                    }

                    content[i] = ' ';                   //  replace all characters of single line comment by space characters
                    i++;
                }
            }
            else if (i + 2 < N && content.mid(i, 3) == "\"\"\"")
            {
                content[i] = content[i + 1] = content[i + 2] = ' ';
                i += 3;

                while (i < N)
                {
                    if (i + 2 < N && content.mid(i, 3) == "\"\"\"")
                    {
                        content[i] = ' ';
                        i++;
                        content[i] = ' ';
                        i++;
                        content[i] = ' ';
                        break;
                    }

                    content[i] = ' ';                   //  replace all characters of single line comment by space characters
                    i++;
                }
            }
            else if (content[i] == '"')                 //  string literal found in string
            {
                int from = i;

                while (i < N)
                {
                    if (content[i] == '\n')
                        break;
                    else if (i + 1 < N && content[i + 1] == '"' && content[i] != '\\')  //  handle escaped quotes characters
                    {
                        content[i] = ' ';
                        i++;
                        break;
                    }

                    content[i] = ' ';                   //  replace all characters of single line comment by space characters
                    i++;
                }

                content[from] = '"';
            }
            else if (content[i] == '\'')                //  character literal found in string
            {
                int from = i;

                while (i < N)
                {
                    if (content[i] == '\n')
                        break;
                    else if (i + 1 < N && content[i + 1] == '\'' && content[i] != '\\')     //  handle escaped quotes characters
                    {
                        content[i] = ' ';
                        i++;
                        break;
                    }

                    content[i] = ' ';                   //  replace all characters of single line comment by space characters
                    i++;
                }

                content[from] = '\'';
            }
        }
    }
    else if (language != plain_text)                    //  active language of actual text editor tab is not plain text
    {
        //  pass
    }
}


/// Refresh all present extra selections in tab content
///
/// @param  Integer value which represents tabs index of file
void Spade::refresh_extra_selections(int files_index)
{
    int index = active_tabs[files_index].index_in_tabs;     //  get active tabs index of actual text editor tab

    QList<QTextEdit::ExtraSelection> new_extra_selections;  //  list of new extra selections in text editor content
    QString content = editor[index].document()->toPlainText();  //  get content of actual text editor tab
    int N = content.size();
    int position = editor[index].textCursor().position();   //  save actual text cursor position

    remove_comments_and_quotation(content, active_tabs[files_index].language);  //  remove all comments and quotation from source code string

    if (content[position].isLetterOrNumber() || content[position] == '_')   //  actual character is part of language identifier
    {
        int from = position;

        while (from - 1 && (content[from - 1].isLetterOrNumber() || content[from - 1] == '_'))
            from--;                                     //  iterate through previos characters while identifier is built from characaters

        while (from <= position && content[from].isNumber())    //  first character of identifier cannot be digit
            from++;

        int to = position + 1;

        while (to < N && (content[to].isLetterOrNumber() || content[to] == '_'))
            to++;                                       //  iterate through next characters while identifier is built from characaters

        QString found;

        for (int i = from; i < to; i++)
            found.push_back(content[i]);                //  save whole identifier into string

        QRegularExpression identifier_regex("[A-Za-z_][A-Za-z0-9_]*");      //  regular expression for language identifier
        identifier_regex.optimize();

        if (identifier_regex.isValid())                 //  check if regular expression of rule is valid
        {
            QRegularExpressionMatchIterator match_iter = identifier_regex.globalMatch(content);     //  check for match of regular expression from rule

            while (match_iter.hasNext())                //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                if (match.captured(0) == found)         //  actual match must be same found identifier
                {
                    QTextEdit::ExtraSelection selection;    //  underline matched identifier in text editor content
                    selection.cursor = editor[index].textCursor();
                    selection.format.setUnderlineStyle(QTextCharFormat::SingleUnderline);
                    selection.cursor.setPosition(match.capturedStart(), QTextCursor::MoveAnchor);
                    selection.cursor.setPosition(match.capturedEnd(), QTextCursor::KeepAnchor);
                    new_extra_selections.append(selection);     //  push new highlight of actual token into extra highlight of tab
                }
            }
        }
    }
    else if (content[position] == '{' || content[position] == '}')  //  text cursor is on block bracket character
    {
        class Bracket                                   //  describes single bracket
        {
        public:
            int index;                                  //  index in text
            bool is_closing;                            //  bracket type(normal or closing)
        };

        vector<Bracket> brackets;                       //  holds all brackets with same type found in text

        QRegularExpression regex("[{]|[}]");            //  regular expression for block bracket
        regex.optimize();

        if (regex.isValid())                            //  check if regular expression of rule is valid
        {
            QRegularExpressionMatchIterator match_iter = regex.globalMatch(content);     //  check for global match of regular expression from rule

            while (match_iter.hasNext())                //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                Bracket temp;                           //  create new bracket object
                temp.index = match.capturedStart();

                if (match.captured(0) == "{")           //  recognize type of concrete bracket
                    temp.is_closing = false;
                else
                    temp.is_closing = true;

                brackets.push_back(temp);               //  push new bracket into brackets list
            }
        }

        int M = brackets.size();

        for (int i = 0; i < M; i++)                     //  iterate through brackets list
        {
            if (position == brackets[i].index)          //  bracket on actual cursor position found in brackets list
            {
                int brackets_flag;

                if (brackets[i].is_closing)             //  actual bracket is closing
                {
                    brackets_flag = -1;                 //  matching bracket is found if this variable will have zero value

                    for (int j = i - 1; j >= 0; j--)    //  find appropriate normal bracket to actual closing bracket
                    {
                        if (brackets[j].is_closing)     //  refresh variable value by type of actual bracket
                            brackets_flag--;
                        else
                            brackets_flag++;

                        if (brackets_flag == 0)         //  appropriate was found
                        {                               //  highlight found matching bracket in text content
                            QTextEdit::ExtraSelection selection;
                            selection.cursor = editor[active_tabs[files_index].index_in_tabs].textCursor();
                            selection.format.setBackground(QColor(255, 150, 0, 150));
                            selection.cursor.setPosition(position, QTextCursor::MoveAnchor);
                            selection.cursor.setPosition(position + 1, QTextCursor::KeepAnchor);
                            new_extra_selections.append(selection);

                            selection.cursor = editor[active_tabs[files_index].index_in_tabs].textCursor();
                            selection.format.setBackground(QColor(255, 150, 0, 150));
                            selection.cursor.setPosition(brackets[j].index, QTextCursor::MoveAnchor);
                            selection.cursor.setPosition(brackets[j].index + 1, QTextCursor::KeepAnchor);
                            new_extra_selections.append(selection);

                            break;                      //  stop searching
                        }
                    }
                }
                else                                    //  actual bracket is normal
                {
                    brackets_flag = 1;                  //  matching bracket is found if this variable will have zero value

                    for (int j = i + 1; j < M; j++)     //  find appropriate closing bracket to actual normal bracket
                    {
                        if (brackets[j].is_closing)     //  refresh variable value by type of actual bracket
                            brackets_flag--;
                        else
                            brackets_flag++;

                        if (brackets_flag == 0)         //  appropriate was found
                        {                               //  highlight found matching bracket in text content
                            QTextEdit::ExtraSelection selection;
                            selection.cursor = editor[active_tabs[files_index].index_in_tabs].textCursor();
                            selection.format.setBackground(QColor(255, 150, 0, 150));
                            selection.cursor.setPosition(position, QTextCursor::MoveAnchor);
                            selection.cursor.setPosition(position + 1, QTextCursor::KeepAnchor);
                            new_extra_selections.append(selection);

                            selection.cursor = editor[active_tabs[files_index].index_in_tabs].textCursor();
                            selection.format.setBackground(QColor(255, 150, 0, 150));
                            selection.cursor.setPosition(brackets[j].index, QTextCursor::MoveAnchor);
                            selection.cursor.setPosition(brackets[j].index + 1, QTextCursor::KeepAnchor);
                            new_extra_selections.append(selection);

                            break;                      //  stop searching
                        }
                    }
                }

                break;
            }
        }
    }
    else if (content[position] == '(' || content[position] == ')')  //  text cursor is on classic bracket character
    {
        class Bracket                                   //  describes single bracket
        {
        public:
            int index;                                  //  index in text
            bool is_closing;                            //  bracket type(normal or closing)
        };

        vector<Bracket> brackets;                       //  holds all brackets with same type found in text

        QRegularExpression regex("[(]|[)]");            //  regular expression for classic bracket
        regex.optimize();

        if (regex.isValid())                            //  check if regular expression of rule is valid
        {
            QRegularExpressionMatchIterator match_iter = regex.globalMatch(content);     //  check for global match of regular expression from rule

            while (match_iter.hasNext())                //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                Bracket temp;                           //  create new bracket object
                temp.index = match.capturedStart();

                if (match.captured(0) == "(")           //  recognize type of concrete bracket
                    temp.is_closing = false;
                else
                    temp.is_closing = true;

                brackets.push_back(temp);               //  push new bracket into brackets list
            }
        }

        int M = brackets.size();

        for (int i = 0; i < M; i++)                     //  iterate through brackets list
        {
            if (position == brackets[i].index)          //  bracket on actual cursor position found in brackets list
            {
                int brackets_flag;

                if (brackets[i].is_closing)             //  actual bracket is closing
                {
                    brackets_flag = -1;                 //  matching bracket is found if this variable will have zero value

                    for (int j = i - 1; j >= 0; j--)    //  find appropriate normal bracket to actual closing bracket
                    {
                        if (brackets[j].is_closing)     //  refresh variable value by type of actual bracket
                            brackets_flag--;
                        else
                            brackets_flag++;

                        if (brackets_flag == 0)         //  appropriate was found
                        {                               //  highlight found matching bracket in text content
                            QTextEdit::ExtraSelection selection;
                            selection.cursor = editor[active_tabs[files_index].index_in_tabs].textCursor();
                            selection.format.setBackground(QColor(255, 150, 0, 150));
                            selection.cursor.setPosition(position, QTextCursor::MoveAnchor);
                            selection.cursor.setPosition(position + 1, QTextCursor::KeepAnchor);
                            new_extra_selections.append(selection);

                            selection.cursor = editor[active_tabs[files_index].index_in_tabs].textCursor();
                            selection.format.setBackground(QColor(255, 150, 0, 150));
                            selection.cursor.setPosition(brackets[j].index, QTextCursor::MoveAnchor);
                            selection.cursor.setPosition(brackets[j].index + 1, QTextCursor::KeepAnchor);
                            new_extra_selections.append(selection);

                            break;                      //  stop searching
                        }
                    }
                }
                else                                    //  actual bracket is normal
                {
                    brackets_flag = 1;                  //  matching bracket is found if this variable will have zero value

                    for (int j = i + 1; j < M; j++)     //  find appropriate closing bracket to actual normal bracket
                    {
                        if (brackets[j].is_closing)     //  refresh variable value by type of actual bracket
                            brackets_flag--;
                        else
                            brackets_flag++;

                        if (brackets_flag == 0)         //  appropriate was found
                        {                               //  highlight found matching bracket in text content
                            QTextEdit::ExtraSelection selection;
                            selection.cursor = editor[active_tabs[files_index].index_in_tabs].textCursor();
                            selection.format.setBackground(QColor(255, 150, 0, 150));
                            selection.cursor.setPosition(position, QTextCursor::MoveAnchor);
                            selection.cursor.setPosition(position + 1, QTextCursor::KeepAnchor);
                            new_extra_selections.append(selection);

                            selection.cursor = editor[active_tabs[files_index].index_in_tabs].textCursor();
                            selection.format.setBackground(QColor(255, 150, 0, 150));
                            selection.cursor.setPosition(brackets[j].index, QTextCursor::MoveAnchor);
                            selection.cursor.setPosition(brackets[j].index + 1, QTextCursor::KeepAnchor);
                            new_extra_selections.append(selection);

                            break;                      //  stop searching
                        }
                    }
                }

                break;
            }
        }
    }
    else if (content[position] == '[' || content[position] == ']')  //  text cursor is on array bracket character
    {
        class Bracket                                   //  describes single bracket
        {
        public:
            int index;                                  //  index in text
            bool is_closing;                            //  bracket type(normal or closing)
        };

        vector<Bracket> brackets;                       //  holds all brackets with same type found in text

        QRegularExpression regex("\\[|\\]");            //  regular expression for array bracket
        regex.optimize();

        if (regex.isValid())                            //  check if regular expression of rule is valid
        {
            QRegularExpressionMatchIterator match_iter = regex.globalMatch(content);     //  check for global match of regular expression from rule

            while (match_iter.hasNext())                //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                Bracket temp;                           //  create new bracket object
                temp.index = match.capturedStart();

                if (match.captured(0) == "[")           //  recognize type of concrete bracket
                    temp.is_closing = false;
                else
                    temp.is_closing = true;

                brackets.push_back(temp);               //  push new bracket into brackets list
            }
        }

        int M = brackets.size();

        for (int i = 0; i < M; i++)                     //  iterate through brackets list
        {
            if (position == brackets[i].index)          //  bracket on actual cursor position found in brackets list
            {
                int brackets_flag;

                if (brackets[i].is_closing)             //  actual bracket is closing
                {
                    brackets_flag = -1;                 //  matching bracket is found if this variable will have zero value

                    for (int j = i - 1; j >= 0; j--)    //  find appropriate normal bracket to actual closing bracket
                    {
                        if (brackets[j].is_closing)     //  refresh variable value by type of actual bracket
                            brackets_flag--;
                        else
                            brackets_flag++;

                        if (brackets_flag == 0)         //  appropriate was found
                        {                               //  highlight found matching bracket in text content
                            QTextEdit::ExtraSelection selection;
                            selection.cursor = editor[active_tabs[files_index].index_in_tabs].textCursor();
                            selection.format.setBackground(QColor(255, 150, 0, 150));
                            selection.cursor.setPosition(position, QTextCursor::MoveAnchor);
                            selection.cursor.setPosition(position + 1, QTextCursor::KeepAnchor);
                            new_extra_selections.append(selection);

                            selection.cursor = editor[active_tabs[files_index].index_in_tabs].textCursor();
                            selection.format.setBackground(QColor(255, 150, 0, 150));
                            selection.cursor.setPosition(brackets[j].index, QTextCursor::MoveAnchor);
                            selection.cursor.setPosition(brackets[j].index + 1, QTextCursor::KeepAnchor);
                            new_extra_selections.append(selection);

                            break;                      //  stop searching
                        }
                    }
                }
                else                                    //  actual bracket is normal
                {
                    brackets_flag = 1;                  //  matching bracket is found if this variable will have zero value

                    for (int j = i + 1; j < M; j++)     //  find appropriate closing bracket to actual normal bracket
                    {
                        if (brackets[j].is_closing)     //  refresh variable value by type of actual bracket
                            brackets_flag--;
                        else
                            brackets_flag++;

                        if (brackets_flag == 0)         //  appropriate was found
                        {                               //  highlight found matching bracket in text content
                            QTextEdit::ExtraSelection selection;
                            selection.cursor = editor[active_tabs[files_index].index_in_tabs].textCursor();
                            selection.format.setBackground(QColor(255, 150, 0, 150));
                            selection.cursor.setPosition(position, QTextCursor::MoveAnchor);
                            selection.cursor.setPosition(position + 1, QTextCursor::KeepAnchor);
                            new_extra_selections.append(selection);

                            selection.cursor = editor[active_tabs[files_index].index_in_tabs].textCursor();
                            selection.format.setBackground(QColor(255, 150, 0, 150));
                            selection.cursor.setPosition(brackets[j].index, QTextCursor::MoveAnchor);
                            selection.cursor.setPosition(brackets[j].index + 1, QTextCursor::KeepAnchor);
                            new_extra_selections.append(selection);

                            break;                      //  stop searching
                        }
                    }
                }

                break;
            }
        }
    }

    int count = active_tabs[files_index].custom_selections_count;   //  get number of found new extra selections
    QList<QTextEdit::ExtraSelection> custom_selections;

    while (count)                                       //  remove old extra selections from list
    {                                                   //  save all custom selections into appropriate list
        custom_selections.push_back(active_tabs[files_index].extra_selections.front());
        count--;
        active_tabs[files_index].extra_selections.pop_front();  //  remove front item from extra selections list
    }

    new_extra_selections = custom_selections + new_extra_selections;    //  insert all custom selections into new extra selections
    active_tabs[files_index].extra_selections = new_extra_selections;   //  refresh extra selections variable of text editor actual tab
    editor[active_tabs[files_index].index_in_tabs].setExtraSelections(new_extra_selections);    //  apply new extra selections to actual tab
}


/// Enable or disable undo and redo buttons by availability of these operations
void Spade::refresh_undo_redo_buttons()
{                                                       //  refresh undo and redo button by the availability undo and redo operations
    bool undo_flag = editor[active_tabs[files->currentIndex()].index_in_tabs].document()->isUndoAvailable();
    bool redo_flag = editor[active_tabs[files->currentIndex()].index_in_tabs].document()->isRedoAvailable();

    if (undo_button->isEnabled() && undo_flag == false)
        undo_button->setDisabled(true);
    else if (undo_button->isEnabled() == false && undo_flag)
        undo_button->setEnabled(true);

    if (redo_button->isEnabled() && redo_flag == false)
        redo_button->setDisabled(true);
    else if (redo_button->isEnabled() == false && redo_flag)
        redo_button->setEnabled(true);
}


/// Find language inside languages list by name string
///
/// @param  Name of language as a string
int Spade::find_language(QString & name)
{
    int len = user_languages.size();

    for (int i = 0; i < len; i++)
    {
        if (user_languages[i].name == name)             //  find appropriate language by its name
            return i;
    }

    return -1;
}


/// Get language saved on desired index
///
/// @param  Return language type instance
/// @param  Integer index of language
void Spade::get_language(Language & user_language, int index)
{
    user_language = user_languages[index];
}


/// Add new language into languages list
///
/// @param  Return language type instance
void Spade::push_language(Language & user_language)
{
    user_languages.push_back(user_language);
}


/// Replace language on desired index
///
/// @param  Return language type instance
/// @param  Integer index of language
void Spade::update_language(Language & user_language, int index)
{
    user_languages[index] = user_language;
}


/// Remove language on desired index
///
/// @param  Integer index of language
void Spade::remove_language(int index)
{
    user_languages.removeAt(index);
}


/// Reaction to application exit
void Spade::handle_exit()
{
    QFile projects_file(projects_file_path);

    if (projects_file.open(QFile::WriteOnly | QFile::Text | QFile::Truncate))    //  projects file was successfully opened for writing
    {
        QTextStream fout(&projects_file);

        fout << terminal_name->text() << char(29);
        int N = active_projects.size();

        for (int i = 0; i < N; i++)
            fout << active_projects[i].path << char(29);

        projects_file.close();                          //  close projects file
    }

    QFile language_file(language_file_path);

    if (language_file.open(QFile::WriteOnly | QFile::Text | QFile::Truncate))    //  language file was successfully opened for writing
    {
        QTextStream fout(&language_file);

        int N = custom_languages->count();
        fout << N << char(29);

        for (int i = 0; i < N; i++)
        {
            Language user_language;
            user_language = user_languages[i];

            int elements_len = user_language.subElements.size();
            int comments_len = user_language.comments.size();

            bool multiline_flag = false;

            if (user_language.multiline_comment_from.size() && user_language.multiline_comment_to.size())
                multiline_flag = true;

            fout << user_language.name << char(29) << elements_len << char(29) << comments_len << char(29) << multiline_flag << char(29);

            for (int j = 0; j < elements_len; j++)
            {
                fout << user_language.subElements[j].regex << char(29) << user_language.subElements[j].color_1
                     << char(29) << user_language.subElements[j].color_2 << char(29) << user_language.subElements[j].color_3
                     << char(29) << user_language.subElements[j].color_4 << char(29) << user_language.subElements[j].color_5
                     << char(29) << user_language.subElements[j].color_6 << char(29);
            }

            for (int j = 0; j < comments_len; j++)
            {
                fout << user_language.comments[j].from << char(29) << user_language.comments[j].color_1
                     << char(29) << user_language.comments[j].color_2 << char(29) << user_language.comments[j].color_3
                     << char(29) << user_language.comments[j].color_4 << char(29) << user_language.comments[j].color_5
                     << char(29) << user_language.comments[j].color_6 << char(29);
            }

            if (multiline_flag)
            {
                fout << user_language.multiline_comment_from << char(29) << user_language.multiline_comment_to << char(29)
                     << user_language.multiline_comment_color_1 << char(29) << user_language.multiline_comment_color_2 << char(29)
                     << user_language.multiline_comment_color_3 << char(29) << user_language.multiline_comment_color_4 << char(29)
                     << user_language.multiline_comment_color_5 << char(29) << user_language.multiline_comment_color_6 << char(29);
            }
        }

        language_file.close();                          //  close language file
    }

    QFile config_file(config_file_path);

    if (config_file.open(QFile::WriteOnly | QFile::Text | QFile::Truncate))    //  configuration file was successfully opened for writing
    {
        QTextStream fout(&config_file);

        int N = active_tabs.size();                     //  get number of active tabs in text editor

        if (N)                                          //  at least one tab is still opened in text editor
        {
            int actual = files->currentIndex();         //  get actual index of files combo box
                                                        //  save values of global flags and variables into configuration file
            fout << bold_flag << char(29) << italic_flag << char(29) << regex_flag << char(29) << case_flag
                 << char(29) << boundary_flag << char(29) << actual << char(29) << QString("%1").arg(color.red())
                 << char(29) << QString("%1").arg(color.green()) << char(29) << QString("%1").arg(color.blue())
                 << char(29) << QString("%1").arg(color.alpha());

            for (int i = 0; i < N; i++)                 //  iterate through all opened tabs
            {
                int count = active_tabs[i].custom_selections_count;     //  get number of all custom highlights in all tabs of text editor
                QString selections = "";                //  holds information about all custom highlights in all tabs of text editor

                for (int j = 0; j < count; j++)         //  iterate through all custom highlights in all tabs of text editor
                {
                    if (j)                              //  separate all custom highlights using | character for better parsing
                        selections.push_back("|");

                    selections += QString("%1").arg(active_tabs[i].extra_selections.front().format.background().color().red());
                    selections.push_back(" ");          //  save red part of RGB value of actual custom highlight
                    selections += QString("%1").arg(active_tabs[i].extra_selections.front().format.background().color().green());
                    selections.push_back(" ");          //  save green part of RGB value of actual custom highlight
                    selections += QString("%1").arg(active_tabs[i].extra_selections.front().format.background().color().blue());
                    selections.push_back(" ");          //  save blue part of RGB value of actual custom highlight
                    selections += QString("%1").arg(active_tabs[i].extra_selections.front().format.background().color().alpha());
                    selections.push_back(" ");          //  save alpha part of RGB value of actual custom highlight
                    selections += QString("%1").arg(active_tabs[i].extra_selections.front().cursor.anchor());
                    selections.push_back(" ");          //  save starting position value of actual custom highlight
                    selections += QString("%1").arg(active_tabs[i].extra_selections.front().cursor.position());
                                                        //  save starting position value of actual custom highlight
                    active_tabs[i].extra_selections.pop_front();    //  remove actual custom highlight from extra selections of actual tab
                }

                fout << char(29)
                << active_tabs[i].index_in_tabs << char(29)     //  save index in text editor tabs into configuration file
                << active_tabs[i].language << char(29)      //  save language value into configuration file
                << active_tabs[i].file_path << char(29)     //  save file path into configuration file
                << active_tabs[i].file_name << char(29)     //  save file name into configuration file
                << active_tabs[i].font_size << char(29)     //  save font size value into configuration file
                << active_tabs[i].scroll_bars << char(29)   //  save scroll bars flag value into configuration file
                << active_tabs[i].comments << char(29)  //  save comments flag value into configuration file
                << active_tabs[i].theme << char(29)     //  save theme value into configuration file
                << editor[active_tabs[i].index_in_tabs].document()->toPlainText() << char(29)   //  save actual tab content into configuration file
                << selections << char(29)               //  save selections string into configuration file
                << editor[active_tabs[i].index_in_tabs].actual_selection.from << char(29)   //  save selection coordinates into configuration file
                << editor[active_tabs[i].index_in_tabs].actual_selection.to << char(29)
                << editor[active_tabs[i].index_in_tabs].verticalScrollBar()->value() << char(29)
                << editor[active_tabs[i].index_in_tabs].horizontalScrollBar()->value();     //  save positions of scroll bars into configuration file
            }
        }

        config_file.close();                            //  close configuration file
    }
}


/// Reaction to fullscreen toggle
void Spade::handle_fullscreen()
{
    if (fullscreen)                                     //  fullscreen mode is active
        fullscreen_button->setIcon(* fullscreen_off_icon);  //  refresh icon of fullscreen button
    else                                                //  fullscreen mode is not active
        fullscreen_button->setIcon(* fullscreen_on_icon);   //  refresh icon of fullscreen button

    fullscreen = !fullscreen;                           //  invert fullscreen flag
}


/// Reaction to change of layout
///
/// @param  Integer index of text editor in window
void Spade::handle_layouts(int index)
{
    layouts->setCurrentIndex(index);
}


/// Get language from another layout
///
/// @param  Return language type instance
void Spade::receive_language(Language & user_language)
{
    int index = find_language(user_language.name);

    if (index == -1)
    {
        push_language(user_language);
        custom_languages->addItem(user_language.name);
        languages->addItem(user_language.name);
    }
    else
    {
        int N = active_tabs.size();                         //  get number of active tabs

        for (int i = 0; i < N; i++)                     //  iterate through all tabs of text editor
        {
            if (active_tabs[i].language == index + builtInLanguages)
                return;
        }

        update_language(user_language, index);
    }
}


/// Handle exit of text editor
void Spade::exit_editor()
{
    emit exit_signal();
}


/// Slot method to handle cursor movement timeout
void Spade::handle_cursor_timeout()
{
    cursor_timer->stop();                               //  stop generic timer
    refresh_extra_selections(files->currentIndex());    //  refresh extra selection for actual text editor tab
}


/// Slot method to handle text content change timeout
void Spade::handle_text_change_timeout()
{
    text_change_timer->stop();

    if (class_tree_visible)                             //  check if class tree is already visible
        refresh_class_tree();                           //  refresh class tree content
}


/// Slot method to handle change of document slider position
void Spade::slider_position_changed()
{
    if (vim_tray_visible)
    {
        int line = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().blockNumber();
        int field = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().columnNumber();
        vim_coordinates->setText(QString("%1,%2").arg(line).arg(field));

        double max = editor[active_tabs[files->currentIndex()].index_in_tabs].verticalScrollBar()->maximum();
        double value = editor[active_tabs[files->currentIndex()].index_in_tabs].verticalScrollBar()->value() / max;
        value *= 100.0;
        int percent = value;

        if (percent == 0)
            vim_position->setText("Top");
        else if (percent == 100)
            vim_position->setText("Bot");
        else if (percent > 0 && percent < 100)
            vim_position->setText(QString("%1%").arg(percent));
        else
            vim_position->setText("All");
    }
}


/// Slot method to handle change of text cursor position
void Spade::cursor_position_changed()
{
    cursor_timer->start(500);                           //  start half second countdown if text cursor position changed
    slider_position_changed();
}


/// Slot method to handle change of text editor content
void Spade::editor_text_changed()
{
    int index = files->currentIndex();                  //  actual index in active tabs

    QString file_content = "";
    QFile file(active_tabs[index].file_path);

    if (file.open(QFile::ReadOnly | QFile::Text))       //  read file content from disk
    {
        QTextStream fin(&file);
        file_content = fin.readAll();
        file.close();
    }
                                                        //  check if content of text editor tab is same as content saved on disk
    if (file_content != editor[active_tabs[index].index_in_tabs].document()->toPlainText())
    {
        if (active_tabs[index].saved)
        {
            active_tabs[index].saved = false;
            close_tab_button->setIcon(* warning_icon);
        }
    }
    else
    {
        if (active_tabs[index].saved == false)
        {
            active_tabs[index].saved = true;
            close_tab_button->setIcon(* close_icon);
        }
    }

    int N = active_tabs[index].custom_selections_count;

    for (int i = 0; i < N; i++)                         //  check if some custom highlights was removed from content or its position changed
    {
        if (active_tabs[index].extra_selections.at(i).cursor.anchor() == active_tabs[index].extra_selections.at(i).cursor.position())
        {
            active_tabs[index].extra_selections.removeAt(i);
            active_tabs[index].custom_selections_count--;

            i--;
            N--;
        }
    }

    handle_cursor_timeout();
    refresh_undo_redo_buttons();                        //  refresh undo and redo push buttons

    if (class_tree_visible)                             //  check if class tree is already visible
    {
        if (projects->currentIndex())                   //  check if there is at least one opened project
        {
            QString path = active_tabs[files->currentIndex()].file_path;
            int N = active_projects[projects->currentIndex() - 1].files.size();

            for (int i = 0; i < N; i++)
            {
                if (active_projects[projects->currentIndex() - 1].files[i] == path)
                {
                    text_change_timer->start(3000);     //  start second countdown if text editor content changed
                    break;
                }
            }
        }
        else
            text_change_timer->start(3000);             //  start second countdown if text editor content changed
    }
}


/// Slot method to handle block signal from syntax highlighter
///
/// @param  Text block index value
void Spade::handle_block(int block_index)
{
    int index = active_tabs[files->currentIndex()].index_in_tabs;
    editor[index].handle_line_change(block_index);
}


/// Slot method to handle press event of clickable label object
///
/// @param  Integer identifier of clickable label
void Spade::clickable_label_pressed(int id)
{
    if (id)
    {
    }

    hide_theme_tray();                                  //  hide theme tray if one of theme images was pushed
    show_tray();

    theme_tray_visible = false;
    tray_visible = true;
}


/// Slot method to handle enter event of clickable label object
///
/// @param  Integer identifier of clickable label
void Spade::clickable_label_entered(int id)
{
    if (id != active_tabs[files->currentIndex()].theme)     //  select color scheme is not same as color scheme of actual text editor tab
    {
        int index = active_tabs[files->currentIndex()].index_in_tabs;
        active_tabs[files->currentIndex()].theme = id;
        init_palette(id);                               //  refresh text editor color palette by actual color scheme value
        editor[index].setPalette(* theme_color);        //  set color palette of text editor tab
        editor[index].theme = id;

        int language = active_tabs[files->currentIndex()].language;
                                                        //  update color scheme of actual text editor tab
        int language_index = language - builtInLanguages;
        highlighters[index]->applyRules(&(user_languages[language_index]), language, active_tabs[files->currentIndex()].comments, id);
    }
}


/// Handle press of undo button
void Spade::undo_button_pressed()
{
    editor[active_tabs[files->currentIndex()].index_in_tabs].text_undo();   //  call improved undo method from code editor class
}


/// Handle press of redo button
void Spade::redo_button_pressed()
{
    editor[active_tabs[files->currentIndex()].index_in_tabs].text_redo();   //  call improved redo method from code editor class
}


/// Handle press of save all button
void Spade::save_all_button_pressed()
{
    int N = active_tabs.size();

    for (int i = 0; i < N; i++)                         //  iterate through all active text editor tabs
    {
        if (active_tabs[i].saved == false && active_tabs[i].file_path != "New tab")   //  do nothing if file is saved or file is empty tab
        {
            active_tabs[i].saved = true;

            QFile file(active_tabs[i].file_path);

            if (file.open(QFile::WriteOnly | QFile::Text | QFile::Truncate))    //  open file for writing
            {
                QTextStream fout(&file);
                fout << editor[active_tabs[i].index_in_tabs].document()->toPlainText();     //  save content from text editor tab into appropriate file
                file.close();
            }

            editor[active_tabs[i].index_in_tabs].save_content();    //  call special method from code editor to handle file save
        }
    }

    close_tab_button->setIcon(* close_icon);            //  refresh close push button icon
}


/// Handle press of reload button
void Spade::reload_button_pressed()
{
    if (active_tabs[files->currentIndex()].saved)       //  do nothing if file is saved
        return;

    QFile file(active_tabs[files->currentIndex()].file_path);

    if (file.open(QFile::ReadOnly | QFile::Text))       //  file was successfully opened for reading
    {
        QTextStream fin(&file);
        editor[active_tabs[files->currentIndex()].index_in_tabs].selectAll();
        editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText(fin.readAll());    //  read content from file and insert it into editor
        editor[active_tabs[files->currentIndex()].index_in_tabs].save_content();

        file.close();

        active_tabs[files->currentIndex()].saved = true;    //  mark actual text editor tab content as saved
        close_tab_button->setIcon(* close_icon);
    }
}


/// Handle press of open button
void Spade::open_button_pressed()
{
    if (vim_tray_visible)
        return;

    QString path = "";                                  //  holds full path to file which will be opened
    int parameters_len = parameters.size();

    if (parameters_len)                                 //  check if there are some parameters of program
    {
        for (int i = 0; i < parameters_len; i++)
        {
            path = parameters[i];

            if (path.left(1) != "/" && path.left(1) != "~")     //  file path is relative
            {
                QString temp = QDir::currentPath();     //  get actual working directory path

                if (temp.right(1) != "/")
                    temp.push_back('/');

                path = temp + path;                     //  connect relative file path with actual working directory path
            }

            QDir temp_dir(path);
            path = temp_dir.canonicalPath();
            parameters[i] = path;
        }
    }
    else
    {
        parameters = file_dialog->getOpenFileNames
        (
            this,                                       //  parent
            "Select concrete files",                    //  file dialog title
            QDir::homePath(),                           //  default directory
            "All files (*);;"
            "Text files (*.txt *.dat);;"
            "C header files (*.h *.H);;"
            "C source files (*.c *.C);;"
            "C++ header files (*.hh *.hxx *.h++);;"
            "C++ source files (*.cpp *.cc *.cxx *.c++);;"
            "Java source files (*.java *.jar *.jsp *.dpj);;"
            "PHP source files (*.php *.phtml *.php3 *.php4 *.php5 *.php7 *.phps);;"
            "Python source files (*.py *.py3)",         //  file filter
            (QString *)(nullptr),                       //  pointer to string of selected filter
            QFileDialog::DontResolveSymlinks            //  ignore symbolic links
        );

        parameters_len = parameters.size();
    }

    for (int iter = 0; iter < parameters_len; iter++)
    {
        path = parameters[iter];

        if (active_tabs.size() < (unsigned)max_tabs)    //  check if maximum allowed number of tabs is not reached
        {
            int index = 0;
            int N = active_tabs.size();
            bool success = true;

            for (int i = 0; i < N; i++)                 //  check if desired file to open is not already opened is text editor
            {
                if (active_tabs[i].file_path == path)   //  same file cannot be opened twice
                {
                    success = false;
                    break;
                }
            }

            if (success == false)
                continue;

            if (check_file_path(path))                  //  check validity of file path of new file
                continue;

            for (int i = 0; i <= max_index; i++)        //  iterate through all text editor tabs(not active tabs too)
            {
                bool index_used = false;

                for (int j = 0; j < N; j++)
                {
                    if (active_tabs[j].index_in_tabs == i)  //  find first not used text editor tab
                    {
                        index_used = true;
                        break;
                    }
                }

                if (index_used == false)
                {
                    index = i;                          //  save found empty place
                    break;
                }
            }

            QString file_name = get_filename_from_file_path(path);  //  get file name from file path
            int language = recognize_language(file_name);   //  recognize language from file

            Tab_details temp;                           //  create new temporary tab details object
            temp.language = language;
            temp.file_path = path;
            temp.file_name = file_name;
            temp.index_in_tabs = index;
            temp.font_size = active_tabs[files->currentIndex()].font_size;
            font.setPointSize(temp.font_size);
            temp.theme = active_tabs[files->currentIndex()].theme;

            active_tabs.push_back(temp);                //  push back new tab into active tabs array
            files_watcher->addPath(path);               //  add path of new file into file system watcher

            QString content = "";
            QFile file(path);

            if (file.open(QFile::ReadOnly | QFile::Text))
            {
                QTextStream fin(&file);
                content = fin.readAll();                //  get content of file from disk
                file.close();
            }

            editor[index].content = content;            //  refresh code editor code variable
            int content_len = content.size();
            int j = 0;
            vector<bool> differences;

            while (j < content_len)                     //  create new element of differences array
            {
                if (content[j] == '\n')
                    differences.push_back(false);

                j++;
            }

            differences.push_back(false);

            editor[index].differences.clear();          //  clear differences array
            editor[index].differences.push_back(differences);   //  push back new element into differences array
            editor[index].actual_difference = differences;  //  refresh actual differences
            editor[index].differences_index = 0;        //  refresh differences index value
            editor[index].setPlainText(content);        //  load content of file into text editor tab
            editor[index].moveCursor(QTextCursor::Start);   //  move cursor to begin of source file
            editor[index].update();
            editor[index].setFont(font);                //  refresh font of new text editor tab
            QFontMetrics metrics(editor[index].font());     //  refresh tab width to appropriate value using font metrics
            editor[index].setTabStopWidth(4 * metrics.width(' '));

            files->addItem(file_name);                  //  add new item into files combo box with information about new tab
            files->setItemData(active_tabs.size() - 1, path, Qt::ToolTipRole);
            files->setCurrentIndex(active_tabs.size() - 1);
            files->setToolTip(path);

            init_palette(temp.theme);                   //  refresh theme color palette
            editor[index].setPalette(* theme_color);    //  set color palette for text editor tab
            editor[index].theme = temp.theme;           //  refresh theme variable of code editor
            editor[index].file_path = temp.file_path;   //  refresh file path variable of code editor

            int language_index = language - builtInLanguages;
            highlighters[index]->applyRules(&(user_languages[language_index]), language, true, temp.theme);     //  set appropriate syntax highlighter for new tab of text editor

            file_selected(active_tabs.size() - 1);      //  move to new tab of text editor
        }
    }

    parameters.clear();
}


/// Handle press of new tab button
void Spade::new_tab_button_pressed()
{
    if (vim_tray_visible)
        return;

    if (active_tabs.size() < (unsigned)max_tabs)        //  check if maximum allowed number of tabs is not reached
    {
        int index = 0;
        int N = active_tabs.size();

        for (int i = 0; i <= max_index; i++)            //  iterate through all text editor tabs(not active tabs too)
        {
            bool index_used = false;

            for (int j = 0; j < N; j++)
            {
                if (active_tabs[j].index_in_tabs == i)  //  find first not user text editor tab
                {
                    index_used = true;
                    break;
                }
            }

            if (index_used == false)
            {
                index = i;                              //  save found empty place
                break;
            }
        }

        Tab_details temp;                               //  create new temporary tab details object
        temp.language = plain_text;
        temp.file_path = "New tab";
        temp.file_name = "untitled";
        temp.index_in_tabs = index;
        temp.font_size = active_tabs[files->currentIndex()].font_size;
        font.setPointSize(temp.font_size);
        temp.theme = active_tabs[files->currentIndex()].theme;

        active_tabs.push_back(temp);                    //  push back new tab into active tabs array
        QString content = "";

        editor[index].content = content;                //  refresh code editor code variable
        int content_len = content.size();
        int j = 0;
        vector<bool> differences;

        while (j < content_len)                         //  create new element of differences array
        {
            if (content[j] == '\n')
                differences.push_back(false);

            j++;
        }

        differences.push_back(false);

        editor[index].differences.clear();              //  clear differences array
        editor[index].differences.push_back(differences);   //  push back new element into differences array
        editor[index].actual_difference = differences;  //  refresh actual differences
        editor[index].differences_index = 0;            //  refresh differences index value
        editor[index].setPlainText(content);            //  load content of file into text editor tab
        editor[index].moveCursor(QTextCursor::Start);   //  move cursor to begin of source file
        editor[index].update();
        editor[index].setFont(font);                    //  refresh font of new text editor tab
        QFontMetrics metrics(editor[index].font());     //  refresh tab width to appropriate value using font metrics
        editor[index].setTabStopWidth(4 * metrics.width(' '));

        files->addItem("untitled");                     //  add new item into files combo box with information about new tab
        files->setItemData(active_tabs.size() - 1, "New tab", Qt::ToolTipRole);
        files->setCurrentIndex(active_tabs.size() - 1);
        files->setToolTip("New tab");

        init_palette(temp.theme);                       //  refresh theme color palette
        editor[index].setPalette(* theme_color);        //  set color palette for text editor tab
        editor[index].theme = temp.theme;               //  refresh theme variable of code editor
        editor[index].file_path = "New tab";            //  refresh file path variable of code editor

        file_selected(active_tabs.size() - 1);          //  move to new tab of text editor
    }
}


/// Handle selection of tab width
///
/// @param  Tab width specified as an integer value
void Spade::tab_width_selected(int index)
{
    tab_width->setCurrentIndex(index);
    int actual = files->currentIndex();
    int editor_index = active_tabs[actual].index_in_tabs;

    active_tabs[actual].tab_width = index + 1;          //  refresh tab width value of actual text editor tab

    QFontMetrics metrics(editor[editor_index].font());  //  refresh tab width to appropriate value using font metrics
    editor[editor_index].setTabStopWidth((index + 1) * metrics.width(' '));
}


/// Handle selection of window layout
///
/// @param  Integer index of layout
void Spade::layout_selected(int index)
{
    emit layout_signal(index);
}


/// Handle press of first back button
void Spade::back_button_pressed()
{
    hide_file_tray();                                   //  hide file tray
    show_tray();                                        //  show main tray

    file_tray_visible = false;                          //  refresh values of appropriate flags
    tray_visible = true;
}


/// Handle press of color button
void Spade::color_button_pressed()
{
    QColor temp_color = QColorDialog::getColor(color, this, "Color selection", QColorDialog::ShowAlphaChannel | QColorDialog::DontUseNativeDialog);

    if (temp_color.isValid())                           //  let user to select desired RGB color using color dialog
    {
        color = temp_color;                             //  refresh icon of color push button
        color_pixmap->fill(color);
        color_button->setIcon(QIcon(* color_pixmap));
        color_button->setIconSize(QSize(18, 18));
    }
}


/// Handle press of apply button
void Spade::apply_button_pressed()
{
    int from = editor[active_tabs[files->currentIndex()].index_in_tabs].actual_selection.from;  //  save coordinates of actual text cursor selection
    int to = editor[active_tabs[files->currentIndex()].index_in_tabs].actual_selection.to;

    if (from != to)                                     //  at least one character selected
    {
        QTextEdit::ExtraSelection selection;
        selection.cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
        selection.format.setBackground(color);          //  get actual color for custom highlights
        selection.cursor.setPosition(from, QTextCursor::MoveAnchor);
        selection.cursor.setPosition(to, QTextCursor::KeepAnchor);
        active_tabs[files->currentIndex()].extra_selections.push_front(selection);  //  update extra selections of actual text editor tab
        active_tabs[files->currentIndex()].custom_selections_count++;
        handle_cursor_timeout();                        //  refresh extra selections in tab
    }
}


/// Handle press of rubber button
void Spade::rubber_button_pressed()
{
    int N = active_tabs[files->currentIndex()].custom_selections_count;

    if (N)
    {
        int position = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();    //  get actual text cursor position
        bool removed = false;

        for (int i = 0; i < N; i++)                     //  find if some custom highlight is not matching with cursor position
        {
            if (active_tabs[files->currentIndex()].extra_selections.at(i).cursor.anchor() <= position &&
                position <= active_tabs[files->currentIndex()].extra_selections.at(i).cursor.position())
            {
                removed = true;                         //  remove matching custom highlight from text editor tab
                active_tabs[files->currentIndex()].extra_selections.removeAt(i);
                active_tabs[files->currentIndex()].custom_selections_count--;

                i--;
                N--;
            }
        }

        if (removed)
            handle_cursor_timeout();                    //  refresh extra selections in actual text editor tab
    }
}


/// Handle press of second undo button
void Spade::undo_button_2_pressed()
{
    if (active_tabs[files->currentIndex()].custom_selections_count)
    {
        active_tabs[files->currentIndex()].custom_selections_count--;
        active_tabs[files->currentIndex()].extra_selections.pop_front();    //  remove last custom highlight from actual text editor tab
        editor[active_tabs[files->currentIndex()].index_in_tabs].setExtraSelections(active_tabs[files->currentIndex()].extra_selections);
    }                                                   //  refresh extra selections in actual text editor tab
}


/// Handle press of clear button
void Spade::clear_button_pressed()
{                                                       //  remove all custom highlights from actual text editor tab
    while (active_tabs[files->currentIndex()].custom_selections_count)  //  iterate throudh all extra selections of actual text editor tab
    {
        active_tabs[files->currentIndex()].custom_selections_count--;
        active_tabs[files->currentIndex()].extra_selections.pop_front();
        editor[active_tabs[files->currentIndex()].index_in_tabs].setExtraSelections(active_tabs[files->currentIndex()].extra_selections);
    }                                                   //  refresh extra selections in actual text editor tab
}


/// Handle press of second back button
void Spade::back_button_2_pressed()
{
    hide_paint_tray();                                  //  hide paint tray
    show_tray();                                        //  show main tray

    paint_tray_visible = false;                         //  refresh values of appropriate flags
    tray_visible = true;
}


/// Handle press of find button
void Spade::find_button_pressed()
{
    show_find_tray();                                   //  show find tray
    hide_actions_tray();                                //  hide actions tray

    find_tray_visible = true;                           //  refresh values of appropriate flags
    actions_tray_visible = false;
}


/// Handle press of swap line up button
void Spade::swap_line_up_button_pressed()
{
    int index = active_tabs[files->currentIndex()].index_in_tabs;
    QString content = editor[index].document()->toPlainText();
    * text_cursor = editor[index].textCursor();         //  set pointer to text cursor of actual editor tab
    int position = text_cursor->position();
    int from = text_cursor->selectionStart();           //  get cursor selection coordinates
    int to = text_cursor->selectionEnd();
    int up_line;                                        //  holds top line of lines which will be swapped up
    int down_line;                                      //  holds bottom line of lines which will be swapped up

    if (position == from)                               //  cursor position is on top line of lines to swap up
    {
        up_line = text_cursor->blockNumber();
        down_line = up_line;

        for (int i = from; i < to; i++)                 //  find all newline characters inside cursor selection area
        {
            if (content[i] == '\n')                     //  get number of line which will be swapped up
                down_line++;
        }
    }
    else                                                //  cursor position is on bottom line of lines to swap up
    {
        down_line = text_cursor->blockNumber();
        up_line = down_line;

        for (int i = from; i < to; i++)                 //  find all newline characters inside cursor selection area
        {
            if (content[i] == '\n')                     //  get number of line which will be swapped up
                up_line--;
        }
    }

    if (up_line)                                        //  above lines to swap is at least one line
    {
        text_cursor->beginEditBlock();                  //  all operations with text will be only one undo history item during lines swap
        bool top_difference_value = editor[index].actual_difference[up_line - 1];   //  get difference value of line affected by swapping

        text_cursor->movePosition(QTextCursor::Start);  //  select line above swap lines
        text_cursor->movePosition(QTextCursor::Down, QTextCursor::MoveAnchor, up_line - 1);
        text_cursor->select(QTextCursor::LineUnderCursor);

        int remove_from = text_cursor->selectionStart();    //  save coordinates of line selection
        int remove_to = text_cursor->selectionEnd();

        QString line = "";

        for (int i = remove_from; i < remove_to; i++)   //  save selected string content
            line.push_back(content[i]);

        line.push_back('\n');

        text_cursor->movePosition(QTextCursor::Start);  //  move to beginning of line below swap lines
        text_cursor->movePosition(QTextCursor::Down, QTextCursor::MoveAnchor, down_line + 1);
        text_cursor->insertText(line);                  //  insert saved content of upper line
        editor[index].setTextCursor(* text_cursor);

        text_cursor->movePosition(QTextCursor::Start);  //  select line above swap lines again
        text_cursor->movePosition(QTextCursor::Down, QTextCursor::MoveAnchor, up_line - 1);
        text_cursor->select(QTextCursor::LineUnderCursor);
        text_cursor->removeSelectedText();              //  remove selected line
        text_cursor->deleteChar();
        editor[index].setTextCursor(* text_cursor);     //  apply all text changes to text editor

        text_cursor->setPosition(from - line.size());   //  select swapped lines with cursor selection
        text_cursor->setPosition(to - line.size(), QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        text_cursor->endEditBlock();                    //  undo history is successfully increased by one item
        editor[index].handle_swap_line_up(up_line - 1, down_line - up_line + 1, top_difference_value);  //  handle text differences using method
    }
}


/// Handle press of swap line down button
void Spade::swap_line_down_button_pressed()
{
    int index = active_tabs[files->currentIndex()].index_in_tabs;
    QString content = editor[index].document()->toPlainText();
    * text_cursor = editor[index].textCursor();         //  set pointer to text cursor of actual editor tab
    int position = text_cursor->position();
    int from = text_cursor->selectionStart();           //  set pointer to text cursor of actual editor tab
    int to = text_cursor->selectionEnd();
    int up_line;                                        //  holds top line of lines which will be swapped down
    int down_line;                                      //  holds bottom line of lines which will be swapped down

    if (position == from)                               //  cursor position is on top line of lines to swap down
    {
        up_line = text_cursor->blockNumber();
        down_line = up_line;

        for (int i = from; i < to; i++)                 //  find all newline characters inside cursor selection area
        {
            if (content[i] == '\n')                     //  get number of line which will be swapped down
                down_line++;
        }
    }
    else                                                //  cursor position is on bottom line of lines to swap down
    {
        down_line = text_cursor->blockNumber();
        up_line = down_line;

        for (int i = from; i < to; i++)                 //  find all newline characters inside cursor selection area
        {
            if (content[i] == '\n')                     //  get number of line which will be swapped down
                up_line--;
        }
    }

    if (down_line + 1 < editor[index].blockCount())     //  below lines to swap is at least one line
    {
        text_cursor->beginEditBlock();                  //  all operations with text will be only one undo history item during lines swap
        bool top_difference_value = editor[index].actual_difference[down_line + 1];     //  get difference value of line affected by swapping

        text_cursor->movePosition(QTextCursor::Start);  //  select line below swap lines
        text_cursor->movePosition(QTextCursor::Down, QTextCursor::MoveAnchor, down_line + 1);
        text_cursor->select(QTextCursor::LineUnderCursor);

        int remove_from = text_cursor->selectionStart();    //  save coordinates of line selection
        int remove_to = text_cursor->selectionEnd();

        QString line = "";

        for (int i = remove_from; i < remove_to; i++)   //  save selected string content
            line.push_back(content[i]);

        line.push_back('\n');

        text_cursor->movePosition(QTextCursor::Start);  //  move to beginning of line above swap lines
        text_cursor->movePosition(QTextCursor::Down, QTextCursor::MoveAnchor, up_line);
        text_cursor->insertText(line);                  //  insert saved content of upper line
        editor[index].setTextCursor(* text_cursor);

        text_cursor->movePosition(QTextCursor::Start);  //  select line below swap lines again
        text_cursor->movePosition(QTextCursor::Down, QTextCursor::MoveAnchor, down_line + 2);
        text_cursor->select(QTextCursor::LineUnderCursor);
        text_cursor->removeSelectedText();              //  remove selected line
        text_cursor->deleteChar();
        editor[index].setTextCursor(* text_cursor);     //  apply all text changes to text editor

        text_cursor->setPosition(from + line.size());   //  select swapped lines with cursor selection
        text_cursor->setPosition(to + line.size(), QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        text_cursor->endEditBlock();                    //  undo history is successfully increased by one item
        editor[index].handle_swap_line_down(up_line + 1, down_line - up_line + 1, top_difference_value);    //  handle text differences using method
    }
}


/// Handle press of upper case button
void Spade::upper_case_button_pressed()
{
    int index = files->currentIndex();                  //  get actual index of active tabs

    * text_cursor = editor[active_tabs[index].index_in_tabs].textCursor();
    QString selection = text_cursor->selectedText();

    if (selection.size())
        text_cursor->insertText(selection.toUpper());
    else
    {
        text_cursor->setPosition(text_cursor->position() + 1, QTextCursor::KeepAnchor);
        text_cursor->insertText(text_cursor->selectedText().toUpper());
    }

    editor[active_tabs[index].index_in_tabs].setTextCursor(* text_cursor);
}


/// Handle press of lower case button
void Spade::lower_case_button_pressed()
{
    int index = files->currentIndex();                  //  get actual index of active tabs

    * text_cursor = editor[active_tabs[index].index_in_tabs].textCursor();
    QString selection = text_cursor->selectedText();

    if (selection.size())
        text_cursor->insertText(selection.toLower());
    else
    {
        text_cursor->setPosition(text_cursor->position() + 1, QTextCursor::KeepAnchor);
        text_cursor->insertText(text_cursor->selectedText().toLower());
    }

    editor[active_tabs[index].index_in_tabs].setTextCursor(* text_cursor);
}


/// Handle press of swap case button
void Spade::swap_case_button_pressed()
{
    int index = files->currentIndex();                  //  get actual index of active tabs
    int from = editor[active_tabs[index].index_in_tabs].textCursor().selectionStart();  //  save coordinates of actual text cursor selection
    int to = editor[active_tabs[index].index_in_tabs].textCursor().selectionEnd();
    QString content = editor[active_tabs[index].index_in_tabs].document()->toPlainText();

    if (to != from)                                     //  at least one character was selected
    {
        if (from > to)
        {
            int temp = from;
            from = to;
            to = temp;
        }

        QString selected_text = "";

        for (int i = from; i < to; i++)                 //  push text in range of actual selection into temporary string and invert case
        {
            if (content[i].isUpper())
                selected_text.push_back(content[i].toLower());
            else if (content[i].isLower())
                selected_text.push_back(content[i].toUpper());
            else
                selected_text.push_back(content[i]);
        }

        editor[active_tabs[index].index_in_tabs].insertPlainText(selected_text);    //  insert new temporary string into text editor content
    }
}


/// Handle press of bold button
void Spade::bold_button_pressed()
{
    bold_flag = !bold_flag;                             //  invert bold font flag
    font.setBold(bold_flag);

    for (int i = 0; i <= max_index; i++)
    {
        font.setPointSize(editor[i].font().pointSize());
        editor[i].setFont(font);                        //  refresh bold font setting for all text editor tabs(non-used tabs too)
    }

    if (bold_flag)                                      //  toggle bold push button icon
        bold_button->setIcon(* bold_on_icon);
    else
        bold_button->setIcon(* bold_off_icon);
}


/// Handle press of italic button
void Spade::italic_button_pressed()
{
    italic_flag = !italic_flag;                         //  invert italic font flag
    font.setItalic(italic_flag);

    for (int i = 0; i <= max_index; i++)
    {
        font.setPointSize(editor[i].font().pointSize());
        editor[i].setFont(font);                        //  refresh italic font setting for all text editor tabs(non-used tabs too)
    }

    if (italic_flag)                                    //  toggle italic push button icon
        italic_button->setIcon(* italic_on_icon);
    else
        italic_button->setIcon(* italic_off_icon);
}


/// Handle press of Vim button
void Spade::vim_button_pressed()
{
    hide_actions_tray();                                //  hide actions tray
    show_vim_tray();                                    //  show vim tray

    actions_tray_visible = false;                       //  refresh values of appropriate flags
    vim_tray_visible = true;

    vim_edit->setText(editor[active_tabs[files->currentIndex()].index_in_tabs].file_path);
    vim_edit->insert("  ");
    vim_edit->insert(QString("%1").arg(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->blockCount()));
    vim_edit->insert("L, ");
    vim_edit->insert(QString("%1").arg(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText().size()));
    vim_edit->insert("C");
    slider_position_changed();
    editor[active_tabs[files->currentIndex()].index_in_tabs].vim_active = true;
    editor[active_tabs[files->currentIndex()].index_in_tabs].setOverwriteMode(true);

    * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
    text_cursor->clearSelection();      //  clear actual text cursor selection
    editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
}


/// Handle press of concept button
void Spade::concept_button_pressed()
{
    hide_actions_tray();                                //  hide actions tray
    show_language_tray();                               //  show language tray

    actions_tray_visible = false;                       //  refresh values of appropriate flags
    language_tray_visible = true;
}


/// Handle press of help button
void Spade::help_button_pressed()
{
    hide_actions_tray();                                //  hide actions tray

    help_flag = true;                                   //  set help flag
    ui->tabs->setCurrentIndex(max_tabs - 1);            //  move to help screen tab of text editor
}


/// Handle press of third back button
void Spade::back_button_3_pressed()
{
    hide_actions_tray();                                //  hide actions tray
    show_tray();                                        //  show main tray

    actions_tray_visible = false;                       //  refresh values of appropriate flags
    tray_visible = true;
}


/// Handle press of find previous button
void Spade::find_previous_button_pressed()
{
    if (find_line_edit->text().size())                  //  file line edit content cannot be empty
    {                                                   //  set file line edit content as find pattern of regular expression
        QString find_pattern = find_line_edit->text();  //  get content of find line edit

        if (regex_flag == false)
            find_pattern = QRegularExpression::escape(find_pattern);    //  escape search string if searching by regular expression is disabled

        if (boundary_flag)
            find_pattern = "\\b" + find_pattern + "\\b";    //  find whole word if boundary flag is active

        QRegularExpression expr(find_pattern);
                                                        //  allow multiline match for regular expression
        if (case_flag)                                  //  toggle case sensitive matching
            expr.setPatternOptions(QRegularExpression::DotMatchesEverythingOption | QRegularExpression::CaseInsensitiveOption);
        else
            expr.setPatternOptions(QRegularExpression::DotMatchesEverythingOption);

        expr.optimize();

        if (expr.isValid())                             //  check if regular expression is valid
        {
            vector<int> from_array;                     //  array with starting positions of all regular expression matches
            vector<int> to_array;                       //  array with ending positions of all regular expression matches

            QRegularExpressionMatchIterator iter = expr.globalMatch(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText());
                                                        //  check for global match of regular expression and save result into match iterator
            while (iter.hasNext())                      //  iterate through all matches
            {
                QRegularExpressionMatch match = iter.next();

                if (match.hasMatch())                   //  regular expression match found
                {
                    from_array.push_back(match.capturedStart(0));   //  push coordinates of match into appropriate arrays
                    to_array.push_back(match.capturedEnd(0));
                }
            }

            int N = from_array.size();                  //  get number of regular expression matches

            if (N)                                      //  at least one match must be present
            {                                           //  get actual text cursor position
                int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();

                if (N == 1)                             //  just highlight one and only match by text cursor selection
                {
                    * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                    text_cursor->setPosition(from_array[0]);
                    text_cursor->setPosition(to_array[0], QTextCursor::KeepAnchor);
                    editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                    return;                             //  stop searching
                }

                bool found = false;                     //  holds if appropriate match was selected

                for (int i = 0; i < N; i++)             //  iterate again through all matches
                {
                    if (from_array[i] <= actual && actual <= to_array[i])   //  cursor position is at location of actual match
                    {
                        if (i)                          //  actual match is not first in file content
                        {
                            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                            text_cursor->setPosition(from_array[i - 1]);    //  highlight previous match by text cursor selection
                            text_cursor->setPosition(to_array[i - 1], QTextCursor::KeepAnchor);
                            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                        }
                        else                            //  actual match is first in file content
                        {
                            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                            text_cursor->setPosition(from_array[N - 1]);    //  highlight last match of file content by text cursor selection
                            text_cursor->setPosition(to_array[N - 1], QTextCursor::KeepAnchor);
                            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                        }

                        found = true;
                        break;                          //  stop searching
                    }
                    else if (actual < from_array[i])    //  cursor position is before location of actual match
                    {
                        if (i)                          //  actual match is not first in file content
                        {
                            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                            text_cursor->setPosition(from_array[i - 1]);    //  highlight previous match by text cursor selection
                            text_cursor->setPosition(to_array[i - 1], QTextCursor::KeepAnchor);
                            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                        }
                        else                            //  actual match is first in file content
                        {
                            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                            text_cursor->setPosition(from_array[N - 1]);    //  highlight last match of file content by text cursor selection
                            text_cursor->setPosition(to_array[N - 1], QTextCursor::KeepAnchor);
                            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                        }

                        found = true;
                        break;                          //  stop searching
                    }
                }

                if (found == false)
                {                                       //  select last match if flag is not set
                    * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                    text_cursor->setPosition(from_array[N - 1]);    //  highlight last match of file content by text cursor selection
                    text_cursor->setPosition(to_array[N - 1], QTextCursor::KeepAnchor);
                    editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                }

                editor[active_tabs[files->currentIndex()].index_in_tabs].setFocus();    //  set focus to text editor
            }
        }
    }
}


/// Handle press of find next button
void Spade::find_next_button_pressed()
{
    if (find_line_edit->text().size())                  //  file line edit content cannot be empty
    {                                                   //  set file line edit content as find pattern of regular expression
        QString find_pattern = find_line_edit->text();  //  get content of find line edit

        if (regex_flag == false)
            find_pattern = QRegularExpression::escape(find_pattern);    //  escape search string if searching by regular expression is disabled

        if (boundary_flag)
            find_pattern = "\\b" + find_pattern + "\\b";    //  find whole word if boundary flag is active

        QRegularExpression expr(find_pattern);
                                                        //  allow multiline match for regular expression
        if (case_flag)                                  //  toggle case sensitive matching
            expr.setPatternOptions(QRegularExpression::DotMatchesEverythingOption | QRegularExpression::CaseInsensitiveOption);
        else
            expr.setPatternOptions(QRegularExpression::DotMatchesEverythingOption);

        expr.optimize();

        if (expr.isValid())                             //  check if regular expression is valid
        {
            vector<int> from_array;                     //  array with starting positions of all regular expression matches
            vector<int> to_array;                       //  array with ending positions of all regular expression matches

            QRegularExpressionMatchIterator iter = expr.globalMatch(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText());
                                                        //  check for global match of regular expression and save result into match iterator
            while (iter.hasNext())                      //  iterate through all matches
            {
                QRegularExpressionMatch match = iter.next();

                if (match.hasMatch())                   //  regular expression match found
                {
                    from_array.push_back(match.capturedStart(0));   //  push coordinates of match into appropriate arrays
                    to_array.push_back(match.capturedEnd(0));
                }
            }

            int N = from_array.size();                  //  get number of regular expression matches

            if (N)                                      //  at least one match must be present
            {                                           //  get actual text cursor position
                int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();

                if (N == 1)                             //  just highlight one and only match by text cursor selection
                {
                    * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                    text_cursor->setPosition(from_array[0]);
                    text_cursor->setPosition(to_array[0], QTextCursor::KeepAnchor);
                    editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                    return;                             //  stop searching
                }

                bool found = false;                     //  holds if appropriate match was selected

                for (int i = 0; i < N; i++)             //  iterate again through all matches
                {
                    if (from_array[i] <= actual && actual <= to_array[i])   //  cursor position is at location of actual match
                    {
                        if (i == N - 1)                 //  actual match is last in file content
                        {
                            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                            text_cursor->setPosition(from_array[0]);    //  highlight first match of file content by text cursor selection
                            text_cursor->setPosition(to_array[0], QTextCursor::KeepAnchor);
                            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                        }
                        else                            //  actual match is not last in file content
                        {
                            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                            text_cursor->setPosition(from_array[i + 1]);    //  highlight next match by text cursor selection
                            text_cursor->setPosition(to_array[i + 1], QTextCursor::KeepAnchor);
                            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                        }

                        found = true;
                        break;                          //  stop searching
                    }
                    else if (actual < from_array[i])    //  cursor position is before location of actual match
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->setPosition(from_array[i]);    //  highlight actual match by text cursor selection
                        text_cursor->setPosition(to_array[i], QTextCursor::KeepAnchor);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                        found = true;
                        break;                          //  stop searching
                    }
                }

                if (found == false)
                {                                       //  select first match if flag is not set
                    * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                    text_cursor->setPosition(from_array[0]);    //  highlight first match of file content by text cursor selection
                    text_cursor->setPosition(to_array[0], QTextCursor::KeepAnchor);
                    editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                }

                editor[active_tabs[files->currentIndex()].index_in_tabs].setFocus();    //  set focus to text editor
            }
        }
    }
}


/// Handle press of replace button
void Spade::replace_button_pressed()
{
    if (find_line_edit->text().size())                  //  file line edit content cannot be empty
    {                                                   //  set file line edit content as find pattern of regular expression
        QRegularExpression expr(find_line_edit->text(), QRegularExpression::DotMatchesEverythingOption);    //  allow multiline match for regular expression
        expr.optimize();

        if (expr.isValid())                             //  check if regular expression is valid
        {
            vector<int> from_array;                     //  array with starting positions of all regular expression matches
            vector<int> to_array;                       //  array with ending positions of all regular expression matches

            QRegularExpressionMatchIterator iter = expr.globalMatch(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText());
                                                        //  check for global match of regular expression and save result into match iterator
            while (iter.hasNext())                      //  iterate through all matches
            {
                QRegularExpressionMatch match = iter.next();

                if (match.hasMatch())                   //  regular expression match found
                {
                    from_array.push_back(match.capturedStart(0));   //  push coordinates of match into appropriate arrays
                    to_array.push_back(match.capturedEnd(0));
                }
            }

            int N = from_array.size();                  //  get number of regular expression matches

            if (N)                                      //  at least one match must be present
            {                                           //  get actual text cursor position
                int from = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().selectionStart();
                int to = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().selectionEnd();
                                                        //  get actual text cursor selection coordinates
                for (int i = 0; i < N; i++)             //  check if text cursor selection really contains one of pattern matches
                {
                    if (from_array[i] == from && to_array[i] == to)
                    {                                   //  replace matched pattern with content if replace line edit
                        editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText(replace_line_edit->text());
                        break;
                    }
                }

                editor[active_tabs[files->currentIndex()].index_in_tabs].setFocus();    //  set focus to text editor
            }
        }
    }
}


/// Handle press of replace all button
void Spade::replace_all_button_pressed()
{
    if (find_line_edit->text().size())                  //  file line edit content cannot be empty
    {                                                   //  set file line edit content as find pattern of regular expression
        QRegularExpression expr(find_line_edit->text(), QRegularExpression::DotMatchesEverythingOption);    //  allow multiline match for regular expression
        expr.optimize();

        if (expr.isValid())                             //  check if regular expression is valid
        {
            vector<int> from_array;                     //  array with starting positions of all regular expression matches
            vector<int> to_array;                       //  array with ending positions of all regular expression matches

            QRegularExpressionMatchIterator iter = expr.globalMatch(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText());
                                                        //  check for global match of regular expression and save result into match iterator
            while (iter.hasNext())                      //  iterate through all matches
            {
                QRegularExpressionMatch match = iter.next();

                if (match.hasMatch())                   //  regular expression match found
                {
                    from_array.push_back(match.capturedStart(0));   //  push coordinates of match into appropriate arrays
                    to_array.push_back(match.capturedEnd(0));
                }
            }

            int N = from_array.size();                  //  get number of regular expression matches

            if (N)                                      //  at least one match must be present
            {                                           //  get actual text cursor position
                QString replace_text = replace_line_edit->text();   //  save replace line edit content into string variable

                for (int i = N - 1; i >= 0; i--)        //  iterate through all matches from bottom of file content
                {                                       //  mark actual match with text cursor selection
                    * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                    text_cursor->setPosition(from_array[i]);
                    text_cursor->setPosition(to_array[i], QTextCursor::KeepAnchor);
                    editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                                        //  insert replace text into actual selection location
                    editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText(replace_text);
                }

                editor[active_tabs[files->currentIndex()].index_in_tabs].setFocus();    //  set focus to text editor
            }
        }
    }
}


/// Handle press of regex button
void Spade::regex_button_pressed()
{
    regex_flag = !regex_flag;                           //  invert regex flag

    if (regex_flag)                                     //  toggle regex push button icon
        regex_button->setIcon(* regex_icon);
    else
        regex_button->setIcon(* text_icon);
}


/// Handle press of case button
void Spade::case_button_pressed()
{
    case_flag = !case_flag;                             //  invert case flag

    if (case_flag)                                      //  toggle case push button icon
        case_button->setIcon(* swap_icon);
    else
        case_button->setIcon(* upper_icon);
}


/// Handle press of boundary button
void Spade::boundary_button_pressed()
{
    boundary_flag = !boundary_flag;                     //  invert boundary flag

    if (boundary_flag)                                  //  toggle boundary push button icon
        boundary_button->setIcon(* boundary_on_icon);
    else
        boundary_button->setIcon(* boundary_off_icon);
}


/// Handle press of fourth back button
void Spade::back_button_4_pressed()
{
    hide_find_tray();                                   //  hide find tray
    show_tray();                                        //  show main tray

    find_tray_visible = false;                          //  refresh values of appropriate flags
    tray_visible = true;
}


/// Handle press of first template button
void Spade::template_style_button_1_pressed()
{
    int actual = files->currentIndex();                 //  get actual index of files combo box
    int index = active_tabs[actual].index_in_tabs;

    if (active_tabs[actual].language == c99)            //  document in actual tab of text editor is C99
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += QString("if (variable == %1)").arg(count);
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tcondition is true\n" + offset + "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 5;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 8, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == cplusplus)     //  document in actual tab of text editor is C++
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += QString("if (variable == %1)").arg(count);
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tcondition is true\n" + offset + "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 5;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 8, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == java)      //  document in actual tab of text editor is Java
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += QString("if (variable == %1)").arg(count);
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tcondition is true\n" + offset + "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 5;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 8, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == php)       //  document in actual tab of text editor is PHP
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += QString("if ($variable == %1)").arg(count);
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tcondition is true\n" + offset + "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 6;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 8, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == plain_text)    //  document in actual tab of text editor is plain text
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";                         //  load string with template which will be inserted into text
        int count = template_count->currentIndex() + 1;

        for (int j = 1; j <= count; j++)
        {
            QString bullet = QString("%1 ").arg(j);
            numbering = numbering + "\n" + offset + bullet + "\t";
        }

        numbering += "\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab

        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 4;
                                                        //  set cursor position to desired place in template string
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else                                                //  document in actual tab of text editor is Python
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += QString("if (variable == %1):").arg(count);
        numbering += "\n";
        numbering = numbering + offset + "\tprint(\"condition is true\")\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 5;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 8, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }

    editor[index].setFocus();                           //  set focus to text editor
}


/// Handle press of second template button
void Spade::template_style_button_2_pressed()
{
    int actual = files->currentIndex();                 //  get actual index of files combo box
    int index = active_tabs[actual].index_in_tabs;

    if (active_tabs[actual].language == c99)            //  document in actual tab of text editor is C99
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += QString("if (variable == %1)").arg(count);
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tfirst condition is true\n" + offset + "}\n";
        numbering += offset;
        numbering += QString("else if (variable < %1)").arg(count);
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tsecond condition is true\n" + offset + "}\n";
        numbering += offset;
        numbering += "else\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tboth conditions are false\n" + offset + "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 5;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 8, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == cplusplus)      //  document in actual tab of text editor is C++
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += QString("if (variable == %1)").arg(count);
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tfirst condition is true\n" + offset + "}\n";
        numbering += offset;
        numbering += QString("else if (variable < %1)").arg(count);
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tsecond condition is true\n" + offset + "}\n";
        numbering += offset;
        numbering += "else\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tboth conditions are false\n" + offset + "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 5;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 8, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == java)      //  document in actual tab of text editor is Java
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += QString("if (variable == %1)").arg(count);
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tfirst condition is true\n" + offset + "}\n";
        numbering += offset;
        numbering += QString("else if (variable < %1)").arg(count);
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tsecond condition is true\n" + offset + "}\n";
        numbering += offset;
        numbering += "else\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tboth conditions are false\n" + offset + "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 5;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 8, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == php)       //  document in actual tab of text editor is PHP
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += QString("if ($variable == %1)").arg(count);
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tfirst condition is true\n" + offset + "}\n";
        numbering += offset;
        numbering += QString("else if ($variable < %1)").arg(count);
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tsecond condition is true\n" + offset + "}\n";
        numbering += offset;
        numbering += "else\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tboth conditions are false\n" + offset + "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 6;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 8, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == plain_text)    //  document in actual tab of text editor is plain text
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";                         //  load string with template which will be inserted into text
        int count = template_count->currentIndex() + 1;

        for (int j = 1; j <= count; j++)
        {
            QString bullet = bullet = QString("%1.").arg(j);
            numbering = numbering + "\n" + offset + bullet + "\t";
        }

        numbering += "\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab

        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 4;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else                                                //  document in actual tab of text editor is Python
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += QString("if (variable == %1):").arg(count);
        numbering += "\n";
        numbering = numbering + offset + "\tprint(\"first condition is true\")\n";
        numbering += offset;
        numbering += QString("elif (variable < %1):").arg(count);
        numbering += "\n";
        numbering = numbering + offset + "\tprint(\"second condition is true\")\n";
        numbering += offset;
        numbering += "else:";
        numbering += "\n";
        numbering = numbering + offset + "\tprint(\"both conditions are false\")\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 5;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 8, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }

    editor[index].setFocus();                           //  set focus to text editor
}


/// Handle press of third template button
void Spade::template_style_button_3_pressed()
{
    int actual = files->currentIndex();                 //  get actual index of files combo box
    int index = active_tabs[actual].index_in_tabs;

    if (active_tabs[actual].language == c99)            //  document in actual tab of text editor is C99
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "switch (variable)";
        numbering += "\n";
        numbering += offset;
        numbering += "{";

        int count = template_count->currentIndex() + 1;

        for (int j = 1; j <= count; j++)
        {
            QString bullet = "";

            if (j == count)
                bullet = "default:";
            else
                bullet = QString("case %1:").arg(j - 1);

            numbering = numbering + "\n" + offset + "\t" + bullet;
            numbering = numbering + "\n" + offset + "\t\t" + "//\tyour code";
            numbering = numbering + "\n" + offset + "\t\t" + "break;\n";
        }

        numbering += offset;
        numbering += "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 9;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 8, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == cplusplus)      //  document in actual tab of text editor is C++
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "switch (variable)";
        numbering += "\n";
        numbering += offset;
        numbering += "{";

        int count = template_count->currentIndex() + 1;

        for (int j = 1; j <= count; j++)
        {
            QString bullet = "";

            if (j == count)
                bullet = "default:";
            else
                bullet = QString("case %1:").arg(j - 1);

            numbering = numbering + "\n" + offset + "\t" + bullet;
            numbering = numbering + "\n" + offset + "\t\t" + "//\tyour code";
            numbering = numbering + "\n" + offset + "\t\t" + "break;\n";
        }

        numbering += offset;
        numbering += "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 9;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 8, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == java)      //  document in actual tab of text editor is Java
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "switch (variable)";
        numbering += "\n";
        numbering += offset;
        numbering += "{";

        int count = template_count->currentIndex() + 1;

        for (int j = 1; j <= count; j++)
        {
            QString bullet = "";

            if (j == count)
                bullet = "default:";
            else
                bullet = QString("case %1:").arg(j - 1);

            numbering = numbering + "\n" + offset + "\t" + bullet;
            numbering = numbering + "\n" + offset + "\t\t" + "//\tyour code";
            numbering = numbering + "\n" + offset + "\t\t" + "break;\n";
        }

        numbering += offset;
        numbering += "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 9;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 8, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == php)       //  document in actual tab of text editor is PHP
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "switch ($variable)";
        numbering += "\n";
        numbering += offset;
        numbering += "{";

        int count = template_count->currentIndex() + 1;

        for (int j = 1; j <= count; j++)
        {
            QString bullet = "";

            if (j == count)
                bullet = "default:";
            else
                bullet = QString("case %1:").arg(j - 1);

            numbering = numbering + "\n" + offset + "\t" + bullet;
            numbering = numbering + "\n" + offset + "\t\t" + "//\tyour code";
            numbering = numbering + "\n" + offset + "\t\t" + "break;\n";
        }

        numbering += offset;
        numbering += "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 10;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 8, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == plain_text)    //  document in actual tab of text editor is plain text
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";                         //  load string with template which will be inserted into text
        int count = template_count->currentIndex() + 1;

        for (int j = 1; j <= count; j++)
        {
            QString bullet = bullet = QString("%1)").arg(j);
            numbering = numbering + "\n" + offset + bullet + "\t";
        }

        numbering += "\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab

        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 4;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else                                                //  document in actual tab of text editor is Python
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "\n";                       //  load string with template which will be inserted into text
        numbering = numbering + offset + "options = { ";

        for (int i = 0; i < count; i++)
        {
            char ch = 'a';
            ch += i;

            if (i)
                numbering += ", ";

            numbering += QString("'%1': %2").arg(ch).arg(i + 1);
        }

        numbering += " }\n";
        numbering = numbering + offset + "result = options.get('a', 'default')\n";
        numbering = numbering + offset + "print(result)\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 1;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 7, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }

    editor[index].setFocus();                           //  set focus to text editor
}


/// Handle press of fourth templatebutton
void Spade::template_style_button_4_pressed()
{
    int actual = files->currentIndex();                 //  get actual index of files combo box
    int index = active_tabs[actual].index_in_tabs;

    if (active_tabs[actual].language == c99)            //  document in actual tab of text editor is C99
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += QString("for (int i = 0; i < %1; i++)").arg(count);
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tyour code\n" + offset + "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 14;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 1, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == cplusplus)      //  document in actual tab of text editor is C++
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += QString("for (int i = 0; i < %1; i++)").arg(count);
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tyour code\n" + offset + "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 14;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 1, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == java)      //  document in actual tab of text editor is Java
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += QString("for (int i = 0; i < %1; i++)").arg(count);
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tyour code\n" + offset + "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 14;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 1, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == php)       //  document in actual tab of text editor is PHP
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += QString("for ($i = 0; $i < %1; $i++)").arg(count);
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tyour code\n" + offset + "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 15;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 1, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == plain_text)    //  document in actual tab of text editor is plain text
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";                         //  load string with template which will be inserted into text
        int count = template_count->currentIndex() + 1;

        for (int j = 1; j <= count; j++)
        {
            QString bullet = "";
            char ch = 'a';
            ch += j - 1;
            bullet = QString("%1 ").arg(ch);
            numbering = numbering + "\n" + offset + bullet + "\t";
        }

        numbering += "\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab

        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 4;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else                                                //  document in actual tab of text editor is Python
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += QString("for i in range(0, %1):").arg(count);
        numbering += "\n";
        numbering = numbering + offset + "\tprint(i)\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 16;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 1, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }

    editor[index].setFocus();                           //  set focus to text editor
}


/// Handle press of fifth templatebutton
void Spade::template_style_button_5_pressed()
{
    int actual = files->currentIndex();                 //  get actual index of files combo box
    int index = active_tabs[actual].index_in_tabs;

    if (active_tabs[actual].language == c99)            //  document in actual tab of text editor is C99
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "int i = 0;\n";
        numbering += offset;
        numbering += "\n";
        numbering += offset;
        numbering += QString("while (i < %1)").arg(count);
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\ti++;\n" + offset + "\t//\tyour code\n" + offset + "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 9;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 1, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == cplusplus)      //  document in actual tab of text editor is C++
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "int i = 0;\n";
        numbering += offset;
        numbering += "\n";
        numbering += offset;
        numbering += QString("while (i < %1)").arg(count);
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\ti++;\n" + offset + "\t//\tyour code\n" + offset + "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 9;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 1, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == java)      //  document in actual tab of text editor is Java
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "int i = 0;\n";
        numbering += offset;
        numbering += "\n";
        numbering += offset;
        numbering += QString("while (i < %1)").arg(count);
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\ti++;\n" + offset + "\t//\tyour code\n" + offset + "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 9;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 1, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == php)       //  document in actual tab of text editor is PHP
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "$i = 0;\n";
        numbering += offset;
        numbering += "\n";
        numbering += offset;
        numbering += QString("while ($i < %1)").arg(count);
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t$i++;\n" + offset + "\t//\tyour code\n" + offset + "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 6;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 1, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == plain_text)    //  document in actual tab of text editor is plain text
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";                         //  load string with template which will be inserted into text
        int count = template_count->currentIndex() + 1;

        for (int j = 1; j <= count; j++)
        {
            QString bullet = "";
            char ch = 'a';
            ch += j - 1;
            bullet = QString("%1)").arg(ch);
            numbering = numbering + "\n" + offset + bullet + "\t";
        }

        numbering += "\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab

        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 4;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else                                                //  document in actual tab of text editor is Python
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "i = 0\n";
        numbering += offset;
        numbering += "\n";
        numbering += offset;
        numbering += QString("while (i < %1):").arg(count);
        numbering += "\n";
        numbering = numbering + offset + "\ti += 1\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 5;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 1, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }

    editor[index].setFocus();                           //  set focus to text editor
}


/// Handle press of sixth template button
void Spade::template_style_button_6_pressed()
{
    int actual = files->currentIndex();                 //  get actual index of files combo box
    int index = active_tabs[actual].index_in_tabs;

    if (active_tabs[actual].language == c99)            //  document in actual tab of text editor is C99
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "int i = 0;\n";
        numbering += offset;
        numbering += "\n";
        numbering += offset;
        numbering += "do\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\ti++;\n" + offset + "\t//\tyour code\n" + offset + QString("}while (i < %1);\n").arg(count);

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 9;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 1, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == cplusplus)      //  document in actual tab of text editor is C++
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "int i = 0;\n";
        numbering += offset;
        numbering += "\n";
        numbering += offset;
        numbering += "do\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\ti++;\n" + offset + "\t//\tyour code\n" + offset + QString("}while (i < %1);\n").arg(count);

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 9;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 1, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == java)      //  document in actual tab of text editor is Java
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "int i = 0;\n";
        numbering += offset;
        numbering += "\n";
        numbering += offset;
        numbering += "do\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\ti++;\n" + offset + "\t//\tyour code\n" + offset + QString("}while (i < %1);\n").arg(count);

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 9;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 1, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == php)       //  document in actual tab of text editor is PHP
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "$i = 0;\n";
        numbering += offset;
        numbering += "\n";
        numbering += offset;
        numbering += "do\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t$i++;\n" + offset + "\t//\tyour code\n" + offset + QString("}while ($i < %1);\n").arg(count);

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 6;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 1, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == plain_text)    //  document in actual tab of text editor is plain text
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";                         //  load string with template which will be inserted into text
        int count = template_count->currentIndex() + 1;

        for (int j = 1; j <= count; j++)
        {
            QString bullet = "";
            char ch = 'A';
            ch += j - 1;
            bullet = QString("%1 ").arg(ch);
            numbering = numbering + "\n" + offset + bullet + "\t";
        }

        numbering += "\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab

        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 4;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else                                                //  document in actual tab of text editor is Python
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += QString("def my_function(number = %1):").arg(count);
        numbering += "\n";
        numbering = numbering + offset + "\treturn number\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 5;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 11, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }

    editor[index].setFocus();                           //  set focus to text editor
}


/// Handle press of seventh template button
void Spade::template_style_button_7_pressed()
{
    int actual = files->currentIndex();                 //  get actual index of files combo box
    int index = active_tabs[actual].index_in_tabs;

    if (active_tabs[actual].language == c99)            //  document in actual tab of text editor is C99
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "int my_function(int)";
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tyour code\n" + offset + QString("\treturn %1;\n").arg(count) + offset + "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 5;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 11, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == cplusplus)      //  document in actual tab of text editor is C++
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "int My_class::my_method(int)";
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tyour code\n" + offset + QString("\treturn %1;\n").arg(count) + offset + "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 15;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 9, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == java)      //  document in actual tab of text editor is Java
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "public int my_method(int)";
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tyour code\n" + offset + QString("\treturn %1;\n").arg(count) + offset + "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 12;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 9, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == php)       //  document in actual tab of text editor is PHP
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "public function my_function($number)";
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\t//\tyour code\n" + offset + QString("\treturn %1;\n").arg(count) + offset + "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 17;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 11, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == plain_text)    //  document in actual tab of text editor is plain text
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";                         //  load string with template which will be inserted into text
        int count = template_count->currentIndex() + 1;

        for (int j = 1; j <= count; j++)
        {
            QString bullet = "";
            char ch = 'A';
            ch += j - 1;
            bullet = QString("%1)").arg(ch);
            numbering = numbering + "\n" + offset + bullet + "\t";
        }

        numbering += "\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab

        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 4;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else                                                //  document in actual tab of text editor is Python
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        int count = template_count->currentIndex() + 1;

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += QString("def my_method(self, number = %1):").arg(count);
        numbering += "\n";
        numbering = numbering + offset + "\treturn number\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 5;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 9, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }

    editor[index].setFocus();                           //  set focus to text editor
}


/// Handle press of eighth template button
void Spade::template_style_button_8_pressed()
{
    int actual = files->currentIndex();                 //  get actual index of files combo box
    int index = active_tabs[actual].index_in_tabs;

    if (active_tabs[actual].language == c99)            //  document in actual tab of text editor is C99
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "struct My_struct";
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\tbool my_flag;\n";
        numbering = numbering + offset + "\tint my_integer;\n";
        numbering = numbering + offset + "\tdouble my_float;\n";
        numbering += offset;
        numbering += "};\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 8;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 9, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == cplusplus)      //  document in actual tab of text editor is C++
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "class My_class : public Parent";
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "private:\n";
        numbering = numbering + offset + "\tbool my_flag;\n";
        numbering = numbering + offset + "\tint my_integer;\n";
        numbering = numbering + offset + "\tdouble my_float;\n";
        numbering = numbering + offset + "protected:\n";
        numbering = numbering + offset + "\tvoid show_information();\n";
        numbering = numbering + offset + "public:\n";
        numbering = numbering + offset + "\tMy_class();\n";
        numbering = numbering + offset + "\tint my_method(int);\n";
        numbering = numbering + offset + "\tvirtual ~My_class();\n";
        numbering += offset;
        numbering += "};\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 7;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 8, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == java)      //  document in actual tab of text editor is Java
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "public class My_class extends Parent";
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\tprivate boolean my_flag;\n";
        numbering = numbering + offset + "\tprivate int my_integer;\n";
        numbering = numbering + offset + "\tprivate double my_float;\n";
        numbering = numbering + offset + "\n\tprotected void show_information()\n\t{\n\t\t//\tpass\n\t}\n";
        numbering = numbering + offset + "\n\tpublic My_class()\n\t{\n\t\t//\tpass\n\t}\n";
        numbering = numbering + offset + "\n\tpublic int my_method(int)\n\t{\n\t\t//\tpass\n\t}\n";
        numbering += offset;
        numbering += "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 14;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 8, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == php)       //  document in actual tab of text editor is PHP
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "class My_class extends Parent";
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\tprivate $my_flag;\n";
        numbering = numbering + offset + "\tprivate $my_integer;\n";
        numbering = numbering + offset + "\tprivate $my_float;\n";
        numbering = numbering + offset + "\n\tprotected function show_information()\n\t{\n\t\t//\tpass\n\t}\n";
        numbering = numbering + offset + "\n\tpublic My_class()\n\t{\n\t\t//\tpass\n\t}\n";
        numbering = numbering + offset + "\n\tpublic function my_method($number)\n\t{\n\t\t//\tpass\n\t}\n";
        numbering += offset;
        numbering += "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 7;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 8, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == plain_text)    //  document in actual tab of text editor is plain text
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";                         //  load string with template which will be inserted into text
        int count = template_count->currentIndex() + 1;

        for (int j = 1; j <= count; j++)
        {
            QString bullet = "";
            bullet = QString("- ");
            numbering = numbering + "\n" + offset + bullet + "\t";
        }

        numbering += "\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab

        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 4;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else                                                //  document in actual tab of text editor is Python
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "class My_class(Parent):";
        numbering += "\n";
        numbering = numbering + offset + "\tdef __init__(self, my_flag, my_integer, my_float, my_string):\n";
        numbering = numbering + offset + "\t\tself.__my_flag = my_flag\n";
        numbering = numbering + offset + "\t\tself.__my_integer = my_integer\n";
        numbering = numbering + offset + "\t\tself.__my_float = my_float\n";
        numbering = numbering + offset + "\t\tself._my_string = my_string\n";
        numbering = numbering + offset + "\t\n";
        numbering = numbering + offset + "\tdef get_information(self):\n";
        numbering = numbering + offset + "\t\treturn self._my_string\n";
        numbering = numbering + offset + "\t\n";
        numbering = numbering + offset + "\tdef my_method(self, my_integer):\n";
        numbering = numbering + offset + "\t\tself.__my_integer = my_integer\n";
        numbering = numbering + offset + "\t\treturn self.__my_integer\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 7;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 8, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }

    editor[index].setFocus();                           //  set focus to text editor
}


/// Handle press of ninth template button
void Spade::template_style_button_9_pressed()
{
    int actual = files->currentIndex();                 //  get actual index of files combo box
    int index = active_tabs[actual].index_in_tabs;

    if (active_tabs[actual].language == c99)            //  document in actual tab of text editor is C99
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "union My_union";
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\tbool my_flag;\n";
        numbering = numbering + offset + "\tint my_integer;\n";
        numbering = numbering + offset + "\tdouble my_float;\n";
        numbering += offset;
        numbering += "};\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 7;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 8, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == cplusplus)      //  document in actual tab of text editor is C++
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";                         //  load string with template which will be inserted into text

        numbering += "\n";
        numbering += offset;
        numbering += "class Parent";
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "private:\n";
        numbering = numbering + offset + "\tbool my_flag;\n";
        numbering = numbering + offset + "\tint my_integer;\n";
        numbering = numbering + offset + "\tdouble my_float;\n";
        numbering = numbering + offset + "protected:\n";
        numbering = numbering + offset + "\tvirtual void show_information();\n";
        numbering = numbering + offset + "public:\n";
        numbering = numbering + offset + "\tParent();\n";
        numbering = numbering + offset + "\tint my_method(int);\n";
        numbering = numbering + offset + "\tvirtual ~Parent();\n";
        numbering += offset;
        numbering += "};\n";

        numbering += "\n";
        numbering += offset;
        numbering += "class Child : public Parent";
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "private:\n";
        numbering = numbering + offset + "\tbool my_flag;\n";
        numbering = numbering + offset + "\tint my_integer;\n";
        numbering = numbering + offset + "\tdouble my_float;\n";
        numbering = numbering + offset + "protected:\n";
        numbering = numbering + offset + "\tvoid show_information();\n";
        numbering = numbering + offset + "public:\n";
        numbering = numbering + offset + "\tChild();\n";
        numbering = numbering + offset + "\tint my_method(int);\n";
        numbering = numbering + offset + "\t~Child();\n";
        numbering += offset;
        numbering += "};\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 7;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 6, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == java)      //  document in actual tab of text editor is Java
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";                         //  load string with template which will be inserted into text

        numbering += "\n";
        numbering += offset;
        numbering += "public class Parent";
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\tprivate boolean my_flag;\n";
        numbering = numbering + offset + "\tprivate int my_integer;\n";
        numbering = numbering + offset + "\tprivate double my_float;\n";
        numbering = numbering + offset + "\n\tprotected void show_information()\n\t{\n\t\t//\tpass\n\t}\n";
        numbering = numbering + offset + "\n\tpublic Parent()\n\t{\n\t\t//\tpass\n\t}\n";
        numbering = numbering + offset + "\n\tpublic int my_method(int)\n\t{\n\t\t//\tpass\n\t}\n";
        numbering += offset;
        numbering += "}\n";

        numbering += "\n";
        numbering += offset;
        numbering += "public class Child extends Parent";
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\tprivate boolean my_flag;\n";
        numbering = numbering + offset + "\tprivate int my_integer;\n";
        numbering = numbering + offset + "\tprivate double my_float;\n";
        numbering = numbering + offset + "\n\tprotected void show_information()\n\t{\n\t\t//\tpass\n\t}\n";
        numbering = numbering + offset + "\n\tpublic Child()\n\t{\n\t\t//\tpass\n\t}\n";
        numbering = numbering + offset + "\n\tpublic int my_method(int)\n\t{\n\t\t//\tpass\n\t}\n";
        numbering += offset;
        numbering += "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 14;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 6, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == php)       //  document in actual tab of text editor is PHP
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";                         //  load string with template which will be inserted into text

        numbering += "\n";
        numbering += offset;
        numbering += "class Parent";
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\tprivate $my_flag;\n";
        numbering = numbering + offset + "\tprivate $my_integer;\n";
        numbering = numbering + offset + "\tprivate $my_float;\n";
        numbering = numbering + offset + "\n\tprotected function show_information()\n\t{\n\t\t//\tpass\n\t}\n";
        numbering = numbering + offset + "\n\tpublic Parent()\n\t{\n\t\t//\tpass\n\t}\n";
        numbering = numbering + offset + "\n\tpublic function my_method($number)\n\t{\n\t\t//\tpass\n\t}\n";
        numbering += offset;
        numbering += "}\n";

        numbering += "\n";
        numbering += offset;
        numbering += "class Child extends Parent";
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\tprivate $my_flag;\n";
        numbering = numbering + offset + "\tprivate $my_integer;\n";
        numbering = numbering + offset + "\tprivate $my_float;\n";
        numbering = numbering + offset + "\n\tprotected function show_information()\n\t{\n\t\t//\tpass\n\t}\n";
        numbering = numbering + offset + "\n\tpublic Child()\n\t{\n\t\t//\tpass\n\t}\n";
        numbering = numbering + offset + "\n\tpublic function my_method($number)\n\t{\n\t\t//\tpass\n\t}\n";
        numbering += offset;
        numbering += "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 7;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 6, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == plain_text)    //  document in actual tab of text editor is plain text
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";                         //  load string with template which will be inserted into text
        int count = template_count->currentIndex() + 1;

        for (int j = 1; j <= count; j++)
        {
            QString bullet = "";
            bullet = QString("> ");
            numbering = numbering + "\n" + offset + bullet + "\t";
        }

        numbering += "\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab

        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 4;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else                                                //  document in actual tab of text editor is Python
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";                         //  load string with template which will be inserted into text
        numbering += "\n";
        numbering += offset;
        numbering += "class Parent:";
        numbering += "\n";
        numbering = numbering + offset + "\tdef __init__(self, my_flag, my_integer, my_float, my_string):\n";
        numbering = numbering + offset + "\t\tself.__my_flag = my_flag\n";
        numbering = numbering + offset + "\t\tself.__my_integer = my_integer\n";
        numbering = numbering + offset + "\t\tself.__my_float = my_float\n";
        numbering = numbering + offset + "\t\tself._my_string = my_string\n";
        numbering = numbering + offset + "\t\n";
        numbering = numbering + offset + "\tdef get_information(self):\n";
        numbering = numbering + offset + "\t\treturn self.__my_float\n";
        numbering = numbering + offset + "\t\n";
        numbering = numbering + offset + "\tdef my_method(self, my_integer):\n";
        numbering = numbering + offset + "\t\tself.__my_integer = my_integer\n";
        numbering = numbering + offset + "\t\treturn self.__my_integer\n";

        numbering += "\n";
        numbering += offset;
        numbering += "class Child(Parent):";
        numbering += "\n";
        numbering = numbering + offset + "\tdef __init__(self, my_flag, my_integer, my_float, my_string):\n";
        numbering = numbering + offset + "\t\tsuper().__init__(my_flag, my_integer, my_float, my_string)\n";
        numbering = numbering + offset + "\t\n";
        numbering = numbering + offset + "\tdef parent_access(self):\n";
        numbering = numbering + offset + "\t\treturn self._my_string\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 7;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 6, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }

    editor[index].setFocus();                           //  set focus to text editor
}


/// Handle press of tenth template button
void Spade::template_style_button_10_pressed()
{
    int actual = files->currentIndex();                 //  get actual index of files combo box
    int index = active_tabs[actual].index_in_tabs;

    if (active_tabs[actual].language == c99)            //  document in actual tab of text editor is C99
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";
        numbering += "\n";
        numbering += offset;
        numbering += "enum myEnum{One, Two, Three, Four, Five};\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 6;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 6, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == cplusplus)      //  document in actual tab of text editor is C++
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";
        numbering += "\n";
        numbering += offset;
        numbering += "template <class type>";
        numbering += "\n";
        numbering += offset;
        numbering += "type sum(type left, type right)";
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\treturn left + right;\n";
        numbering += offset;
        numbering += "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 17;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 4, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == java)      //  document in actual tab of text editor is Java
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";
        numbering += "\n";
        numbering += offset;
        numbering += "public interface myInterface";
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\tpublic void show_information();\n";
        numbering = numbering + offset + "\tpublic int my_method(int);\n";
        numbering += offset;
        numbering += "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 18;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 11, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == php)       //  document in actual tab of text editor is PHP
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";
        numbering += "\n";
        numbering += offset;
        numbering += "interface myInterface";
        numbering += "\n";
        numbering += offset;
        numbering += "{\n";
        numbering = numbering + offset + "\tpublic function show_information();\n";
        numbering = numbering + offset + "\tpublic function my_method($number);\n";
        numbering += offset;
        numbering += "}\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 11;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 11, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else if (active_tabs[actual].language == plain_text)    //  document in actual tab of text editor is plain text
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "";
        int count = template_count->currentIndex() + 1;

        for (int j = 1; j <= count; j++)
        {
            QString bullet = "";
            bullet = QString("->");
            numbering = numbering + "\n" + offset + bullet + "\t";
        }

        numbering += "\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab

        int from = editor[index].textCursor().position() - numbering.size() + offset.size() + 4;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else                                                //  document in actual tab of text editor is Python
    {
        QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
        int N = content.size();
        int position = editor[index].textCursor().position();   //  get actual text cursor position
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        while (i < N && content[i] != '\n')             //  find end of actual line
            i++;

        * text_cursor = editor[index].textCursor();     //  move text cursor to end of actual line
        text_cursor->setPosition(i);
        text_cursor->setPosition(i, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);

        QString numbering = "\n";
        numbering = numbering + offset + "try:\n";
        numbering = numbering + offset + "\tfout = open('file.txt', 'w')\n";
        numbering = numbering + offset + "except IOError:\n";
        numbering = numbering + offset + "\tsys.stderr.write(\"cannot open output file\\n\")\n";
        numbering = numbering + offset + "\tsys.exit(1)\n";

        editor[index].insertPlainText(numbering);       //  insert string into content of actual tab
        int from = editor[index].textCursor().position() - numbering.size() + 2 * offset.size() + 20;
                                                        //  move cursor to first line of template sequence
        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from + 8, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }

    editor[index].setFocus();                           //  set focus to text editor
}


/// Handle press of fifth back button
void Spade::back_button_5_pressed()
{
    hide_template_tray();                               //  hide template tray
    show_tray();                                        //  show main tray

    template_tray_visible = false;                      //  refresh values of appropriate flags
    tray_visible = true;
}


/// Handle press of horizontal send button
void Spade::send_horizontal_button_pressed()
{
    if (custom_languages->count())
        emit send_language_signal(1, user_languages[custom_languages->currentIndex()]);
}


/// Handle press of vertical send button
void Spade::send_vertical_button_pressed()
{
    if (custom_languages->count())
        emit send_language_signal(2, user_languages[custom_languages->currentIndex()]);
}


/// Handle press of diagonal send button
void Spade::send_diagonal_button_pressed()
{
    if (custom_languages->count())
        emit send_language_signal(3, user_languages[custom_languages->currentIndex()]);
}


/// Handle press of save all button
void Spade::send_all_button_pressed()
{
    if (custom_languages->count())
        emit send_language_signal(4, user_languages[custom_languages->currentIndex()]);
}


/// Handle press of change button
void Spade::change_button_pressed()
{
    if (custom_languages->count())
    {
        Language user_language;
        user_language = user_languages[custom_languages->currentIndex()];
        ui->widget->open_language(user_language);
        ui->widget->set_language_name(user_language.name);

        hide_language_tray();                           //  hide language tray

        language_flag = true;                           //  set language flag
        ui->tabs->setCurrentIndex(max_tabs);            //  move to language screen tab of text editor
    }
}


/// Handle press of add button
void Spade::add_button_pressed()
{
    hide_language_tray();                               //  hide language tray

    language_flag = true;                               //  set language flag
    ui->tabs->setCurrentIndex(max_tabs);                //  move to language screen tab of text editor
}


/// Handle press of delete button
void Spade::delete_button_pressed()
{
    if (custom_languages->count())
    {
        int index = custom_languages->currentIndex();

        int N = active_tabs.size();                     //  get number of active tabs
        bool used = false;

        for (int i = 0; i < N; i++)                     //  iterate through all tabs of text editor
        {
            if (active_tabs[i].language == index + builtInLanguages)
            {
                used = true;
                break;
            }
        }

        if (used == false)
        {
            user_languages.removeAt(index);
            custom_languages->removeItem(index);
            languages->removeItem(builtInLanguages + index);

            for (int i = 0; i < N; i++)                 //  iterate through all tabs of text editor
            {
                if (active_tabs[i].language > index + builtInLanguages)
                    active_tabs[i].language--;
            }
        }
    }
}


/// Handle press of sixth back button
void Spade::back_button_6_pressed()
{
    hide_language_tray();                               //  hide language tray
    show_tray();                                        //  show main tray

    language_tray_visible = false;                      //  refresh values of appropriate flags
    tray_visible = true;
}


/// Handle press of Vim accept button
void Spade::vim_edit_accepted()
{   
    if (vim_prefix->text() == ":")                      //  command mode has been activated
    {
        QString command = vim_edit->text();

        if (command.contains('/'))                      //  search command selected
        {
            QStringList parts = command.split("/");
            bool line_flag = false;

            vim_prefix->text().trimmed();

            if (parts.size() == 4)                      //  search command is built from four parts
            {
                if (parts[3].trimmed() != "g")          //  g subcommand has been selected
                    return;

                line_flag = true;                       //  activate single line search mode
                parts.pop_back();
            }

            if (parts.size() == 3)                      //   search command is built from four parts
            {
                QString type = parts[0].trimmed();
                parts.pop_front();

                if (type == "s")                        //  s subcommand has been selected
                {
                    bool found = false;
                                                        //  get content of actual using text cursor
                    * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                    text_cursor->movePosition(QTextCursor::StartOfBlock);
                    int actual = text_cursor->position();
                    text_cursor->movePosition(QTextCursor::EndOfBlock, QTextCursor::KeepAnchor);
                    QString line = text_cursor->selectedText();

                    if (line_flag)                      //  single line search mode is active
                    {
                        found = true;                   //  text patter has been found

                        line.replace(parts[0], parts[1]);
                        text_cursor->insertText(line);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                    }
                    else                                //  single line search mode is inactive
                    {
                        int from = line.indexOf(parts.front());

                        if (from != -1)
                        {
                            found = true;               //  text patter has been found

                            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                            text_cursor->setPosition(actual + from);
                            text_cursor->setPosition(actual + from + parts.front().size(), QTextCursor::KeepAnchor);
                            text_cursor->insertText(parts.last());
                            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                        }
                    }

                    if (found)                          //  text patter has been found
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->movePosition(QTextCursor::StartOfBlock);   //  mark searched text using text cursor selection
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                        vim_prefix->hide();
                        vim_edit->setReadOnly(true);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setReadOnly(false);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setFocus();

                        editor[active_tabs[files->currentIndex()].index_in_tabs].key_press_flag = true;

                        QKeyEvent * event = new QKeyEvent(QEvent::KeyPress, Qt::Key_Right, Qt::ControlModifier);
                        QApplication::postEvent(QApplication::focusWidget(), event);
                    }
                }
                else if (type.right(1) == "s")          //  s subcommand has been selected at the end of command
                {
                    bool found = false;                 //  holds if desired text pattern has been found
                    int range_from = 1;
                    int range_to = 1;

                    if (type.left(1) == "%")            //  % subcommand has been selected
                        range_to = editor[active_tabs[files->currentIndex()].index_in_tabs].blockCount() - 1;
                    else
                    {
                        bool success = false;           //  holds if command construction is correct
                        type.chop(1);

                        if (type.contains(','))         //  check if comma character is present in command
                        {
                            QStringList digits = type.split(",");   //  split command to comma separated parts

                            if (digits.size() == 2)
                            {
                                digits[0] = digits[0].trimmed();
                                digits[1] = digits[1].trimmed();

                                QRegExp re("\\d+");

                                if (re.exactMatch(digits[0]))   //  get lines range from command
                                {
                                    range_from = digits[0].toInt();

                                    if (re.exactMatch(digits[1]))
                                    {
                                        range_to = digits[1].toInt();
                                        success = true;     //  command construction is correct
                                    }
                                }
                            }
                        }
                        else
                        {
                            type = type.trimmed();

                            QRegExp re("\\d+");         //  get line number from command

                            if (re.exactMatch(type))
                            {
                                range_from = range_to = type.toInt();
                                success = true;         //  command construction is correct
                            }
                        }

                        if (success == false)           //  command construction is incorrect
                            return;                     //  do not search anything
                    }

                    if (range_from == 0)                //  handle zero range specification
                        range_from = 1;

                    if (range_to == 0)                  //  handle zero range specification
                        range_to = 1;

                    for (int i = range_from; i <= range_to; i++)    //  iterate through specified lines range
                    {
                        QTextCursor line_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(i - 1));

                        int actual = line_cursor.position();
                        line_cursor.movePosition(QTextCursor::EndOfBlock, QTextCursor::KeepAnchor);
                        QString line = line_cursor.selectedText();

                        if (line_flag)                  //  single line search mode is active
                        {
                            QString original = line;
                            line.replace(parts[0], parts[1]);   //  perform text substitution

                            if (line != original)       
                            {
                                found = true;           //  text patter has been found

                                line_cursor.insertText(line);
                                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(line_cursor);
                            }
                        }
                        else                            //  single line search mode is inactive
                        {
                            int from = line.indexOf(parts.front());

                            if (from != -1)
                            {
                                found = true;           //  text patter has been found

                                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                text_cursor->setPosition(actual + from);
                                text_cursor->setPosition(actual + from + parts.front().size(), QTextCursor::KeepAnchor);
                                text_cursor->insertText(parts.last());
                                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                            }
                        }
                    }

                    if (found)                          //  text patter has been found
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->movePosition(QTextCursor::StartOfBlock);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                        vim_prefix->hide();             //  hide Vim prefix slash after successfull searching
                        vim_edit->setReadOnly(true);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setReadOnly(false);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setFocus();

                        editor[active_tabs[files->currentIndex()].index_in_tabs].key_press_flag = true;

                        QKeyEvent * event = new QKeyEvent(QEvent::KeyPress, Qt::Key_Right, Qt::ControlModifier);
                        QApplication::postEvent(QApplication::focusWidget(), event);
                    }
                }
            }

            return;
        }

        command = command.trimmed();

        if (command == "w")                             //  save file command has been selected
        {
            save_button_pressed();                      //  save actual file using appropriate method

            if (active_tabs[files->currentIndex()].saved)   //  file has been successfully saved
            {
                vim_edit->setText(editor[active_tabs[files->currentIndex()].index_in_tabs].file_path);
                vim_edit->insert("  ");
                vim_edit->insert(QString("%1").arg(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->blockCount()));
                vim_edit->insert("L, ");
                vim_edit->insert(QString("%1").arg(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText().size()));
                vim_edit->insert("C  written");

                vim_prefix->hide();                     //  close Vim tray and return back to editor
                vim_edit->clear();
                vim_edit->setReadOnly(true);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setReadOnly(false);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setFocus();
            }
        }
        else if (command == "q")                        //  exit command has been selected
        {
            if (active_tabs[files->currentIndex()].saved)   //  file is saved
            {
                hide_vim_tray();                        //  hide vim tray
                show_tray();                            //  show main tray

                vim_tray_visible = false;               //  refresh values of appropriate flags
                tray_visible = true;

                editor[active_tabs[files->currentIndex()].index_in_tabs].vim_active = false;
                editor[active_tabs[files->currentIndex()].index_in_tabs].setOverwriteMode(insert_mode);
            }
            else                                        //  file is not saved
                vim_edit->setText("No write since last change (add ! to override)");

            vim_prefix->hide();                         //  close Vim tray and return back to editor
            vim_edit->setReadOnly(true);
            editor[active_tabs[files->currentIndex()].index_in_tabs].setReadOnly(false);
            editor[active_tabs[files->currentIndex()].index_in_tabs].setFocus();
        }
        else if (command == "wq")                       //  save and exit command has been selected
        {
            save_button_pressed();                      //  save actual file using appropriate method

            if (active_tabs[files->currentIndex()].saved)   //  file has been successfully saved
            {
                hide_vim_tray();                        //  hide vim tray
                show_tray();                            //  show main tray

                vim_tray_visible = false;               //  refresh values of appropriate flags
                tray_visible = true;

                editor[active_tabs[files->currentIndex()].index_in_tabs].vim_active = false;
                editor[active_tabs[files->currentIndex()].index_in_tabs].setOverwriteMode(insert_mode);
            }
            else                                        //  file has not been saved
                vim_edit->setText("No write since last change (add ! to override)");
                                                        //  close Vim tray and return back to editor
            vim_prefix->hide();
            vim_edit->setReadOnly(true);
            editor[active_tabs[files->currentIndex()].index_in_tabs].setReadOnly(false);
            editor[active_tabs[files->currentIndex()].index_in_tabs].setFocus();
        }
        else if (command == "q!")                       //  forced exit command has been selected
        {
            hide_vim_tray();                            //  hide vim tray
            show_tray();                                //  show main tray

            vim_tray_visible = false;                   //  refresh values of appropriate flags
            tray_visible = true;
                                                        //  close Vim tray and return back to editor
            editor[active_tabs[files->currentIndex()].index_in_tabs].vim_active = false;
            editor[active_tabs[files->currentIndex()].index_in_tabs].setOverwriteMode(insert_mode);
            vim_prefix->hide();
            vim_edit->clear();
            vim_edit->setReadOnly(true);
            editor[active_tabs[files->currentIndex()].index_in_tabs].setReadOnly(false);
            editor[active_tabs[files->currentIndex()].index_in_tabs].setFocus();
        }
    }
    else
    {
        bool delete_flag = false;
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
            delete_flag = true;                         //  set delete flag
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
            lower_flag = true;                          //  set lowercase flag
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
            upper_flag = true;                          //  set uppercase flag

        vim_character_queue = "";

        if (vim_edit->text().size() > 1)
        {
            if (vim_edit->text().size())                //  vim edit content cannot be empty
            {                                           //  set vim edit content as find pattern of regular expression
                QString find_pattern = vim_edit->text();    //  get content of vim edit

                QRegularExpression expr(find_pattern);
                expr.setPatternOptions(QRegularExpression::DotMatchesEverythingOption);     //  allow multiline match for regular expression
                expr.optimize();

                if (expr.isValid())                     //  check if regular expression is valid
                {
                    vector<int> from_array;             //  array with starting positions of all regular expression matches
                    vector<int> to_array;               //  array with ending positions of all regular expression matches

                    QRegularExpressionMatchIterator iter = expr.globalMatch(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText());
                                                        //  check for global match of regular expression and save result into match iterator
                    while (iter.hasNext())              //  iterate through all matches
                    {
                        QRegularExpressionMatch match = iter.next();

                        if (match.hasMatch())           //  regular expression match found
                        {
                            from_array.push_back(match.capturedStart(0));   //  push coordinates of match into appropriate arrays
                            to_array.push_back(match.capturedEnd(0));
                        }
                    }

                    int N = from_array.size();          //  get number of regular expression matches

                    if (N)                              //  at least one match must be present
                    {                                   //  get actual text cursor position
                        if (delete_flag || lower_flag || upper_flag || vim_visual_flag)
                        {
                            vim_prefix->hide();

                            if (vim_visual_flag)                            //  Vim visual mode is active
                                vim_edit->setText("- -  VISUAL  - -");

                            vim_edit->setReadOnly(true);
                            editor[active_tabs[files->currentIndex()].index_in_tabs].setReadOnly(false);
                            editor[active_tabs[files->currentIndex()].index_in_tabs].setFocus();
                            vim_find_pattern = find_pattern;

                            int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();

                            if (N == 1)                 //  just highlight one and only match by text cursor selection
                            {
                                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                text_cursor->setPosition(from_array[0], QTextCursor::KeepAnchor);
                                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                                return;                 //  stop searching
                            }

                            bool found = false;         //  holds if appropriate match was selected

                            for (int i = 0; i < N; i++)     //  iterate again through all matches
                            {
                                if (from_array[i] <= actual && actual <= to_array[i])   //  cursor position is at location of actual match
                                {
                                    if (i == N - 1)     //  actual match is last in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[0], QTextCursor::KeepAnchor);    //  highlight first match
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }
                                    else                //  actual match is not last in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[i + 1], QTextCursor::KeepAnchor);    //  highlight next match
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }

                                    found = true;
                                    break;              //  stop searching
                                }
                                else if (actual < from_array[i])    //  cursor position is before location of actual match
                                {
                                    * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                    text_cursor->setPosition(from_array[i], QTextCursor::KeepAnchor);    //  highlight actual match
                                    editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                                    found = true;
                                    break;              //  stop searching
                                }
                            }

                            if (found == false)
                            {                           //  select first match if flag is not set
                                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                text_cursor->setPosition(from_array[0], QTextCursor::KeepAnchor);    //  highlight first match of file content
                                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                            }
                        }
                        else
                        {
                            vim_prefix->hide();
                            vim_edit->clear();
                            vim_edit->setReadOnly(true);
                            editor[active_tabs[files->currentIndex()].index_in_tabs].setReadOnly(false);
                            editor[active_tabs[files->currentIndex()].index_in_tabs].setFocus();
                            vim_find_pattern = find_pattern;

                            int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();

                            if (N == 1)                 //  just highlight one and only match by text cursor selection
                            {
                                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                text_cursor->setPosition(from_array[0]);
                                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                                return;                 //  stop searching
                            }

                            bool found = false;         //  holds if appropriate match was selected

                            for (int i = 0; i < N; i++)     //  iterate again through all matches
                            {
                                if (from_array[i] <= actual && actual <= to_array[i])   //  cursor position is at location of actual match
                                {
                                    if (i == N - 1)     //  actual match is last in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[0]);    //  highlight first match of file content by text cursor selection
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }
                                    else                //  actual match is not last in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[i + 1]);    //  highlight next match by text cursor selection
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }

                                    found = true;
                                    break;              //  stop searching
                                }
                                else if (actual < from_array[i])    //  cursor position is before location of actual match
                                {
                                    * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                    text_cursor->setPosition(from_array[i]);    //  highlight actual match by text cursor selection
                                    editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                                    found = true;
                                    break;              //  stop searching
                                }
                            }

                            if (found == false)
                            {                           //  select first match if flag is not set
                                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                text_cursor->setPosition(from_array[0]);    //  highlight first match of file content by text cursor selection
                                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                            }
                        }

                        if (delete_flag)
                            editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                        else if (lower_flag)
                            lower_case_button_pressed();    //  convert selected text into lowercase text
                        else if (upper_flag)
                            upper_case_button_pressed();    //  convert selected text into uppercase text

                        if (insert_flag)                                //  insert command has been used
                        {
                            int index = active_tabs[files->currentIndex()].index_in_tabs;

                            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
                            editor[index].vim_active = false;           //  activate overwrite mode in text editor
                            editor[index].setOverwriteMode(insert_mode);
                        }
                    }
                }
            }
        }
    }
}


/// Handle selection of project language
///
/// @param  Integer index of project language
void Spade::project_language_selected(int)
{
    if (projects->currentIndex() == 0)                  //  single file mode must be active to allow change of language
    {
        if (class_tree_visible)                         //  check if class tree is already visible
            text_change_timer->start(3000);             //  refresh class tree content
    }
}


/// Handle press of new project button
void Spade::new_project_button_pressed()
{
    if (language->currentIndex() == plain_text || language->currentIndex() == php || language->currentIndex() == python)
        return;

    QString default_path = QDir::homePath();

    if (default_path.right(1) != "/")                   //  check if path contains trailing slash character
        default_path.push_back('/');

    default_path.push_back("untitled.pro");

    QString path = file_dialog->getSaveFileName
    (
        this,                                           //  parent
        "Select project file",                          //  file dialog title
        default_path,                                   //  default directory
        "Project files (*.pro)",                        //  file filter
        (QString *)(nullptr),                           //  pointer to string of selected filter
        QFileDialog::DontResolveSymlinks                //  ignore symbolic links
    );

    if (path.isEmpty() || path.isNull())
        return;

    if (path.right(4) != ".pro")                        //  add project file extension
        path.push_back(".pro");

    int projects_len = active_projects.size();

    for (int i = 0; i < projects_len; i++)              //  same project cannot be opened twice
    {
        if (active_projects[i].path == path)
        {
            project_selected(i);
            return;
        }
    }

    run_parameters->setText("");

    if (language->currentIndex() == c99)
    {
        compile_parameters->setText("-std=c11 -Wall -Wextra -pedantic -O3");
        make_parameters->setText(QString("-j%1").arg(thread_count));
    }
    else if (language->currentIndex() == cplusplus)
    {
        compile_parameters->setText("-std=c++11 -Wall -Wextra -pedantic -O3");
        make_parameters->setText(QString("-j%1").arg(thread_count));
    }
    else if (language->currentIndex() == java)
    {
        compile_parameters->setText("");
        make_parameters->setText("");
    }

    QFile project_file(path);

    if (project_file.open(QFile::WriteOnly | QFile::Text))    //  open source file for reading
    {
        QTextStream fout(&project_file);                //  create output text stream to allows writing into project file
        fout << language->currentIndex() << char(29) << run_parameters->text() << char(29) << compile_parameters->text() << char(29) << make_parameters->text() << char(29);
        project_file.close();                           //  close opened project file
    }

    QString name = get_filename_from_file_path(path);

    projects->addItem(name);                            //  add new project into appropriate combobox
    projects->setToolTip(path);
    projects->setItemData(projects->count() - 1, path, Qt::ToolTipRole);

    Project_details new_project;                        //  create new descriptor of project
    new_project.name = name;
    new_project.path = path;
    new_project.language = language->currentIndex();
    new_project.run_arguments = run_parameters->text();
    new_project.compile_arguments = compile_parameters->text();
    new_project.make_arguments = make_parameters->text();
    active_projects.push_back(new_project);             //  push back new item into project descriptors list

    delete_button_2->show();                            //  toggle visibility of some elements in projects tray
    source_button->show();
    source_files->show();
    delete_button_3->show();
    run_button->show();
    build_button->show();
    clean_button->show();
    source_files->clear();

    projects->setCurrentIndex(projects->count() - 1);
}


/// Handle press of open project button
void Spade::open_project_button_pressed()
{
    QString default_path = QDir::homePath();

    if (default_path.right(1) != "/")                   //  check if path contains trailing slash character
        default_path.push_back('/');

    default_path.push_back("untitled.pro");

    QString path = file_dialog->getOpenFileName
    (
        this,                                           //  parent
        "Select project file",                          //  file dialog title
        default_path,                                   //  default directory
        "Project files (*.pro)",                        //  file filter
        (QString *)(nullptr),                           //  pointer to string of selected filter
        QFileDialog::DontResolveSymlinks                //  ignore symbolic links
    );

    if (path.isEmpty() || path.isNull())
        return;

    int projects_len = active_projects.size();

    for (int i = 0; i < projects_len; i++)              //  same project cannot be opened twice
    {
        if (active_projects[i].path == path)
        {
            project_selected(i);
            return;
        }
    }

    QString name = get_filename_from_file_path(path);

    projects->addItem(name);                            //  add new project into appropriate combobox
    projects->setToolTip(path);
    projects->setItemData(projects->count() - 1, path, Qt::ToolTipRole);

    Project_details new_project;                        //  create new descriptor of project
    new_project.name = name;
    new_project.path = path;
    active_projects.push_back(new_project);             //  push back new item into project descriptors list

    delete_button_2->show();                            //  toggle visibility of some elements in projects tray
    source_button->show();
    source_files->show();
    delete_button_3->show();
    run_button->show();
    build_button->show();
    clean_button->show();
    source_files->clear();

    QString content = "";

    QFile file(path);

    if (file.open(QFile::ReadOnly | QFile::Text))       //  open project file for writing
    {
        QTextStream fin(&file);
        content = fin.readAll();                        //  get content of file from disk
        file.close();
    }

    int N = content.size();

    if (N)                                              //  iterate through loaded content until length of content is reached
    {
        int i = 0;
        QString temp = "";

        while (i < N && content[i] != char(29))         //  parse bold flag value from content of language file
        {
            temp.push_back(content[i]);
            i++;
        }

        if (temp.size())
        {
            active_projects[active_projects.size() - 1].language = temp.toInt();
            language->setCurrentIndex(temp.toInt());

            i++;                                        //  ignore separating character with ASCII value 29
            temp.clear();

            while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
            {
                temp.push_back(content[i]);
                i++;
            }

            active_projects[active_projects.size() - 1].run_arguments = temp;
            run_parameters->setText(temp);

            i++;                                        //  ignore separating character with ASCII value 29
            temp.clear();

            while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
            {
                temp.push_back(content[i]);
                i++;
            }

            active_projects[active_projects.size() - 1].compile_arguments = temp;
            compile_parameters->setText(temp);

            i++;                                        //  ignore separating character with ASCII value 29
            temp.clear();

            while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
            {
                temp.push_back(content[i]);
                i++;
            }

            active_projects[active_projects.size() - 1].make_arguments = temp;
            make_parameters->setText(temp);

            i++;                                        //  ignore separating character with ASCII value 29
            temp.clear();

            while (true)
            {
                while (i < N && content[i] != char(29))     //  parse bold flag value from content of language file
                {
                    temp.push_back(content[i]);
                    i++;
                }

                if (temp.size() == 0)
                    break;

                QFile source_file(temp);

                if (source_file.open(QFile::ReadOnly | QFile::Text))
                {
                    source_files->addItem(get_filename_from_file_path(temp));
                    active_projects[active_projects.size() - 1].files.push_back(temp);
                    source_files->setItemData(source_files->count() - 1, temp, Qt::ToolTipRole);
                    source_files->setToolTip(temp);

                    source_file.close();
                }

                i++;                                    //  ignore separating character with ASCII value 29
                temp.clear();
            }
        }
    }

    if (source_files->count())
        source_files->setCurrentIndex(source_files->count() - 1);

    projects->setCurrentIndex(projects->count() - 1);
}


/// Handle press of source button
void Spade::source_button_pressed()
{
    QStringList values;

    if (active_projects[active_projects.size() - 1].language == c99)
    {
        values = file_dialog->getOpenFileNames
        (
            this,                                       //  parent
            "Select concrete files",                    //  file dialog title
            get_directory_from_file_path(active_projects[projects->currentIndex() - 1].path),   //  default directory
            "C source files (*.h *.H *.c *.C)",         //  file filter
            (QString *)(nullptr),                       //  pointer to string of selected filter
            QFileDialog::DontResolveSymlinks            //  ignore symbolic links
        );
    }
    else if (active_projects[active_projects.size() - 1].language == cplusplus)
    {
        values = file_dialog->getOpenFileNames
        (
            this,                                       //  parent
            "Select concrete files",                    //  file dialog title
            get_directory_from_file_path(active_projects[projects->currentIndex() - 1].path),   //  default directory
            "C++ source files (*.h *.H *.c *.C *.hh *.hxx *.h++ *.cpp *.cc *.cxx *.c++)",   //  file filter
            (QString *)(nullptr),                       //  pointer to string of selected filter
            QFileDialog::DontResolveSymlinks            //  ignore symbolic links
        );
    }
    else if (active_projects[active_projects.size() - 1].language == java)
    {
        values = file_dialog->getOpenFileNames
        (
            this,                                       //  parent
            "Select concrete files",                    //  file dialog title
            get_directory_from_file_path(active_projects[projects->currentIndex() - 1].path),   //  default directory
            "Java source files (*.java *.jar *.jsp *.dpj)",     //  file filter
            (QString *)(nullptr),                       //  pointer to string of selected filter
            QFileDialog::DontResolveSymlinks            //  ignore symbolic links
        );
    }

    int N = values.size();

    if (N)
    {
        QFile project_file(active_projects[projects->currentIndex() - 1].path);

        if (project_file.open(QFile::WriteOnly | QFile::Text | QFile::Append))    //  project file was successfully opened for writing
        {
            QTextStream fout(&project_file);            //  create output text stream to allows writing into project file
            bool file_added = false;

            for (int i = 0; i < N; i++)
            {
                if (active_projects[projects->currentIndex() - 1].files.contains(values[i]))
                    continue;

                source_files->addItem(get_filename_from_file_path(values[i]));
                fout << values[i] << char(29);
                active_projects[projects->currentIndex() - 1].files.push_back(values[i]);
                source_files->setItemData(source_files->count() - 1, values[i], Qt::ToolTipRole);
                file_added = true;
            }

            project_file.close();                       //  close opened project file

            if (file_added)
            {
                source_files->setCurrentIndex(source_files->count() - 1);
                source_files->setToolTip(values[N - 1]);

                if (class_tree_visible)                 //  check if class tree is already visible
                    text_change_timer->start(3000);     //  refresh class tree content
            }
        }
    }
}


/// Handle press of second delete button
void Spade::delete_button_2_pressed()
{
    if (projects->currentIndex())                       //  check if there is at least one opened project
    {
        active_projects.removeAt(projects->currentIndex() - 1);
        projects->removeItem(projects->currentIndex());
    }
}


/// Handle selection of project
///
/// @param  Index of concrete project as an integer value
void Spade::project_selected(int index)
{
    if (index == 0)                                     //  single file mode has been activated
    {
        delete_button_2->setEnabled(false);             //  toggle visibility of some elements inside projects tray
        source_button->setEnabled(false);
        delete_button_3->setEnabled(false);
        makefile_button->setEnabled(false);
        build_button->setEnabled(false);
        clean_button->setEnabled(false);

        source_files->clear();
        source_files->addItem(active_tabs[files->currentIndex()].file_name);
        source_files->setToolTip(active_tabs[files->currentIndex()].file_path);
        source_files->setItemData(0, active_tabs[files->currentIndex()].file_path, Qt::ToolTipRole);

        projects->setToolTip("Empty project with single file only");
    }
    else                                                //  concrete project has been selected
    {
        delete_button_2->setEnabled(true);              //  toggle visibility of some elements inside projects tray
        source_button->setEnabled(true);
        delete_button_3->setEnabled(true);
        makefile_button->setEnabled(true);
        build_button->setEnabled(true);
        clean_button->setEnabled(true);
        source_files->clear();

        int N = active_projects[index - 1].files.size();

        if (N)                                          //  load project files into appropriate combo box
        {
            for (int i = 0; i < N; i++)
                source_files->addItem(get_filename_from_file_path(active_projects[index - 1].files[i]));

            for (int i = 0; i < N; i++)                 //  add full path as a tooltip
                source_files->setItemData(i, active_projects[index - 1].files[i], Qt::ToolTipRole);

            source_files->setCurrentIndex(0);
            source_files->setToolTip(active_projects[index - 1].files[0]);
        }

        projects->setToolTip(active_projects[projects->currentIndex() - 1].path);
        language->setCurrentIndex(active_projects[index - 1].language);
        run_parameters->setText(active_projects[index - 1].run_arguments);
        compile_parameters->setText(active_projects[index - 1].compile_arguments);
        make_parameters->setText(active_projects[index - 1].make_arguments);
    }

    if (class_tree_visible)                             //  check if class tree is already visible
        text_change_timer->start(3000);                 //  refresh class tree content
}


/// Handle press of class tree button
void Spade::class_tree_button_pressed()
{
    if (class_tree_visible)                         //  check if class tree is already visible
    {
        class_tree_button->setIcon(* class_off_icon);
        ui->class_tree->hide();                     //  hide class tree
        ui->line->hide();                           //  hide border of class tree
        class_tree_visible = false;
    }
    else
    {
        class_tree_button->setIcon(* class_on_icon);
        class_tree_visible = true;
        text_change_timer->start(50);               //  reveal class tree after 50 miliseconds
    }
}


/// Handle press of Makefile button
void Spade::makefile_button_pressed()
{
    if (source_files->count())
    {
        if (active_projects[active_projects.size() - 1].language == c99)
        {
            int N = active_projects[projects->currentIndex() - 1].files.size();
            QStringList headers;
            QStringList sources;

            for (int i = 0; i < N; i++)                 //  iterate through all files of project
            {
                QString tail = active_projects[projects->currentIndex() - 1].files[i].right(4);
                                                        //  sort all project files by its type
                if (tail.size() == 4)
                {
                    if (tail == ".hxx" || tail == ".h++")   //  header file type
                        headers.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                    else if (tail == ".cxx" || tail == ".c++" || tail == ".cpp")    //  source file type
                        sources.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                    else
                    {
                        tail.remove(0, 1);

                        if (tail == ".hh")              //  header file type
                            headers.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                        else if (tail == ".cc")         //  source file type
                            sources.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                        else
                        {
                            tail.remove(0, 1);

                            if (tail == ".h" || tail == ".H")   //  header file type
                                headers.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                            else if (tail == ".c" || tail == ".C")  //  source file type
                                sources.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                        }
                    }
                }
            }

            N = sources.size();

            if (N)                                      //  ignore empty projects with no files
            {
                QString Compile = compile_parameters->text();
                QString code = "";
                QString makefile_head = "";
                QString directory_path = get_directory_from_file_path(active_projects[projects->currentIndex() - 1].path);

                if (directory_path.right(1) != "/")     //  check if directory contains trailing slash character
                    directory_path.push_back('/');

                for (int i = 0; i < N; i++)             //  create objects for all project files in loop
                {
                    makefile_head.push_back(QString(" %1object_%2.o").arg(directory_path).arg(i));
                    code.push_back(QString("%1object_%2.o: %3").arg(directory_path).arg(i).arg(sources[i]));

                    if (i == N - 1)
                    {
                        int M = headers.size();

                        for (int j = 0; j < M; j++)     //  handle header files behavior
                            code.push_back(QString(" %1").arg(headers[j]));     //  header files have do not require alone objects
                    }
                                                        //  create link line of Makefile
                    code.push_back(QString("\n\tgcc %1 -c %2 -o %3object_%4.o -lm\n\n").arg(Compile).arg(sources[i]).arg(directory_path).arg(i));
                }

                QString binary_path = active_projects[projects->currentIndex() - 1].path;
                binary_path.chop(4);

                code = binary_path + ":" + makefile_head + QString("\n\tgcc %1").arg(Compile) + makefile_head + " -o " + binary_path + " -lm\n\n" + code;
                code = code + "clean:\n\trm -f" + makefile_head + " " + binary_path + "\n\n";   //  add clean command into the Makefile
                code = code + "run:\n\t" + binary_path + "\n";  //  add run command into the Makefile

                QString path = get_directory_from_file_path(active_projects[projects->currentIndex() - 1].path);

                if (path.right(1) != "/")               //  check if path contains trailing slash character
                    path.push_back('/');

                path.push_back("Makefile");

                QFile makefile(path);

                if (makefile.open(QFile::WriteOnly | QFile::Text | QFile::Truncate))    //  project file was successfully opened for writing
                {
                    QTextStream fout(&makefile);        //  write appropriate content into Makefile
                    fout << code;
                    makefile.close();
                }
            }
        }
        else if (active_projects[active_projects.size() - 1].language == cplusplus)
        {
            int N = active_projects[projects->currentIndex() - 1].files.size();
            QStringList headers;
            QStringList sources;

            for (int i = 0; i < N; i++)                 //  iterate through all files of project
            {
                QString tail = active_projects[projects->currentIndex() - 1].files[i].right(4);
                                                        //  sort all project files by its type
                if (tail.size() == 4)
                {
                    if (tail == ".hxx" || tail == ".h++")   //  header file type
                        headers.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                    else if (tail == ".cxx" || tail == ".c++" || tail == ".cpp")    //  source file type
                        sources.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                    else
                    {
                        tail.remove(0, 1);

                        if (tail == ".hh")              //  header file type
                            headers.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                        else if (tail == ".cc")         //  source file type
                            sources.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                        else
                        {
                            tail.remove(0, 1);

                            if (tail == ".h" || tail == ".H")   //  header file type
                                headers.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                            else if (tail == ".c" || tail == ".C")  //  source file type
                                sources.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                        }
                    }
                }
            }

            N = sources.size();

            if (N)                                      //  ignore empty projects with no files
            {
                QString Compile = compile_parameters->text();
                QString code = "";
                QString makefile_head = "";
                QString directory_path = get_directory_from_file_path(active_projects[projects->currentIndex() - 1].path);

                if (directory_path.right(1) != "/")     //  check if directory contains trailing slash character
                    directory_path.push_back('/');

                for (int i = 0; i < N; i++)             //  create objects for all project files in loop
                {
                    makefile_head.push_back(QString(" %1object_%2.o").arg(directory_path).arg(i));
                    code.push_back(QString("%1object_%2.o: %3").arg(directory_path).arg(i).arg(sources[i]));

                    if (i == N - 1)
                    {
                        int M = headers.size();

                        for (int j = 0; j < M; j++)     //  handle header files behavior
                            code.push_back(QString(" %1").arg(headers[j]));     //  header files have do not require alone objects
                    }
                                                        //  create link line of Makefile
                    code.push_back(QString("\n\tg++ %1 -c %2 -o %3object_%4.o -lm\n\n").arg(Compile).arg(sources[i]).arg(directory_path).arg(i));
                }

                QString binary_path = active_projects[projects->currentIndex() - 1].path;
                binary_path.chop(4);

                code = binary_path + ":" + makefile_head + QString("\n\tg++ %1").arg(Compile) + makefile_head + " -o " + binary_path + " -lm\n\n" + code;
                code = code + "clean:\n\trm -f" + makefile_head + " " + binary_path + "\n\n";   //  add clean command into the Makefile
                code = code + "run:\n\t" + binary_path + "\n";  //  add run command into the Makefile

                QString path = get_directory_from_file_path(active_projects[projects->currentIndex() - 1].path);

                if (path.right(1) != "/")               //  check if path contains trailing slash character
                    path.push_back('/');

                path.push_back("Makefile");

                QFile makefile(path);

                if (makefile.open(QFile::WriteOnly | QFile::Text | QFile::Truncate))    //  project file was successfully opened for writing
                {
                    QTextStream fout(&makefile);        //  write appropriate content into Makefile
                    fout << code;
                    makefile.close();
                }
            }
        }
        else if (active_projects[active_projects.size() - 1].language == java)
        {
            //  pass
        }
    }
}


/// Handle press of parameters toggle button
void Spade::toggle_button_pressed()
{
    hide_projects_tray();                               //  hide projects tray
    show_parameters_tray();                             //  show parameters tray

    projects_tray_visible = false;                      //  refresh values of appropriate flags
    parameters_tray_visible = true;

    if (projects->currentIndex())                       //  check if there is at least one opened project
    {
        run_parameters->setText(active_projects[projects->currentIndex() - 1].run_arguments);
        compile_parameters->setText(active_projects[projects->currentIndex() - 1].compile_arguments);
        make_parameters->setText(active_projects[projects->currentIndex() - 1].make_arguments);
    }
}


/// Handle press of third delete button
void Spade::delete_button_3_pressed()
{
    if (projects->currentIndex())                       //  check if there is at least one opened project
    {
        if (source_files->count())
        {
            active_projects[projects->currentIndex() - 1].files.removeAt(source_files->currentIndex());
            source_files->removeItem(source_files->currentIndex());

            QFile project_file(active_projects[projects->currentIndex() - 1].path);

            if (project_file.open(QFile::WriteOnly | QFile::Text | QFile::Truncate))    //  project file was successfully opened for writing
            {
                QTextStream fout(&project_file);        //  create output text stream to allows writing into project file

                fout << active_projects[projects->currentIndex() - 1].language << char(29);
                fout << active_projects[projects->currentIndex() - 1].run_arguments << char(29);
                fout << active_projects[projects->currentIndex() - 1].compile_arguments << char(29);
                fout << active_projects[projects->currentIndex() - 1].make_arguments << char(29);
                int N = active_projects[projects->currentIndex() - 1].files.size();

                for (int i = 0; i < N; i++)
                    fout << active_projects[projects->currentIndex() - 1].files[i] << char(29);

                project_file.close();                   //  close opened project file
            }
        }
    }
}


/// Handle press of run button
void Spade::run_button_pressed()
{
    if (isWindows)
        return;                                         //  project executing on Windows will be supported in the future

    QString terminal = terminal_name->text();

    if (projects->currentIndex())                       //  check if there is at least one opened project
    {
        if (source_files->count())
        {
            if (active_projects[projects->currentIndex() - 1].language == c99 || active_projects[projects->currentIndex() - 1].language == cplusplus)
            {
                int N = active_projects[projects->currentIndex() - 1].files.size();

                for (int i = 0; i < N; i++)
                {
                    QString path = active_projects[projects->currentIndex() - 1].files[i];
                    int tabs_size = active_tabs.size();

                    for (int j = 0; j < tabs_size; j++)     //  check if desired file to open is not already opened is text editor
                    {
                        if (active_tabs[j].file_path == path)
                        {
                            if (j == files->currentIndex())
                                save_button_pressed();
                            else
                            {
                                if (active_tabs[j].saved)   //  do nothing when content of actual tab is saved on disk
                                    break;

                                active_tabs[j].saved = true;

                                QFile file(path);

                                if (file.open(QFile::WriteOnly | QFile::Text | QFile::Truncate))    //  open file for writing
                                {
                                    QTextStream fout(&file);
                                    fout << editor[active_tabs[j].index_in_tabs].document()->toPlainText();     //  save content from text editor tab into appropriate file
                                    file.close();
                                }

                                editor[active_tabs[j].index_in_tabs].save_content();    //  call special method from code editor to handle file save
                            }

                            break;
                        }
                    }
                }

                QString Run = run_parameters->text();
                QString Make = make_parameters->text();
                QString directory_path = get_directory_from_file_path(active_projects[projects->currentIndex() - 1].path);

                if (directory_path.right(1) != "/")     //  check if directory contains trailing slash character
                    directory_path.push_back('/');

                QFile file(directory_path + "Makefile");    //  create path to Makefile from directory path

                if (file.open(QFile::ReadOnly | QFile::Text))
                    file.close();
                else
                    makefile_button_pressed();          //  new Makefile needs to be generated to allow project compilation

                QString binary_path = active_projects[projects->currentIndex() - 1].path;
                binary_path.chop(4);
                QString binary_name = get_filename_from_file_path(binary_path);

                QProcess * process = new QProcess;      //  create new process instance
                process->setWorkingDirectory(directory_path);   //  set appropriate working directory of process
                process->start(terminal, QStringList()
                    << "-e"
                    << QString("bash -c 'make %1 && ./%2 %3; read -p \"\nPress return to continue\"'")
                        .arg(Make)
                        .arg(binary_name)
                        .arg(Run)
                    );                                  //  start process with requested properties
            }
            else if (active_projects[projects->currentIndex() - 1].language == java)
            {
                QRegularExpression regex("void[ \t\n]+main[ \t\n]*[(]");    //  regular expression for block bracket
                regex.optimize();
                int N = active_projects[projects->currentIndex() - 1].files.size();
                int found = N - 1;

                if (regex.isValid())                    //  check if regular expression of rule is valid
                {
                    for (int i = 0; i < N; i++)         //  iterate through all files of project
                    {
                        QString content = "";
                        QFile file(active_projects[projects->currentIndex() - 1].files[i]);

                        if (file.open(QFile::ReadOnly | QFile::Text))   //  file was successfully opened for reading
                        {
                            QTextStream fin(&file);
                            content = fin.readAll();
                            file.close();
                        }

                        remove_comments_and_quotation(content, active_projects[projects->currentIndex() - 1].language);
                        QRegularExpressionMatchIterator match_iter = regex.globalMatch(content);     //  check for global match of regular expression from rule

                        if (match_iter.hasNext())       //  iterate through all regular expression matches
                        {
                            found = i;
                            break;
                        }
                    }
                }

                QString file_path = active_projects[projects->currentIndex() - 1].files[found];
                QString directory_path = get_directory_from_file_path(file_path);
                QString filename = get_filename_from_file_path(file_path);
                QString binary_name = remove_file_extension(filename);

                QProcess * process = new QProcess;      //  create new process instance
                process->setWorkingDirectory(directory_path);   //  set appropriate working directory of process
                process->start(terminal, QStringList()
                    << "-e"
                    << QString("bash -c 'javac %1 %2 && java %3 %4; read -p \"\nPress return to continue\"'")
                        .arg(compile_parameters->text())
                        .arg(filename)
                        .arg(binary_name)
                        .arg(run_parameters->text())
                    );                                  //  start process with requested properties
            }
        }
    }
    else
    {
        save_button_pressed();                          //  save file before continuing
        QString path = source_files->toolTip();
        QString directory_path = get_directory_from_file_path(path);

        if (language->currentIndex() == c99)
        {
            QProcess * process = new QProcess;          //  create new process instance
            process->setWorkingDirectory(directory_path);   //  set appropriate working directory of process
            process->start(terminal, QStringList()
                << "-e"
                << QString("bash -c 'gcc %1 %2 -o a.out -lm && ./a.out %3; read -p \"\nPress return to continue\"'")
                    .arg(compile_parameters->text())
                    .arg(path)
                    .arg(run_parameters->text())
                );                                      //  start process with requested properties
        }
        else if (language->currentIndex() == cplusplus)
        {
            QProcess * process = new QProcess;          //  create new process instance
            process->setWorkingDirectory(directory_path);   //  set appropriate working directory of process
            process->start(terminal, QStringList()
                << "-e"
                << QString("bash -c 'g++ %1 %2 -o a.out -lm && ./a.out %3; read -p \"\nPress return to continue\"'")
                    .arg(compile_parameters->text())
                    .arg(path)
                    .arg(run_parameters->text())
                );                                      //  start process with requested properties
        }
        else if (language->currentIndex() == java)
        {
            QString filename = get_filename_from_file_path(path);
            QString binary_name = remove_file_extension(filename);

            QProcess * process = new QProcess;          //  create new process instance
            process->setWorkingDirectory(directory_path);   //  set appropriate working directory of process
            process->start(terminal, QStringList()
                << "-e"
                << QString("bash -c 'javac %1 %2 && java %3 %4; read -p \"\nPress return to continue\"'")
                    .arg(compile_parameters->text())
                    .arg(filename)
                    .arg(binary_name)
                    .arg(run_parameters->text())
                );                                      //  start process with requested properties
        }
        else if (language->currentIndex() == php)
        {
            QProcess * process = new QProcess;          //  create new process instance
            process->setWorkingDirectory(directory_path);   //  set appropriate working directory of process
            process->start(terminal, QStringList()
                << "-e"
                << QString("bash -c 'php %1 %2 %3; read -p \"\nPress return to continue\"'")
                    .arg(compile_parameters->text())
                    .arg(path)
                    .arg(run_parameters->text())
                );                                      //  start process with requested properties
        }
        else if (language->currentIndex() == python)
        {
            QProcess * process = new QProcess;          //  create new process instance
            process->setWorkingDirectory(directory_path);   //  set appropriate working directory of process
            process->start(terminal, QStringList()
                << "-e"
                << QString("bash -c 'python3 %1 %2 %3; read -p \"\nPress return to continue\"'")
                    .arg(compile_parameters->text())
                    .arg(path)
                    .arg(run_parameters->text())
                );                                      //  start process with requested properties
        }
    }
}


/// Handle press of build button
void Spade::build_button_pressed()
{
    if (isWindows)
        return;                                         //  project executing on Windows will be supported in the future

    if (projects->currentIndex())                       //  check if there is at least one opened project
    {
        if (source_files->count())
        {
            QString terminal = terminal_name->text();

            if (active_projects[projects->currentIndex() - 1].language == c99 || active_projects[projects->currentIndex() - 1].language == cplusplus)
            {
                int N = active_projects[projects->currentIndex() - 1].files.size();

                for (int i = 0; i < N; i++)
                {
                    QString path = active_projects[projects->currentIndex() - 1].files[i];
                    int tabs_size = active_tabs.size();

                    for (int j = 0; j < tabs_size; j++)     //  check if desired file to open is not already opened is text editor
                    {
                        if (active_tabs[j].file_path == path)
                        {
                            if (j == files->currentIndex())
                                save_button_pressed();
                            else
                            {
                                if (active_tabs[j].saved)   //  do nothing when content of actual tab is saved on disk
                                    break;

                                active_tabs[j].saved = true;

                                QFile file(path);

                                if (file.open(QFile::WriteOnly | QFile::Text | QFile::Truncate))    //  open file for writing
                                {
                                    QTextStream fout(&file);
                                    fout << editor[active_tabs[j].index_in_tabs].document()->toPlainText();     //  save content from text editor tab into appropriate file
                                    file.close();
                                }

                                editor[active_tabs[j].index_in_tabs].save_content();    //  call special method from code editor to handle file save
                            }

                            break;
                        }
                    }
                }

                QString Make = make_parameters->text();
                QString directory_path = get_directory_from_file_path(active_projects[projects->currentIndex() - 1].path);

                if (directory_path.right(1) != "/")     //  check if directory contains trailing slash character
                    directory_path.push_back('/');

                QFile file(directory_path + "Makefile");    //  create path to Makefile from directory path

                if (file.open(QFile::ReadOnly | QFile::Text))
                    file.close();
                else
                    makefile_button_pressed();          //  new Makefile needs to be generated to allow project compilation

                QProcess * process = new QProcess;      //  create new process instance
                process->setWorkingDirectory(directory_path);   //  set appropriate working directory of process
                process->start(terminal, QStringList()
                    << "-e"
                    << QString("bash -c 'make %1; read -p \"\nPress return to continue\"'").arg(Make)
                    );
            }
            else if (active_projects[projects->currentIndex() - 1].language == java)
            {
                QRegularExpression regex("void[ \t\n]+main[ \t\n]*[(]");    //  regular expression for block bracket
                regex.optimize();
                int N = active_projects[projects->currentIndex() - 1].files.size();
                int found = N - 1;

                if (regex.isValid())                    //  check if regular expression of rule is valid
                {
                    for (int i = 0; i < N; i++)         //  iterate through all files of project
                    {
                        QString content = "";
                        QFile file(active_projects[projects->currentIndex() - 1].files[i]);

                        if (file.open(QFile::ReadOnly | QFile::Text))   //  file was successfully opened for reading
                        {
                            QTextStream fin(&file);
                            content = fin.readAll();
                            file.close();
                        }

                        remove_comments_and_quotation(content, active_projects[projects->currentIndex() - 1].language);
                        QRegularExpressionMatchIterator match_iter = regex.globalMatch(content);     //  check for global match of regular expression from rule

                        if (match_iter.hasNext())       //  iterate through all regular expression matches
                        {
                            found = i;
                            break;
                        }
                    }
                }

                QString file_path = active_projects[projects->currentIndex() - 1].files[found];
                QString directory_path = get_directory_from_file_path(file_path);
                QString filename = get_filename_from_file_path(file_path);

                QProcess * process = new QProcess;      //  create new process instance
                process->setWorkingDirectory(directory_path);   //  set appropriate working directory of process
                process->start(terminal, QStringList()
                    << "-e"
                    << QString("bash -c 'javac %1 %2; read -p \"\nPress return to continue\"'")
                        .arg(compile_parameters->text())
                        .arg(filename)
                    );                                  //  start process with requested properties
            }
        }
    }
}


/// Handle press of clean button
void Spade::clean_button_pressed()
{
    if (projects->currentIndex())                       //  check if there is at least one opened project
    {
        if (active_projects[projects->currentIndex() - 1].language == c99 || active_projects[projects->currentIndex() - 1].language == cplusplus)
        {
            QString directory_path = get_directory_from_file_path(active_projects[projects->currentIndex() - 1].path);

            if (directory_path.right(1) != "/")         //  check if directory contains trailing slash character
                directory_path.push_back('/');

            QFile file(directory_path + "Makefile");    //  create path to Makefile from directory path

            if (file.open(QFile::ReadOnly | QFile::Text))
                file.close();
            else
                makefile_button_pressed();              //  new Makefile needs to be generated to allow project compilation

            QProcess * process = new QProcess;          //  create new process instance
            process->setWorkingDirectory(directory_path);   //  set appropriate working directory of process
            process->start("make clean");               //  use clean command of make
        }
        else if (active_projects[projects->currentIndex() - 1].language == java)
        {
            QString directory_path = get_directory_from_file_path(active_projects[projects->currentIndex() - 1].path);

            QDir dir(directory_path);
            dir.setNameFilters(QStringList() << "*.class");
            dir.setFilter(QDir::Files);

            foreach(QString dirFile, dir.entryList())
                dir.remove(dirFile);
        }
    }
}


/// Handle press of seventh back button
void Spade::back_button_7_pressed()
{
    hide_projects_tray();                               //  hide project tray
    show_tray();                                        //  show main tray

    projects_tray_visible = false;                      //  refresh values of appropriate flags
    tray_visible = true;
}


/// Handle press of eighth back button
void Spade::back_button_8_pressed()
{
    hide_parameters_tray();                             //  hide parameters tray
    show_projects_tray();                               //  show projects tray

    parameters_tray_visible = false;                    //  refresh values of appropriate flags
    projects_tray_visible = true;

    if (projects->currentIndex())                       //  check if there is at least one opened project
    {
        active_projects[projects->currentIndex() - 1].run_arguments = run_parameters->text();
        active_projects[projects->currentIndex() - 1].compile_arguments = compile_parameters->text();
        active_projects[projects->currentIndex() - 1].make_arguments = make_parameters->text();

        QFile project_file(active_projects[projects->currentIndex() - 1].path);

        if (project_file.open(QFile::WriteOnly | QFile::Text | QFile::Truncate))    //  project file was successfully opened for writing
        {
            QTextStream fout(&project_file);            //  create output text stream to allows writing into project file

            fout << active_projects[projects->currentIndex() - 1].language << char(29);
            fout << active_projects[projects->currentIndex() - 1].run_arguments << char(29);
            fout << active_projects[projects->currentIndex() - 1].compile_arguments << char(29);
            fout << active_projects[projects->currentIndex() - 1].make_arguments << char(29);
            int N = active_projects[projects->currentIndex() - 1].files.size();

            for (int i = 0; i < N; i++)
                fout << active_projects[projects->currentIndex() - 1].files[i] << char(29);

            project_file.close();                       //  close opened project file
        }
    }
}


/// Handle selection of active file
///
/// @param  Index of concrete file as an integer
void Spade::file_selected(int index)
{
    files->setCurrentIndex(index);                      //  refresh index of files combo box
    files->setToolTip(active_tabs[index].file_path);    //  refresh tooltip of files combo box
    ui->tabs->setCurrentIndex(active_tabs[index].index_in_tabs);    //  refresh index in text editor tabs
    languages->setCurrentIndex(active_tabs[index].language);    //  refresh index of languages combo box

    setWindowTitle(QString("%1 - Spade").arg(active_tabs[index].file_path));    //  refresh window title to path to opened file in active tab

    if (active_tabs[index].language == plain_text)      //  refresh comment button icon and tooltip by the language type
    {
        comments_button->setIcon(* comments_on_icon);
        comments_button->setDisabled(true);
    }
    else
    {
        comments_button->setEnabled(true);

        if (active_tabs[index].comments)                //  check comments visibility
            comments_button->setIcon(* comments_on_icon);
        else
            comments_button->setIcon(* comments_off_icon);
    }

    if (active_tabs[index].scroll_bars)                 //  refresh scroll bars button icon
        scroll_bars_button->setIcon(* scroll_bars_on_icon);
    else
        scroll_bars_button->setIcon(* scroll_bars_off_icon);

    if (active_tabs[index].saved)                       //  refresh save button icon
        close_tab_button->setIcon(* close_icon);
    else
        close_tab_button->setIcon(* warning_icon);

    switch (active_tabs[index].font_size)               //  calculate font combo box index by the actual font size of actual tab
    {
        case 6:
            font_size->setCurrentIndex(0);
            break;
        case 7:
            font_size->setCurrentIndex(1);
            break;
        case 8:
            font_size->setCurrentIndex(2);
            break;
        case 9:
            font_size->setCurrentIndex(3);
            break;
        case 10:
            font_size->setCurrentIndex(4);
            break;
        case 11:
            font_size->setCurrentIndex(5);
            break;
        case 12:
            font_size->setCurrentIndex(6);
            break;
        case 13:
            font_size->setCurrentIndex(7);
            break;
        case 14:
            font_size->setCurrentIndex(8);
            break;
        case 15:
            font_size->setCurrentIndex(9);
            break;
        case 16:
            font_size->setCurrentIndex(10);
            break;
        case 17:
            font_size->setCurrentIndex(11);
            break;
        case 18:
            font_size->setCurrentIndex(12);
            break;
        case 20:
            font_size->setCurrentIndex(13);
            break;
        case 22:
            font_size->setCurrentIndex(14);
            break;
        case 24:
            font_size->setCurrentIndex(15);
            break;
        case 26:
            font_size->setCurrentIndex(16);
            break;
        case 28:
            font_size->setCurrentIndex(17);
            break;
        case 32:
            font_size->setCurrentIndex(18);
            break;
        case 36:
            font_size->setCurrentIndex(19);
            break;
        case 40:
            font_size->setCurrentIndex(20);
            break;
        case 44:
            font_size->setCurrentIndex(21);
            break;
        case 48:
            font_size->setCurrentIndex(22);
            break;
        case 54:
            font_size->setCurrentIndex(23);
            break;
        case 60:
            font_size->setCurrentIndex(24);
            break;
        case 66:
            font_size->setCurrentIndex(25);
            break;
        case 72:
            font_size->setCurrentIndex(26);
            break;
        case 80:
            font_size->setCurrentIndex(27);
            break;
        case 88:
            font_size->setCurrentIndex(28);
            break;
        default:
            font_size->setCurrentIndex(29);
            break;
    }

    tab_width->setCurrentIndex(active_tabs[index].tab_width - 1);

    refresh_undo_redo_buttons();                        //  refresh undo and redo buttons

    if (projects->currentIndex() == 0)
    {
        source_files->clear();
        source_files->addItem(active_tabs[index].file_name);
        source_files->setToolTip(active_tabs[index].file_path);
        source_files->setItemData(0, active_tabs[index].file_path, Qt::ToolTipRole);

        if (languages->currentIndex() <= python)
            language->setCurrentIndex(languages->currentIndex());

        if (class_tree_visible)                         //  check if class tree is already visible
            text_change_timer->start(3000);             //  refresh class tree content with appropriate delay
    }
}


/// Handle press of save button
void Spade::save_button_pressed()
{
    if (active_tabs[files->currentIndex()].file_path == "New tab")
    {
        QString default_filename = "untitled";

        if (active_tabs[files->currentIndex()].language == c99)
            default_filename = "untitled.c";
        else if (active_tabs[files->currentIndex()].language == cplusplus)
            default_filename = "untitled.cpp";
        else if (active_tabs[files->currentIndex()].language == java)
            default_filename = "untitled.java";
        else if (active_tabs[files->currentIndex()].language == php)
            default_filename = "untitled.php";
        else if (active_tabs[files->currentIndex()].language == plain_text)
            default_filename = "untitled.txt";
        else if (active_tabs[files->currentIndex()].language == python)
            default_filename = "untitled.py";

        QString path = file_dialog->getSaveFileName
        (
            this,                                       //  parent
            "Save file",                                //  file dialog title
            default_filename                            //  filename preset
        );

        if (path.isEmpty() || path.isNull())            //  check if file was successfully selected from file dialog
            return;

        QFile file(path);

        if (file.open(QFile::WriteOnly | QFile::Text | QFile::Truncate))    //  open source file for reading
        {                                               //  save content of actual tab into file
            QTextStream fout(&file);
            fout << editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText();
            file.close();
        }

        QString file_name = get_filename_from_file_path(path);
        editor[active_tabs[files->currentIndex()].index_in_tabs].file_path = path;  //  refresh file path variable code editor
        files->setItemData(files->currentIndex(), path, Qt::ToolTipRole);
        files->setItemText(files->currentIndex(), file_name);   //  refresh actual item in files combo box
        files->setToolTip(path);

        active_tabs[files->currentIndex()].file_path = path;    //  refresh file path and file name attributes on actual active tabs array index
        active_tabs[files->currentIndex()].file_name = file_name;

        active_tabs[files->currentIndex()].saved = true;
        close_tab_button->setIcon(* close_icon);

        editor[active_tabs[files->currentIndex()].index_in_tabs].save_content();    //  call special method from code editor to handle file save

        files_watcher->addPath(path);                   //  push new file path into file system watcher
        setWindowTitle(QString("%1 - Spade").arg(path));    //  refresh window title to path to opened file in active tab

        if (projects->currentIndex() == 0)
        {
            source_files->clear();
            source_files->addItem(file_name);
            source_files->setToolTip(path);
            source_files->setItemData(0, path, Qt::ToolTipRole);

            if (languages->currentIndex() == c99)
                language->setCurrentIndex(c99);
            else if (languages->currentIndex() == cplusplus)
                language->setCurrentIndex(cplusplus);
            else if (languages->currentIndex() == java)
                language->setCurrentIndex(java);
            else if (languages->currentIndex() == php)
                language->setCurrentIndex(php);
            else if (languages->currentIndex() == plain_text)
                language->setCurrentIndex(plain_text);
            else if (languages->currentIndex() == python)
                language->setCurrentIndex(python);
        }
    }
    else
    {
        if (active_tabs[files->currentIndex()].saved)   //  do nothing when content of actual tab is saved on disk
            return;

        active_tabs[files->currentIndex()].saved = true;
        close_tab_button->setIcon(* close_icon);        //  refresh icon of save button

        QFile file(active_tabs[files->currentIndex()].file_path);   //  get file path from attributes of actual tab

        if (file.open(QFile::WriteOnly | QFile::Text | QFile::Truncate))    //  open source file for reading
        {                                               //  save content of actual tab into file
            QTextStream fout(&file);
            fout << editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText();
            file.close();
        }

        editor[active_tabs[files->currentIndex()].index_in_tabs].save_content();    //  call special method from code editor to handle file save
    }
}


/// Handle press of file button
void Spade::file_button_pressed()
{
    hide_tray();                                        //  hide main tray
    show_file_tray();                                   //  show file tray

    tray_visible = false;                               //  refresh values of appropriate flags
    file_tray_visible = true;
}


/// Handle press of close tab button
void Spade::close_tab_button_pressed()
{
    if (vim_tray_visible)
        return;

    if (active_tabs[files->currentIndex()].saved == false)  //  file content is not saved
    {                                                   //  ask user if save file before closing
        QString content = active_tabs[files->currentIndex()].file_path;
        content += "\n\nSave changes into file before closing?";

        int result = QMessageBox::information(this, "Spade", content, QMessageBox::Yes | QMessageBox::No | QMessageBox::Cancel);

        if (result == QMessageBox::Yes)
            save_button_pressed();                      //  save file content before closing
        else if (result == QMessageBox::Cancel)
            return;
    }

    if (active_tabs.size() == 1)                        //  there is only one active tab in text editor
    {
        active_tabs.clear();                            //  clear active tabs array
        emit exit_signal();                             //  call exit method to provide correct exit of application
    }
    else                                                //  there are many active tabs in text editor
    {
        int to_remove = files->currentIndex();          //  save value of index, which have to be deleted

        if (active_tabs[to_remove].file_path != "New tab")
            files_watcher->removePath(active_tabs[to_remove].file_path);    //  remove file path of actual tab from file system watcher

        int N = active_tabs.size();

        if (to_remove == N - 1)                         //  actual tab is on last position of files combo box
        {
            active_tabs.pop_back();                     //  remove last tab from active tabs array
            files->removeItem(to_remove);               //  remove last tab from files combo box
            file_selected(to_remove - 1);               //  change actual index of active tabs array
            return;
        }

        vector<Tab_details> temp;

        for (int i = 0; i < N; i++)                     //  remove actual tab from active tabs array
        {
            if (i != to_remove)
                temp.push_back(active_tabs[i]);
        }

        active_tabs = temp;
        files->removeItem(to_remove);                   //  remove actual tab from files combo box
        file_selected(to_remove);                       //  change actual index of active tabs array
    }
}


/// Handle press of project button
void Spade::project_button_pressed()
{
    hide_tray();                                        //  hide main tray
    show_projects_tray();                               //  show projecs tray

    tray_visible = false;                               //  refresh values of appropriate flags
    projects_tray_visible = true;
}


/// Handle selection of font size
///
/// @param  Index of font size as an integer value
void Spade::font_size_selected(int font_index)
{
    font_size->setCurrentIndex(font_index);             //  get current index of font combo box

    int actual = files->currentIndex();
    int editor_index = active_tabs[actual].index_in_tabs;
    int size = 10;
                                                        //  refresh font size of actual tab by the font combo box index
    if (font_index == 0)
        size = 6;
    else if (font_index == 1)
        size = 7;
    else if (font_index == 2)
        size = 8;
    else if (font_index == 3)
        size = 9;
    else if (font_index == 4)
        size = 10;
    else if (font_index == 5)
        size = 11;
    else if (font_index == 6)
        size = 12;
    else if (font_index == 7)
        size = 13;
    else if (font_index == 8)
        size = 14;
    else if (font_index == 9)
        size = 15;
    else if (font_index == 10)
        size = 16;
    else if (font_index == 11)
        size = 17;
    else if (font_index == 12)
        size = 18;
    else if (font_index == 13)
        size = 20;
    else if (font_index == 14)
        size = 22;
    else if (font_index == 15)
        size = 24;
    else if (font_index == 16)
        size = 26;
    else if (font_index == 17)
        size = 28;
    else if (font_index == 18)
        size = 32;
    else if (font_index == 19)
        size = 36;
    else if (font_index == 20)
        size = 40;
    else if (font_index == 21)
        size = 44;
    else if (font_index == 22)
        size = 48;
    else if (font_index == 23)
        size = 54;
    else if (font_index == 24)
        size = 60;
    else if (font_index == 25)
        size = 66;
    else if (font_index == 26)
        size = 72;
    else if (font_index == 27)
        size = 80;
    else if (font_index == 28)
        size = 88;
    else
        size = 96;

    active_tabs[actual].font_size = size;
    font.setPointSize(size);
    editor[editor_index].setFont(font);                 //  refresh font size in actual tab of text editor
    QFontMetrics metrics(editor[editor_index].font());  //  refresh tab width to appropriate value using font metrics
    editor[editor_index].setTabStopWidth(active_tabs[actual].tab_width * metrics.width(' '));
}


/// Handle press of scroll bars button
void Spade::scroll_bars_button_pressed()
{                                                       //  toggle visibility of scroll bars in actual tab of text editor
    int index_in_tabs = active_tabs[files->currentIndex()].index_in_tabs;   //  get actual index of text editor tabs

    if (active_tabs[files->currentIndex()].scroll_bars)     //  scroll bars of actual tab are visible
    {                                                   //  make scroll bars of actual tab hidden
        editor[index_in_tabs].setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        editor[index_in_tabs].setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        scroll_bars_button->setIcon(* scroll_bars_off_icon);
    }
    else                                                //  scroll bars of actual tab are hidden
    {                                                   //  make scroll bars of actual tab visible
        editor[index_in_tabs].setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
        editor[index_in_tabs].setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded);
        scroll_bars_button->setIcon(* scroll_bars_on_icon);
    }
                                                        //  invert scroll bars flag value
    active_tabs[files->currentIndex()].scroll_bars = !active_tabs[files->currentIndex()].scroll_bars;
}


/// Handle press of comments button
void Spade::comments_button_pressed()
{
    int actual = files->currentIndex();                 //  get actual index of files combo box
    int index = active_tabs[actual].index_in_tabs;

    active_tabs[actual].comments = !active_tabs[actual].comments;   //  invert comment flag value of actual tab in text editor

    highlighters[index]->applyRules(&(user_languages[active_tabs[actual].language - builtInLanguages]), active_tabs[actual].language, active_tabs[actual].comments, active_tabs[actual].theme);
                                                        //  allocate memory for new syntax highlighter with inverted comments visibility
    if (active_tabs[actual].comments)                   //  refresh icon of scroll bars push button
        comments_button->setIcon(* comments_on_icon);
    else
        comments_button->setIcon(* comments_off_icon);
}


/// Handle press of paint button
void Spade::paint_button_pressed()
{
    hide_tray();                                        //  hide main tray
    show_paint_tray();                                  //  show paint tray

    tray_visible = false;                               //  refresh values of appropriate flags
    paint_tray_visible = true;
}


/// Handle press of theme button
void Spade::theme_button_pressed()
{
    hide_tray();                                        //  hide main tray
    show_theme_tray();                                  //  show theme tray

    tray_visible = false;                               //  refresh values of appropriate flags
    theme_tray_visible = true;
}


/// Handle selection of active file language
///
/// @param  Index of concrete language as an integer value
void Spade::language_selected(int language)
{
    int actual = files->currentIndex();                 //  get actual index of files combo box
    int index = active_tabs[actual].index_in_tabs;

    if (language == plain_text)                         //  selected language is plain text
    {
        comments_button->setIcon(* comments_on_icon);
        comments_button->setDisabled(true);
    }
    else                                                //  selected language is not plain text
    {
        comments_button->setEnabled(true);

        if (active_tabs[actual].comments)
            comments_button->setIcon(* comments_on_icon);
        else
            comments_button->setIcon(* comments_off_icon);
    }

    int old_language = active_tabs[actual].language;    //  get language of actual tab of text editor

    if (old_language != language)                       //  selected language is different than actual language
    {
        highlighters[index]->applyRules(&(user_languages[language - builtInLanguages]), language, active_tabs[actual].comments, active_tabs[actual].theme);

        active_tabs[actual].language = language;        //  refresh value of language variable
        refresh_extra_selections(actual);               //  refresh extra selections in actual tab of text editor
    }
}


/// Handle press of template button
void Spade::template_button_pressed()
{
    hide_tray();                                        //  hide main tray
    show_template_tray();                               //  show template tray

    tray_visible = false;                               //  refresh values of appropriate flags
    template_tray_visible = true;
}


/// Handle press of menu button
void Spade::menu_button_pressed()
{
    hide_tray();                                        //  hide main tray
    show_actions_tray();                                //  show actions tray

    tray_visible = false;                               //  refresh values of appropriate flags
    actions_tray_visible = true;
}


/// Handle press of fullscreen button
void Spade::fullscreen_button_pressed()
{
    emit fullscreen_signal();
}


/// Handle background change of file
///
/// @param  Changed file is specified using its path as a string value
void Spade::handle_file_change(const QString & path)
{
    int file_index = -1;
    int N = active_tabs.size();

    for (int i = 0; i < N; i++)
    {
        if (active_tabs[i].file_path == path)           //  find tab which file content was changed on disk in background
        {
            file_index = i;
            break;
        }
    }

    if (file_index < 0)
        return;

    QString file_content = "";
    QFile file(active_tabs[file_index].file_path);

    if (file.open(QFile::ReadOnly | QFile::Text))       //  open changed file for reading
    {
        QTextStream fin(&file);
        file_content = fin.readAll();                   //  read changed content from file
        file.close();
    }
                                                        //  file content is different from content in text editor tab
    if (file_content != editor[active_tabs[file_index].index_in_tabs].document()->toPlainText())
    {
        if (active_tabs[file_index].saved)
        {
            active_tabs[file_index].saved = false;      //  invert saved flag value

            if (file_index == files->currentIndex())    //  refresh icon of close push button
                close_tab_button->setIcon(* warning_icon);
        }
    }
    else                                                //  file content is same as content in text editor tab
    {
        if (active_tabs[file_index].saved == false)
        {
            active_tabs[file_index].saved = true;       //  invert saved flag value

            if (file_index == files->currentIndex())    //  refresh icon of close push button
                close_tab_button->setIcon(* close_icon);
        }
    }
}


/// Handle press of direct find button
void Spade::find_now()
{                                                       //  hide visible tray and invert appropriate flag value
    if (vim_tray_visible)
        return;

    if (theme_tray_visible)
    {
        if (interface_visible)                          //  hide theme tray if visual interface is visible
            hide_theme_tray();

        theme_tray_visible = false;
    }
    else if (file_tray_visible)
    {
        if (interface_visible)                          //  hide file tray if visual interface is visible
            hide_file_tray();

        file_tray_visible = false;
    }
    else if (paint_tray_visible)
    {
        if (interface_visible)                          //  hide paint tray if visual interface is visible
            hide_paint_tray();

        paint_tray_visible = false;
    }
    else if (actions_tray_visible)
    {
        if (interface_visible)                          //  hide actions tray if visual interface is visible
            hide_actions_tray();

        actions_tray_visible = false;
    }
    else if (template_tray_visible)
    {
        if (interface_visible)                          //  hide actions tray if visual interface is visible
            hide_template_tray();

        template_tray_visible = false;
    }
    else if (find_tray_visible && interface_visible)
        return;
    else
    {
        if (interface_visible)                          //  hide main tray if visual interface is visible
            hide_tray();

        tray_visible = false;
    }

    if (interface_visible == false)
        interface_visible = true;

    show_find_tray();                                   //  show find tray and set find flag
    find_tray_visible = true;
}


/// Handle press of comment toggle button
void Spade::toggle_comment()
{
    int language = active_tabs[files->currentIndex()].language;     //  get language of actual text editor tab

    int index = active_tabs[files->currentIndex()].index_in_tabs;
    int from = editor[index].textCursor().selectionStart();     //  get coordinates of cursor selection
    int to = editor[index].textCursor().selectionEnd();
    QString content = editor[index].document()->toPlainText();  //  get text content of actual tab in text editor

    while (from - 1 >= 0 && content[from - 1] != '\n')  //  move starting selection position to beginning of appropriate line
        from--;

    vector<int> values;
    int N = content.size();

    for (int i = from; i <= to; i++)                    //  get number of lines affected by cursor selection
    {
        if ((content[i - 1] == '\n' || i == 0) && i < N && content[i] != '\n')
            values.push_back(i);
    }

    N = values.size();

    if (N)                                              //  at least one line is affected by cursor selection
    {
        * text_cursor = editor[index].textCursor();

        bool all_commented = true;

        if (language != python)                         //  active language of actual text editor tab is not Python
        {
            for (int i = N - 1; i >= 0; i--)            //  iterate through all affected lines
            {
                if (content[values[i]] != '/' || content[values[i] + 1] != '/')     //  check if actual line already commented
                {
                    all_commented = false;
                    break;
                }
            }
        }
        else                                            //  active language of actual text editor tab is Python
        {
            for (int i = N - 1; i >= 0; i--)            //  iterate through all affected lines
            {
                if (content[values[i]] != '#')          //  check if actual line already commented
                {
                    all_commented = false;
                    break;
                }
            }
        }

        if (all_commented)                              //  all selected lines are commented
        {
            for (int i = N - 1; i >= 0; i--)            //  iterate through all affected lines
            {
                text_cursor->setPosition(values[i]);    //  highlight last match of file content by text cursor selection
                                                        //  select comment character using text cursor(select range set by language of document)
                if (language != python)
                    text_cursor->setPosition(values[i] + 2, QTextCursor::KeepAnchor);
                else
                    text_cursor->setPosition(values[i] + 1, QTextCursor::KeepAnchor);

                editor[index].setTextCursor(* text_cursor);
                editor[index].insertPlainText("");      //  insert empty string to remove comment characters
            }

            text_cursor->setPosition(from);             //  highlight last match of file content by text cursor selection
                                                        //  refresh cursor selection range by updated text size(check language of document)
            if (language != python)
                text_cursor->setPosition(to - 2 * N, QTextCursor::KeepAnchor);
            else
                text_cursor->setPosition(to - N, QTextCursor::KeepAnchor);
        }
        else                                            //  some selected lines are not commented
        {
            for (int i = N - 1; i >= 0; i--)            //  iterate through all affected lines
            {
                text_cursor->setPosition(values[i]);    //  highlight last match of file content by text cursor selection
                text_cursor->setPosition(values[i], QTextCursor::KeepAnchor);
                editor[index].setTextCursor(* text_cursor);
                                                        //  insert appropriate character to beginning of all affected lines
                if (language != python)                 //  push characters which will create comment from actual line
                    editor[index].insertPlainText("//");
                else
                    editor[index].insertPlainText("#");
            }

            text_cursor->setPosition(from);             //  highlight last match of file content by text cursor selection
                                                        //  refresh cursor selection range by updated text size
            if (language != python)
                text_cursor->setPosition(to + 2 * N, QTextCursor::KeepAnchor);
            else
                text_cursor->setPosition(to + 1 * N, QTextCursor::KeepAnchor);
        }

        editor[index].setTextCursor(* text_cursor);
    }
}


/// Handle press of font increase button
void Spade::increase_font_size()
{
    int index = font_size->currentIndex() + 1;          //  increase font size value

    if (index < font_size->count())                     //  check index overflow
        font_size_selected(index);                      //  handle font size change using appropriate method
}


/// Handle press of font decrease button
void Spade::decrease_font_size()
{
    int index = font_size->currentIndex();

    if (index)                                          //  check index underflow
    {
        index--;                                        //  decrease font size value
        font_size_selected(index);                      //  handle font size change using appropriate method
    }
}


/// Handle press of move tab up button
void Spade::move_tab_up()
{
    if (theme_tray_visible || template_tray_visible || vim_tray_visible)
        return;

    int index = files->currentIndex();

    if (index)                                          //  check index underflow
    {
        index--;                                        //  decrease files combo box index value
        file_selected(index);                           //  handle actual tab change using appropriate method
    }
}


/// Handle press of move tab down button
void Spade::move_tab_down()
{
    if (theme_tray_visible || template_tray_visible || vim_tray_visible)
        return;

    int index = files->currentIndex() + 1;              //  increase files combo box index value

    if (index < files->count())                         //  check index overflow
        file_selected(index);                           //  handle actual tab change using appropriate method
}


/// Handle press of scrollbar up button
void Spade::move_scrollbar_up()
{                                                       //  move vertical scroll bar position in actual tab up
    int index = active_tabs[files->currentIndex()].index_in_tabs;
    editor[index].verticalScrollBar()->setValue(editor[index].verticalScrollBar()->value() - 1);
}


/// Handle press of scrollbar down button
void Spade::move_scrollbar_down()
{                                                       //  move vertical scroll bar position in actual tab down
    int index = active_tabs[files->currentIndex()].index_in_tabs;
    editor[index].verticalScrollBar()->setValue(editor[index].verticalScrollBar()->value() + 1);
}


/// Handle press of tab key and insert appropriate indentiation to text file
void Spade::handle_tab_press()
{
    int index = active_tabs[files->currentIndex()].index_in_tabs;
    int from = editor[index].textCursor().selectionStart();     //  get coordinates of cursor selection
    int to = editor[index].textCursor().selectionEnd();
    QString content = editor[index].document()->toPlainText();  //  get text content of actual tab in text editor

    while (from - 1 >= 0 && content[from - 1] != '\n')  //  move starting selection position to beginning of appropriate line
        from--;

    vector<int> values;
    int N = content.size();

    for (int i = from; i <= to; i++)                    //  get number of lines affected by cursor selection
    {
        if ((content[i - 1] == '\n' || i == 0) && i < N && content[i] != '\n')
            values.push_back(i);
    }

    N = values.size();

    if (N >= 2)                                         //  at least two lines are affected by cursor selection
    {
        * text_cursor = editor[index].textCursor();

        for (int i = N - 1; i >= 0; i--)                //  iterate through all affected lines
        {
            text_cursor->setPosition(values[i]);        //  move cursor to beginning of actual line
            text_cursor->setPosition(values[i], QTextCursor::KeepAnchor);
            editor[index].setTextCursor(* text_cursor);
            editor[index].insertPlainText("\t");        //  insert tab character to beginning of all affected lines
        }

        text_cursor->setPosition(from);                 //  refresh cursor selection range by updated text size
        text_cursor->setPosition(to + N, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else                                                //  just single line is affected by cursor selection
        editor[index].insertPlainText("\t");            //  just insert tab character
}


/// Handle press of untab button and remove appropriate indentiation from text file
void Spade::handle_shift_tab_press()
{
    int index = active_tabs[files->currentIndex()].index_in_tabs;
    int from = editor[index].textCursor().selectionStart();     //  get coordinates of cursor selection
    int to = editor[index].textCursor().selectionEnd();
    QString content = editor[index].document()->toPlainText();  //  get text content of actual tab in text editor

    while (from - 1 >= 0 && content[from - 1] != '\n')  //  move starting selection position to beginning of appropriate line
        from--;

    vector<int> values;
    int N = content.size();

    for (int i = from; i <= to; i++)                    //  get number of lines affected by cursor selection
    {
        if ((content[i - 1] == '\n' || i == 0) && i < N && content[i] != '\n')
            values.push_back(i);
    }

    N = values.size();

    if (N >= 2)                                         //  at least two lines are affected by cursor selection
    {
        * text_cursor = editor[index].textCursor();

        int count = 0;                                  //  holds number of successfully removed white characters

        for (int i = N - 1; i >= 0; i--)                //  iterate through all affected lines
        {
            text_cursor->setPosition(values[i]);        //  move cursor to beginning of actual line
            text_cursor->setPosition(values[i], QTextCursor::KeepAnchor);
            editor[index].setTextCursor(* text_cursor);
                                                        //  remove tab character to beginning of all affected lines
            if (content[values[i]] == '\t' || content[values[i]] == ' ')
            {
                editor[index].textCursor().deleteChar();
                count++;                                //  tab character cannot be removed if there is no tab character at beginning of line
            }
        }

        text_cursor->setPosition(from);                 //  refresh cursor selection range by updated text size
        text_cursor->setPosition(to - count, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);
    }
    else                                                //  just single line is affected by cursor selection
    {
        if (editor[index].textCursor().selectionStart() == to)  //  no cursor selection is present
        {
            if (to && content[to - 1] == '\t')
                editor[index].textCursor().deletePreviousChar();    //  just delete character before actual cursor position
        }
        else
            editor[index].insertPlainText("");          //  remove all characters affected by cursor selection
    }
}


/// Handle press of return key
void Spade::handle_enter_press()
{
    int actual = files->currentIndex();
    int index = active_tabs[actual].index_in_tabs;      //  get index of actual text editor tab

    QString content = editor[index].document()->toPlainText();  //  get text content of actual text editor tab
    int N = content.size();
    int position = editor[index].textCursor().position();   //  get actual text cursor position

    if (position && (content[position - 1] == '(' || content[position - 1] == '{' || content[position - 1] == '['))
    {                                                   //  text cursor is exactly after left matching bracket
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        QString pattern;
        int move = 1;
                                                        //  check if left matching bracket is immediately followed by right bracket
        if (content[position] == ')' || content[position] == '}' || content[position] == ']')
            pattern = "\n" + offset + "\t\n" + offset;  //  just insert appropriate offset characters inside matching brackets
        else
        {                                               //  insert appropriate offset characters and insert right closing bracket
            if (content[position - 1] == '(')
                pattern = "\n" + offset + "\t\n" + offset + ")";
            else if (content[position - 1] == '{')
                pattern = "\n" + offset + "\t\n" + offset + "}";
            else
                pattern = "\n" + offset + "\t\n" + offset + "]";

            move++;
        }

        editor[index].insertPlainText(pattern);         //  insert newlines with offset patterns inside matching brackets

        int from = editor[index].textCursor().position() - move - offset.size();

        * text_cursor = editor[index].textCursor();
        text_cursor->setPosition(from);                 //  highlight desired part of template using cursor selection
        text_cursor->setPosition(from, QTextCursor::KeepAnchor);
        editor[index].setTextCursor(* text_cursor);     //  move text cursor between matching brackets
    }
    else if (content[position] == '\n')                 //  cursor is at the end of the line
    {
        int i = position;

        QString line = "";

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
        {
            i--;
            line.push_front(content[i]);                //  push character of the line into string variable
        }

        while (line.size() && (line[0] == ' ' || line[0] == '\t'))
            line.remove(0, 1);                          //  remove white characters from beginning of line string

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        if (active_tabs[actual].language == c99 || active_tabs[actual].language == java ||
            active_tabs[actual].language == php)        //  active language of actual text editor tab is C99 or Java or PHP
        {                                               //  line string is starting with keyword which indicates C99 or Java or PHP block structure
            if ((line.startsWith("case") || line.startsWith("default")) && line.endsWith(":"))
            {                                           //  line string is starting with keyword which indicates command with colon at the end
                offset = "\t" + offset;                 //  just indent next line with one extra tab character
            }
        }
        else if (active_tabs[actual].language == cplusplus)  //  active language of actual text editor tab is C++
        {                                               //  line string is starting with keyword which indicates C++ block structure
            if ((line.startsWith("private") || line.startsWith("protected") || line.startsWith("public") ||
                    line.startsWith("case") || line.startsWith("default")) && line.endsWith(":"))
            {                                           //  line string is starting with keyword which indicates command with colon at the end
                offset = "\t" + offset;                 //  just indent next line with one extra tab character
            }
        }
        else if (active_tabs[actual].language == python)    //  active language of actual text editor tab is Python
        {                                               //  line string is starting with keyword which indicates command with colon at the end
            if ((line.startsWith("if") || line.startsWith("elif") || line.startsWith("else") ||
                line.startsWith("while") || line.startsWith("for") || line.startsWith("try") ||
                line.startsWith("except") || line.startsWith("finally") || line.startsWith("with") ||
                line.startsWith("def") || line.startsWith("class") || line.startsWith("async")) && line.endsWith(":"))
            {
                offset = "\t" + offset;                 //  just indent next line with one extra tab character
            }
        }

        QString pattern = "\n" + offset;
        editor[index].insertPlainText(pattern);         //  insert newline and offset pattern into document
    }
    else
    {
        int i = position;

        while (i - 1 && content[i - 1] != '\n')         //  find beginning of actual line
            i--;

        QString offset = "";

        while (i < N && (content[i] == ' ' || content[i] == '\t'))
        {                                               //  calculate offset from white characters of actual line
            offset.push_back(content[i]);               //  save offset as single string
            i++;
        }

        QString pattern = "\n" + offset;
        editor[index].insertPlainText(pattern);         //  insert newline and offset pattern into document
    }
}


/// Handle press of classic bracket key
void Spade::handle_classic_bracket_press()
{
    int index = active_tabs[files->currentIndex()].index_in_tabs;
    editor[index].insertPlainText("()");                //  insert two matching brackets instead of single left bracket

    int from = editor[index].textCursor().position() - 1;

    * text_cursor = editor[index].textCursor();
    text_cursor->setPosition(from);                     //  highlight desired part of template using cursor selection
    text_cursor->setPosition(from, QTextCursor::KeepAnchor);
    editor[index].setTextCursor(* text_cursor);         //  move text cursor into inserted matching brackets
}


/// Handle press of block bracket key
void Spade::handle_block_bracket_press()
{
    int index = active_tabs[files->currentIndex()].index_in_tabs;
    editor[index].insertPlainText("{}");                //  insert two matching brackets instead of single left bracket

    int from = editor[index].textCursor().position() - 1;

    * text_cursor = editor[index].textCursor();
    text_cursor->setPosition(from);                     //  highlight desired part of template using cursor selection
    text_cursor->setPosition(from, QTextCursor::KeepAnchor);
    editor[index].setTextCursor(* text_cursor);         //  move text cursor into inserted matching brackets
}


/// Handle press of array bracket key
void Spade::handle_array_bracket_press()
{
    int index = active_tabs[files->currentIndex()].index_in_tabs;
    editor[index].insertPlainText("[]");                //  insert two matching brackets instead of single left bracket

    int from = editor[index].textCursor().position() - 1;

    * text_cursor = editor[index].textCursor();
    text_cursor->setPosition(from);                     //  highlight desired part of template using cursor selection
    text_cursor->setPosition(from, QTextCursor::KeepAnchor);
    editor[index].setTextCursor(* text_cursor);         //  move text cursor into inserted matching brackets
}


/// Check if keyword represents C language keyword
///
/// @param  Keyword is represented as a string value
bool Spade::is_c99_keyword(QString & content)
{
    if (content == "auto" || content == "char" || content == "bool" || content == "double" ||
        content == "enum" || content == "float" || content == "int" || content == "long" ||
        content == "short" || content == "signed" || content == "struct" || content == "typedef" ||
        content == "union" || content == "unsigned" || content == "void" || content == "break" ||
        content == "case" || content == "const" || content == "continue" || content == "default" ||
        content == "do" || content == "else" || content == "extern" || content == "for" ||
        content == "goto" || content == "if" || content == "inline" || content == "register" ||
        content == "restrict" || content == "return" || content == "sizeof" || content == "static" ||
        content == "switch" || content == "volatile" || content == "while" || content == "#include" ||
        content == "#define" || content == "#undef" || content == "#if" || content == "#ifdef" ||
        content == "#ifndef" || content == "#error" || content == "#pragma")
    {
        return true;                                    //  argument is C99 keyword
    }
    else
        return false;                                   //  argument is not C99 keyword
}


/// Check if keyword represents C++ language keyword
///
/// @param  Keyword is represented as a string value
bool Spade::is_cplusplus_keyword(QString & content)
{
    if (content == "alignas" ||  content == "alignof" || content == "and" || content == "and_eq" ||
        content == "asm" || content == "atomic_cancel" || content == "atomic_commit" || content == "atomic_noexcept" ||
        content == "auto" || content == "bitand" || content == "bitor" || content == "bool" ||
        content == "break" || content == "case" || content == "catch" || content == "char" ||
        content == "char16_t" || content == "char32_t" || content == "class" || content == "compl" ||
        content == "concept" || content == "const" || content == "constexpr" || content == "const_cast" ||
        content == "continue" || content == "decltype" || content == "default" || content == "delete" ||
        content == "do" ||content == "double" ||content == "dynamic_cast" ||content == "else" ||
        content == "enum" ||content == "explicit" || content == "export" || content == "extern" ||
        content == "false" || content == "float" || content == "for" || content == "friend" || content == "goto" ||
        content == "if" || content == "import" || content == "inline" || content == "int" || content == "long" ||
        content == "module" || content == "mutable" || content == "namespace" || content == "new" ||
        content == "noexcept" || content == "not" || content == "not_eq" || content == "nullptr" ||
        content == "operator" || content == "or" || content == "or_eq" || content == "private" ||
        content == "protected" || content == "public" || content == "register" || content == "reinterpret_cast" ||
        content == "requires" || content == "return" || content == "short" || content == "signed" ||
        content == "sizeof" || content == "static" || content == "static_assert" || content == "static_cast" ||
        content == "struct" || content == "switch" || content == "synchronized" || content == "template" ||
        content == "this" || content == "thread_local" || content == "throw" || content == "true" ||
        content == "try" || content == "typedef" || content == "typeid" || content == "typename" ||
        content == "union" || content == "unsigned" || content == "using" || content == "virtual" ||
        content == "void" || content == "volatile" || content == "wchar_t" || content == "while" ||
        content == "xor" || content == "xor_eq" || content == "override" || content == "#if" || content == "#elif" ||
        content == "#else" || content == "#endif" || content == "#defined" || content == "#ifdef" ||
        content == "#ifndef" || content == "#define" ||content == "#undef" || content == "#include" ||
        content == "#line" || content == "#error" || content == "#pragma" || content == "std")
    {
        return true;                                    //  argument is C++ keyword
    }
    else
        return false;                                   //  argument is not C++ keyword
}


/// Check if keyword represents Java language keyword
///
/// @param  Keyword is represented as a string value
bool Spade::is_java_keyword(QString & content)
{
    if (content == "boolean" || content == "double" || content == "byte" || content == "class" ||
        content == "enum" || content == "interface" || content == "int" || content == "short" ||
        content == "char" || content == "void" || content == "long" || content == "volatile" ||
        content == "const" || content == "float" || content == "abstract" || content == "continue" ||
        content == "for" || content == "new" || content == "switch" || content == "assert" ||
        content == "default" || content == "goto" || content == "package" || content == "synchronized" ||
        content == "do" || content == "if" || content == "private" || content == "break" ||
        content == "protected" || content == "throw" || content == "else" || content == "import" ||
        content == "public" || content == "case" || content == "instanceof" || content == "return" ||
        content == "transient" || content == "catch" || content == "try" || content == "final" ||
        content == "static" || content == "finally" || content == "strictfp" || content == "native" ||
        content == "while" || content == "implements" || content == "throws" || content == "extends")
    {
        return true;                                    //  argument is Java keyword
    }
    else
        return false;                                   //  argument is not Java keyword
}


/// Check if keyword represents PHP language keyword
///
/// @param  Keyword is represented as a string value
bool Spade::is_php_keyword(QString & content)
{
    if (content == "array" || content == "class" || content == "clone" || content == "echo" ||
        content == "function" || content == "interface" || content == "print" || content == "var" ||
        content == "int" || content == "float" || content == "bool" || content == "string" ||
        content == "object" || content == "PHP_VERSION" || content == "PHP_MAJOR_VERSION" ||
        content == "PHP_MINOR_VERSION" || content == "PHP_RELEASE_VERSION" || content == "PHP_VERSION_ID" ||
        content == "PHP_EXTRA_VERSION" || content == "PHP_ZTS" || content == "PHP_DEBUG" ||
        content == "PHP_MAXPATHLEN" || content == "PHP_OS" || content == "PHP_SAPI" || content == "PHP_EOL" ||
        content == "PHP_INT_MAX" || content == "PHP_INT_SIZE" || content == "DEFAULT_INCLUDE_PATH" ||
        content == "PEAR_INSTALL_DIR" || content == "PEAR_EXTENSION_DIR" || content == "PHP_EXTENSION_DIR" ||
        content == "PHP_PREFIX" || content == "PHP_BINDIR" || content == "PHP_LIBDIR" ||
        content == "PHP_DATADIR" || content == "PHP_SYSCONFDIR" || content == "PHP_LOCALSTATEDIR" ||
        content == "PHP_CONFIG_FILE_PATH" || content == "PHP_CONFIG_FILE_SCAN_DIR" ||
        content == "PHP_SHLIB_SUFFIX" || content == "E_ERROR" || content == "E_WARNING" ||
        content == "E_PARSE" || content == "E_NOTICE" || content == "E_CORE_ERROR" ||
        content == "E_CORE_WARNING" || content == "E_COMPILE_ERROR" || content == "E_COMPILE_WARNING" ||
        content == "E_USER_ERROR" || content == "E_USER_WARNING" || content == "E_USER_NOTICE" ||
        content == "E_RECOVERABLE_ERROR" || content == "E_DEPRECATED" || content == "E_USER_DEPRECATED" ||
        content == "E_ALL" || content == "E_STRICT" || content == "__COMPILER_HALT_OFFSET__" ||
        content == "STDIN" || content == "STDOUT" || content == "STDERR" || content == "abstract" ||
        content == "and" || content == "as" || content == "break" || content == "case" ||
        content == "catch" || content == "const" || content == "continue" || content == "declare" ||
        content == "default" || content == "die" || content == "do" || content == "else" ||
        content == "elseif" || content == "enddeclare" || content == "endfor" || content == "endforeach" ||
        content == "endif" || content == "endswitch" || content == "endwhile" || content == "exit" ||
        content == "extends" || content == "final" || content == "for" || content == "foreach" ||
        content == "global" || content == "if" || content == "implements" || content == "include" ||
        content == "include_once" || content == "namespace" || content == "new" || content == "or" ||
        content == "private" || content == "protected" || content == "public" || content == "require" ||
        content == "require_once" || content == "return" || content == "static" || content == "switch" ||
        content == "throw" || content == "try" || content == "use" || content == "while" ||
        content == "xor" || content == "static")
    {
        return true;                                    //  argument is PHP keyword
    }
    else
        return false;                                   //  argument is not PHP keyword
}


/// Check if keyword represents Python language keyword
///
/// @param  Keyword is represented as a string value
bool Spade::is_python_keyword(QString & content)
{
    if (content == "and" || content == "and" || content == "as" || content == "assert" || content == "break" ||
        content == "class" || content == "continue" || content == "def" || content == "del" || content == "elif" ||
        content == "else" || content == "except" || content == "finally" || content == "for" || content == "from" ||
        content == "global" || content == "if" || content == "import" || content == "in" || content == "is" ||
        content == "lambda" || content == "nonlocal" || content == "not" || content == "or" || content == "pass" ||
        content == "raise" || content == "return" || content == "try" || content == "while" || content == "with" ||
        content == "yield" || content == "bool" || content == "int" || content == "long" || content == "double" ||
        content == "float" || content == "str" || content == "complex" || content == "dict" || content == "IndexError" ||
        content == "TypeError" || content == "SyntaxError" || content == "AttributeError" || content == "list" ||
        content == "None" || content == "True" || content == "False")
    {
        return true;                                    //  argument is Python keyword
    }
    else
        return false;                                   //  argument is not Python keyword
}


/// Check if desired element is correct due to the C++ language syntax
///
/// @param  Class element is represented as a string value
bool Spade::check_class_element(QString & content)
{
    int N = content.size();                             //  get length of concrete class element
    int block_bracket_count = 0;
    int array_bracket_count = 0;
    int sharp_bracket_count = 0;

    for (int i = 0; i < N; i++)                         //  check if all three types of brackets are exactly matching
    {
        if (content[i] == '{')
            block_bracket_count++;
        else if (content[i] == '}')
            block_bracket_count--;
        else if (content[i] == '[')
            array_bracket_count++;
        else if (content[i] == ']')
            array_bracket_count--;
        else if (content[i] == '<')
            sharp_bracket_count++;
        else if (content[i] == '>')
            sharp_bracket_count--;
    }

    if (block_bracket_count == 0 && array_bracket_count == 0 && sharp_bracket_count == 0)
    {                                                   //  all three types of brackets are exactly matching
        int is_const = 0;
        int is_static = 0;
        int is_volatile = 0;

        for (int i = 0; i < 3; i++)                     //  check from beginning of string if element contains type qualifiers
        {
            if (content.left(6) == "const " || content.left(7) == "static " || content.left(9) == "volatile ")
            {                                           //  increase appropriate counter by qualifier type
                if (content.left(6) == "const ")
                {
                    content.remove(0, 6);
                    is_const++;
                }
                else if (content.left(7) == "static ")
                {
                    content.remove(0, 7);
                    is_static++;
                }
                else
                {
                    content.remove(0, 9);
                    is_volatile++;
                }
            }
            else
                break;
        }

        while (true)
        {
            int index = content.indexOf(" const");      //  check inside of string if element contains const qualifier

            if (index != -1 && !content[index + 6].isLetterOrNumber())
            {
                is_const++;                             //  increase appropriate counter by qualifier type
                content.remove(index, 6);               //  remove found substring from element string
            }
            else
                break;
        }

        while (true)
        {
            int index = content.indexOf(" static");     //  check inside of string if element contains const qualifier

            if (index != -1 && !content[index + 7].isLetterOrNumber())
            {
                is_static++;                            //  increase appropriate counter by qualifier type
                content.remove(index, 7);               //  remove found substring from element string
            }
            else
                break;
        }

        while (true)
        {
            int index = content.indexOf(" volatile");   //  check inside of string if element contains const qualifier

            if (index != -1 && !content[index + 9].isLetterOrNumber())
            {
                is_volatile++;                          //  increase appropriate counter by qualifier type
                content.remove(index, 9);               //  remove found substring from element string
            }
            else
                break;
        }

        if (is_const <= 1 && is_static <= 1 && is_volatile <= 1)
        {                                               //  insert unified type qualifiers to front of element string
            if (is_volatile)
                content = "volatile " + content;

            if (is_const)
                content = "const " + content;

            if (is_static)
                content = "static " + content;

            int i = N - 1;

            while (i)                                   //  iterate through element string
            {
                if (content[i] == '*')                  //  insert space character from from both sides of pointer characters sequence
                {
                    content.insert(i + 1, ' ');

                    i--;

                    while (content[i] == '*')
                        i--;

                    i++;

                    content.insert(i, ' ');
                    break;
                }
                else if (content[i] == '&')             //  insert space character from from both sides of reference character
                {
                    content.insert(i + 1, ' ');
                    content.insert(i, ' ');
                    break;
                }

                i--;
            }

            i = content.size() - 1;

            while (i)                                   //  iterate through element string
            {
                if (content[i] == ']')
                {
                    i--;

                    while (i)
                    {
                        if (content[i] == '[')
                            break;

                        content.remove(i, 1);           //  remove all characters from inside of array brackets
                        i--;
                    }
                }

                i--;
            }

            return true;                                //  element string is valid
        }
    }

    return false;                                       //  element string is not valid
}


/// Find to which file coresponds desired line number
///
/// @param  Integer value of concrete position inside source code
int Spade::find_appropriate_index(int & position)
{
    if (active_projects[projects->currentIndex() - 1].language == c99 || active_projects[projects->currentIndex() - 1].language == cplusplus)
    {
        int N = active_projects[projects->currentIndex() - 1].files.size();
        QStringList headers;
        QStringList sources;

        for (int i = 0; i < N; i++)
        {
            QString tail = active_projects[projects->currentIndex() - 1].files[i].right(4);

            if (tail.size() == 4)
            {
                if (tail == ".hxx" || tail == ".h++")
                    headers.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                else if (tail == ".cxx" || tail == ".c++" || tail == ".cpp")
                    sources.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                else
                {
                    tail.remove(0, 1);

                    if (tail == ".hh")
                        headers.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                    else if (tail == ".cc")
                        sources.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                    else
                    {
                        tail.remove(0, 1);

                        if (tail == ".h" || tail == ".H")
                            headers.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                        else if (tail == ".c" || tail == ".C")
                            sources.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                    }
                }
            }
        }

        QStringList files_list = headers + sources;
        int offset = 0;

        while (files_list.size())
        {
            QString content = "";
            int tabs_size = active_tabs.size();
            bool success = true;

            for (int i = 0; i < tabs_size; i++)             //  check if desired file to open is not already opened is text editor
            {
                if (active_tabs[i].file_path == files_list[0])  //  same file cannot be opened twice
                {
                    content = editor[active_tabs[i].index_in_tabs].document()->toPlainText();
                    int content_len = content.size() + offset;

                    if (position < content_len)
                    {
                        position = position - offset;
                        return i;
                    }

                    offset += content.size();
                    success = false;
                    break;
                }
            }

            if (success)
            {
                QFile file(files_list[0]);

                if (file.open(QFile::ReadOnly | QFile::Text))
                {
                    QTextStream fin(&file);
                    content = fin.readAll();                //  get content of file from disk
                    int content_len = content.size() + offset;

                    if (position < content_len)
                    {
                        parameters.push_back(files_list[0]);
                        handle_parameters();
                        position = position - offset;
                        return active_tabs.size() - 1;;
                    }

                    offset += content.size();
                    file.close();
                }
            }

            files_list.pop_front();
        }
    }
    else if (active_projects[projects->currentIndex() - 1].language == java)
    {
        QStringList files_list = active_projects[projects->currentIndex() - 1].files;
        int offset = 0;

        while (files_list.size())
        {
            QString content = "";
            int tabs_size = active_tabs.size();
            bool success = true;

            for (int i = 0; i < tabs_size; i++)             //  check if desired file to open is not already opened is text editor
            {
                if (active_tabs[i].file_path == files_list[0])  //  same file cannot be opened twice
                {
                    content = editor[active_tabs[i].index_in_tabs].document()->toPlainText();
                    int content_len = content.size() + offset;

                    if (position < content_len)
                    {
                        position = position - offset;
                        return i;
                    }

                    offset += content.size();
                    success = false;
                    break;
                }
            }

            if (success)
            {
                QFile file(files_list[0]);

                if (file.open(QFile::ReadOnly | QFile::Text))
                {
                    QTextStream fin(&file);
                    content = fin.readAll();                //  get content of file from disk
                    int content_len = content.size() + offset;

                    if (position < content_len)
                    {
                        parameters.push_back(files_list[0]);
                        handle_parameters();
                        position = position - offset;
                        return active_tabs.size() - 1;;
                    }

                    offset += content.size();
                    file.close();
                }
            }

            files_list.pop_front();
        }
    }

    return -1;
}


/// Jump to appropriate location in code of desired class tree item(declaration item)
///
/// @param  Model index of tree widget
void Spade::class_tree_item_left_clicked(QModelIndex index)
{
    if (projects->currentIndex())                       //  check if there is at least one opened project
    {
        if (index.parent().row() == -1)                 //  root of class tree selected
            return;
        else if (index.parent().parent().row() == -1)   //  concrete class of class tree selected
        {                                               //  move cursor position to beginning of appropriate location of item in document
            int from = class_tree_parents[index.row()].from;    //  get range values from description array
            int to = class_tree_parents[index.row()].to;

            if (class_tree_parents[index.row()].is_class)   //  selected item represents class
            {
                int difference = to - from;
                int editor_index = find_appropriate_index(from);
                to = from + difference;

                if (editor_index >= 0)
                {
                    file_selected(editor_index);
                    * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                    text_cursor->setPosition(from);
                    text_cursor->setPosition(to, QTextCursor::KeepAnchor);
                    editor[editor_index].setTextCursor(* text_cursor);

                    editor[editor_index].setFocus();                    //  set focus to actual tab of text editor
                }
            }
            else
            {
                if (from != -1 && to != -1)             //  definition and declaration is present
                {
                    int editor_index = find_appropriate_index(from);

                    if (editor_index >= 0)
                    {
                        file_selected(editor_index);
                        * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                        text_cursor->setPosition(from);
                        text_cursor->setPosition(from, QTextCursor::KeepAnchor);
                        editor[editor_index].setTextCursor(* text_cursor);

                        editor[editor_index].setFocus();                    //  set focus to actual tab of text editor
                    }
                }
                else if (from != -1)                    //  only declaration is present
                {
                    int editor_index = find_appropriate_index(from);

                    if (editor_index >= 0)
                    {
                        file_selected(editor_index);
                        * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                        text_cursor->setPosition(from);
                        text_cursor->setPosition(from, QTextCursor::KeepAnchor);
                        editor[editor_index].setTextCursor(* text_cursor);

                        editor[editor_index].setFocus();                    //  set focus to actual tab of text editor
                    }
                }
                else                                    //  only definition is present
                {
                    int editor_index = find_appropriate_index(to);

                    if (editor_index >= 0)
                    {
                        file_selected(editor_index);
                        * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                        text_cursor->setPosition(to);
                        text_cursor->setPosition(to, QTextCursor::KeepAnchor);
                        editor[editor_index].setTextCursor(* text_cursor);

                        editor[editor_index].setFocus();    //  set focus to actual tab of text editor
                    }
                }
            }
        }
        else                                            //  concrete element of class tree selected
        {                                               //  move cursor position to beginning of appropriate location of item in document
            int from = class_tree_parents[index.parent().row()].children[index.row()].from;     //  get range values from description array
            int to = class_tree_parents[index.parent().row()].children[index.row()].to;

            if (from != -1 && to != -1)                 //  definition and declaration is present
            {
                from = class_tree_parents[index.parent().row()].from + class_tree_parents[index.parent().row()].children[index.row()].from;

                int editor_index = find_appropriate_index(from);

                if (editor_index >= 0)
                {
                    file_selected(editor_index);
                    * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                    text_cursor->setPosition(from);
                    text_cursor->setPosition(from, QTextCursor::KeepAnchor);
                    editor[editor_index].setTextCursor(* text_cursor);

                    editor[editor_index].setFocus();    //  set focus to actual tab of text editor
                }
            }
            else if (from != -1)                        //  only declaration is present
            {
                from = class_tree_parents[index.parent().row()].from + class_tree_parents[index.parent().row()].children[index.row()].from;

                int editor_index = find_appropriate_index(from);

                if (editor_index >= 0)
                {
                    file_selected(editor_index);
                    * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                    text_cursor->setPosition(from);
                    text_cursor->setPosition(from, QTextCursor::KeepAnchor);
                    editor[editor_index].setTextCursor(* text_cursor);

                    editor[editor_index].setFocus();    //  set focus to actual tab of text editor
                }
            }
            else                                        //  only definition is present
            {
                to = class_tree_parents[index.parent().row()].from + class_tree_parents[index.parent().row()].children[index.row()].to;

                int editor_index = find_appropriate_index(to);

                if (editor_index >= 0)
                {
                    file_selected(editor_index);
                    * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                    text_cursor->setPosition(to);
                    text_cursor->setPosition(to, QTextCursor::KeepAnchor);
                    editor[editor_index].setTextCursor(* text_cursor);

                    editor[editor_index].setFocus();    //  set focus to actual tab of text editor
                }
            }
        }
    }
    else
    {
        int editor_index = active_tabs[files->currentIndex()].index_in_tabs;

        if (index.parent().row() == -1)                 //  root of class tree selected
            editor[editor_index].selectAll();           //  select complete content of appropriate document
        else if (index.parent().parent().row() == -1)   //  concrete class of class tree selected
        {                                               //  move cursor position to beginning of appropriate location of item in document
            int from = class_tree_parents[index.row()].from;    //  get range values from description array
            int to = class_tree_parents[index.row()].to;

            if (class_tree_parents[index.row()].is_class)   //  selected item represents class
            {
                int N = editor[editor_index].document()->toPlainText().size();

                if (from > N || to > N)                 //  check text length overflow
                    return;

                * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                text_cursor->setPosition(from);
                text_cursor->setPosition(to, QTextCursor::KeepAnchor);
                editor[editor_index].setTextCursor(* text_cursor);
            }
            else
            {
                if (from != -1 && to != -1)             //  definition and declaration is present
                {
                    if (from > editor[editor_index].document()->toPlainText().size())   //  check text length overflow
                        return;

                    * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                    text_cursor->setPosition(from);
                    text_cursor->setPosition(from, QTextCursor::KeepAnchor);
                    editor[editor_index].setTextCursor(* text_cursor);
                }
                else if (from != -1)                    //  only declaration is present
                {
                    if (from > editor[editor_index].document()->toPlainText().size())   //  check text length overflow
                        return;

                    * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                    text_cursor->setPosition(from);
                    text_cursor->setPosition(from, QTextCursor::KeepAnchor);
                    editor[editor_index].setTextCursor(* text_cursor);
                }
                else                                    //  only definition is present
                {
                    if (to > editor[editor_index].document()->toPlainText().size())     //  check text length overflow
                        return;

                    * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                    text_cursor->setPosition(to);
                    text_cursor->setPosition(to, QTextCursor::KeepAnchor);
                    editor[editor_index].setTextCursor(* text_cursor);
                }
            }
        }
        else                                            //  concrete element of class tree selected
        {                                               //  move cursor position to beginning of appropriate location of item in document
            int from = class_tree_parents[index.parent().row()].children[index.row()].from;     //  get range values from description array
            int to = class_tree_parents[index.parent().row()].children[index.row()].to;

            if (from != -1 && to != -1)                 //  definition and declaration is present
            {
                from = class_tree_parents[index.parent().row()].from + class_tree_parents[index.parent().row()].children[index.row()].from;

                if (from > editor[editor_index].document()->toPlainText().size())   //  check text length overflow
                    return;

                * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                text_cursor->setPosition(from);
                text_cursor->setPosition(from, QTextCursor::KeepAnchor);
                editor[editor_index].setTextCursor(* text_cursor);
            }
            else if (from != -1)                        //  only declaration is present
            {
                from = class_tree_parents[index.parent().row()].from + class_tree_parents[index.parent().row()].children[index.row()].from;

                if (from > editor[editor_index].document()->toPlainText().size())   //  check text length overflow
                    return;

                * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                text_cursor->setPosition(from);
                text_cursor->setPosition(from, QTextCursor::KeepAnchor);
                editor[editor_index].setTextCursor(* text_cursor);
            }
            else                                        //  only definition is present
            {
                to = class_tree_parents[index.parent().row()].from + class_tree_parents[index.parent().row()].children[index.row()].to;

                if (to > editor[editor_index].document()->toPlainText().size())
                    return;

                * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                text_cursor->setPosition(to);
                text_cursor->setPosition(to, QTextCursor::KeepAnchor);
                editor[editor_index].setTextCursor(* text_cursor);
            }
        }

        editor[editor_index].setFocus();                //  set focus to actual tab of text editor
    }
}


/// Jump to appropriate location in code of desired class tree item(definition item)
///
/// @param  Model index of tree widget
void Spade::class_tree_item_right_clicked(QModelIndex index)
{
    if (projects->currentIndex())                   //  check if there is at least one opened project
    {
        if (index.parent().row() == -1)                 //  root of class tree selected
            return;
        else if (index.parent().parent().row() == -1)   //  concrete class of class tree selected
        {                                               //  move cursor position to beginning of appropriate location of item in document
            int from = class_tree_parents[index.row()].from;    //  get range values from description array
            int to = class_tree_parents[index.row()].to;

            if (class_tree_parents[index.row()].is_class)   //  selected item represents class
            {
                int difference = to - from;
                int editor_index = find_appropriate_index(from);
                to = from + difference;

                if (editor_index >= 0)
                {
                    file_selected(editor_index);
                    * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                    text_cursor->setPosition(from);
                    text_cursor->setPosition(to, QTextCursor::KeepAnchor);
                    editor[editor_index].setTextCursor(* text_cursor);

                    editor[editor_index].setFocus();    //  set focus to actual tab of text editor
                }
            }
            else
            {
                if (from != -1 && to != -1)             //  definition and declaration is present
                {
                    int editor_index = find_appropriate_index(to);

                    if (editor_index >= 0)
                    {
                        file_selected(editor_index);
                        * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                        text_cursor->setPosition(to);
                        text_cursor->setPosition(to, QTextCursor::KeepAnchor);
                        editor[editor_index].setTextCursor(* text_cursor);

                        editor[editor_index].setFocus();                    //  set focus to actual tab of text editor
                    }
                }
                else if (from != -1)                    //  only declaration is present
                {
                    int editor_index = find_appropriate_index(from);

                    if (editor_index >= 0)
                    {
                        file_selected(editor_index);
                        * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                        text_cursor->setPosition(from);
                        text_cursor->setPosition(from, QTextCursor::KeepAnchor);
                        editor[editor_index].setTextCursor(* text_cursor);

                        editor[editor_index].setFocus();                    //  set focus to actual tab of text editor
                    }
                }
                else                                    //  only definition is present
                {
                    int editor_index = find_appropriate_index(to);

                    if (editor_index >= 0)
                    {
                        file_selected(editor_index);
                        * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                        text_cursor->setPosition(to);
                        text_cursor->setPosition(to, QTextCursor::KeepAnchor);
                        editor[editor_index].setTextCursor(* text_cursor);

                        editor[editor_index].setFocus();                    //  set focus to actual tab of text editor
                    }
                }
            }
        }
        else                                            //  concrete element of class tree selected
        {                                               //  move cursor position to beginning of appropriate location of item in document
            int from = class_tree_parents[index.parent().row()].children[index.row()].from;     //  get range values from description array
            int to = class_tree_parents[index.parent().row()].children[index.row()].to;

            if (from != -1 && to != -1)                 //  definition and declaration is present
            {
                int editor_index = find_appropriate_index(to);

                if (editor_index >= 0)
                {
                    file_selected(editor_index);
                    * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                    text_cursor->setPosition(to);
                    text_cursor->setPosition(to, QTextCursor::KeepAnchor);
                    editor[editor_index].setTextCursor(* text_cursor);

                    editor[editor_index].setFocus();                    //  set focus to actual tab of text editor
                }
            }
            else if (from != -1)                        //  only declaration is present
            {
                from = class_tree_parents[index.parent().row()].from + class_tree_parents[index.parent().row()].children[index.row()].from;

                int editor_index = find_appropriate_index(from);

                if (editor_index >= 0)
                {
                    file_selected(editor_index);
                    * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                    text_cursor->setPosition(from);
                    text_cursor->setPosition(from, QTextCursor::KeepAnchor);
                    editor[editor_index].setTextCursor(* text_cursor);

                    editor[editor_index].setFocus();                    //  set focus to actual tab of text editor
                }
            }
            else                                        //  only definition is present
            {
                to = class_tree_parents[index.parent().row()].from + class_tree_parents[index.parent().row()].children[index.row()].to;

                int editor_index = find_appropriate_index(to);

                if (editor_index >= 0)
                {
                    file_selected(editor_index);
                    * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                    text_cursor->setPosition(to);
                    text_cursor->setPosition(to, QTextCursor::KeepAnchor);
                    editor[editor_index].setTextCursor(* text_cursor);

                    editor[editor_index].setFocus();                    //  set focus to actual tab of text editor
                }
            }
        }
    }
    else
    {
        int editor_index = active_tabs[files->currentIndex()].index_in_tabs;

        if (index.parent().row() == -1)                 //  root of class tree selected
            editor[editor_index].selectAll();           //  select complete content of appropriate document
        else if (index.parent().parent().row() == -1)   //  concrete class of class tree selected
        {                                               //  move cursor position to beginning of appropriate location of item in document
            int from = class_tree_parents[index.row()].from;    //  get range values from description array
            int to = class_tree_parents[index.row()].to;

            if (class_tree_parents[index.row()].is_class)   //  selected item represents class
            {
                int N = editor[editor_index].document()->toPlainText().size();

                if (from > N || to > N)                 //  check text length overflow
                    return;

                * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                text_cursor->setPosition(from);
                text_cursor->setPosition(to, QTextCursor::KeepAnchor);
                editor[editor_index].setTextCursor(* text_cursor);
            }
            else
            {
                if (from != -1 && to != -1)             //  definition and declaration is present
                {
                    if (to > editor[editor_index].document()->toPlainText().size())     //  check text length overflow
                        return;

                    * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                    text_cursor->setPosition(to);
                    text_cursor->setPosition(to, QTextCursor::KeepAnchor);
                    editor[editor_index].setTextCursor(* text_cursor);
                }
                else if (from != -1)                    //  only declaration is present
                {
                    if (from > editor[editor_index].document()->toPlainText().size())   //  check text length overflow
                        return;

                    * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                    text_cursor->setPosition(from);
                    text_cursor->setPosition(from, QTextCursor::KeepAnchor);
                    editor[editor_index].setTextCursor(* text_cursor);
                }
                else                                    //  only definition is present
                {
                    if (to > editor[editor_index].document()->toPlainText().size())     //  check text length overflow
                        return;

                    * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                    text_cursor->setPosition(to);
                    text_cursor->setPosition(to, QTextCursor::KeepAnchor);
                    editor[editor_index].setTextCursor(* text_cursor);
                }
            }
        }
        else                                            //  concrete element of class tree selected
        {                                               //  move cursor position to beginning of appropriate location of item in document
            int from = class_tree_parents[index.parent().row()].children[index.row()].from;     //  get range values from description array
            int to = class_tree_parents[index.parent().row()].children[index.row()].to;

            if (from != -1 && to != -1)                 //  definition and declaration is present
            {
                if (to > editor[editor_index].document()->toPlainText().size())     //  check text length overflow
                    return;

                * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                text_cursor->setPosition(to);
                text_cursor->setPosition(to, QTextCursor::KeepAnchor);
                editor[editor_index].setTextCursor(* text_cursor);
            }
            else if (from != -1)                        //  only declaration is present
            {
                from = class_tree_parents[index.parent().row()].from + class_tree_parents[index.parent().row()].children[index.row()].from;

                if (from > editor[editor_index].document()->toPlainText().size())   //  check text length overflow
                    return;

                * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                text_cursor->setPosition(from);
                text_cursor->setPosition(from, QTextCursor::KeepAnchor);
                editor[editor_index].setTextCursor(* text_cursor);
            }
            else                                        //  only definition is present
            {
                to = class_tree_parents[index.parent().row()].from + class_tree_parents[index.parent().row()].children[index.row()].to;

                if (to > editor[editor_index].document()->toPlainText().size())
                    return;

                * text_cursor = editor[editor_index].textCursor();  //  move text cursor to an appropriate position
                text_cursor->setPosition(to);
                text_cursor->setPosition(to, QTextCursor::KeepAnchor);
                editor[editor_index].setTextCursor(* text_cursor);
            }
        }

        editor[editor_index].setFocus();                //  set focus to actual tab of text editor
    }
}


/// Refresh content of class tree by the actual file in text editor tabs
void Spade::refresh_class_tree()
{
    if (ui->class_tree->isHidden())
    {
        ui->class_tree->show();                         //  make class tree visible if it is hidden
        ui->line->show();
    }

    ui->class_tree->clear();                            //  clear class tree content
    class_tree_parents.clear();                         //  clear content of class tree description array

    int actual = files->currentIndex();
    int index = active_tabs[actual].index_in_tabs;      //  get actual index of text editor tabs
    int actual_language;

    if (projects->currentIndex())
        actual_language = active_projects[projects->currentIndex() - 1].language;
    else
        actual_language = language->currentIndex();

    QTreeWidgetItem * tree_root;

    if (projects->currentIndex())                       //  check if there is at least one opened project
    {
        tree_root = new QTreeWidgetItem(ui->class_tree);    //  create root item of class tree with filename content
        tree_root->setText(0, projects->currentText());
        tree_root->setToolTip(0, projects->toolTip());
    }
    else
    {
        tree_root = new QTreeWidgetItem(ui->class_tree);    //  create root item of class tree with filename content
        tree_root->setText(0, active_tabs[actual].file_name);
        tree_root->setToolTip(0, active_tabs[actual].file_path);
    }

    if (actual_language == c99 || actual_language == cplusplus)   //  selected language of actual text editor tab is C++
    {
        QString content = "";
        QStringList files_list;

        if (projects->currentIndex())                   //  check if there is at least one opened project
        {
            int N = active_projects[projects->currentIndex() - 1].files.size();
            QStringList headers;
            QStringList sources;

            for (int i = 0; i < N; i++)
            {
                QString tail = active_projects[projects->currentIndex() - 1].files[i].right(4);

                if (tail.size() == 4)
                {
                    if (tail == ".hxx" || tail == ".h++")
                        headers.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                    else if (tail == ".cxx" || tail == ".c++" || tail == ".cpp")
                        sources.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                    else
                    {
                        tail.remove(0, 1);

                        if (tail == ".hh")
                            headers.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                        else if (tail == ".cc")
                            sources.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                        else
                        {
                            tail.remove(0, 1);

                            if (tail == ".h" || tail == ".H")
                                headers.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                            else if (tail == ".c" || tail == ".C")
                                sources.push_back(active_projects[projects->currentIndex() - 1].files[i]);
                        }
                    }
                }
            }

            files_list = headers + sources;
        }
        else
            content = editor[index].document()->toPlainText();

        while (files_list.size())
        {
            int tabs_size = active_tabs.size();
            bool success = true;

            for (int i = 0; i < tabs_size; i++)         //  check if desired file to open is not already opened is text editor
            {
                if (active_tabs[i].file_path == files_list[0])  //  same file cannot be opened twice
                {
                    content.push_back(editor[active_tabs[i].index_in_tabs].document()->toPlainText());
                    success = false;
                    break;
                }
            }

            if (success)
            {
                QFile file(files_list[0]);

                if (file.open(QFile::ReadOnly | QFile::Text))
                {
                    QTextStream fin(&file);
                    content.push_back(fin.readAll());   //  get content of file from disk
                    file.close();
                }
            }

            files_list.pop_front();
        }

        remove_comments_and_quotation(content, actual_language);  //  remove all comments and quotation from source code string

        int enum_count = 0;
                                                        //  regular expression to match C++ enumeration
        QRegularExpression regex("enum([ \t\n]+class){0,1}[ \t\n]+([A-Za-z_][A-Za-z0-9_]*){0,1}[ \t\n]*{", QRegularExpression::DotMatchesEverythingOption);
        regex.optimize();

        if (regex.isValid())                            //  check if regular expression of rule is valid
        {
            int N = content.size();
            QRegularExpressionMatchIterator match_iter = regex.globalMatch(content);     //  check for global match of regular expression from rule

            while (match_iter.hasNext())                //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                int from = match.capturedStart();       //  save range of actual match
                int to = match.capturedEnd();
                int bracket_count = 1;

                for (int i = to; i < N; i++)            //  check if block brackets below enum header are matching
                {
                    if (content[i] == '{')
                        bracket_count++;
                    else if (content[i] == '}')
                    {
                        bracket_count--;

                        if (bracket_count == 0)         //  body of actual C++ block found
                        {
                            Class_tree_parent temp_enum;   //  push new item into class tree description array
                            temp_enum.from = from;
                            temp_enum.to = i + 1;
                            class_tree_parents.push_back(temp_enum);
                            enum_count++;

                            break;
                        }
                    }
                }
            }
        }

        int N = class_tree_parents.size();

        if (enum_count)                                 //  at least one valid C++ enum body found
        {
            for (int i = 0; i < N; i++)                 //  iterate through all found enum bodies
            {                                           //  save enum body into separate string object
                QString sub_content = content.mid(class_tree_parents[i].from, class_tree_parents[i].to - class_tree_parents[i].from);
                int N = sub_content.size();             //  get actual size of enum body string

                for (int j = sub_content.indexOf('{') + 1; j < N; j++)  //  find starting block bracket in enum body string
                {
                    if (sub_content[j] == '{')
                    {
                        int block_bracket_count = 1;
                        j++;

                        while (j < N)
                        {
                            if (sub_content[j] == '{')
                                block_bracket_count++;
                            else if (sub_content[j] == '}')
                                block_bracket_count--;

                            if (block_bracket_count == 0)
                                break;
                            else
                                sub_content[j] = ' ';   //  remove all bodies of all methods location inside body of actual enum

                            j++;
                        }
                    }
                }

                for (int j = 0; j < N; j++)             //  replace all tabs and newlines by space characters
                {
                    if (sub_content[j] == '\t' || sub_content[j] == '\n')
                        sub_content[j] = ' ';
                }

                QList<int> removed_spaces;              //  holds number of removed spaces for every index of enum body string
                int count = 0;                          //  holds count of removed spaces
                int j = 0;

                while (j < N)                           //  remove all explicit spaces from enum body string
                {
                    if (sub_content[j] == ' ')
                    {
                        removed_spaces.push_back(count);

                        while (sub_content[j + 1] == ' ')
                        {
                            count++;
                            sub_content.remove(j + 1, 1);   //  save count of removed spaces into appropriate index of array
                        }

                        j++;
                    }
                    else
                    {
                        removed_spaces.push_back(count);
                        j++;
                    }
                }

                N = sub_content.size() - 1;             //  get actual size of enum body string
                j = 1;

                while (j < N)
                {
                    if (sub_content[j] == ' ')          //  remove all spaces from enum string except spaces inside identifier valid characters
                    {
                        if ((sub_content[j - 1].isLetterOrNumber() || sub_content[j - 1] == '_') &&
                            (sub_content[j + 1].isLetterOrNumber() || sub_content[j + 1] == '_'))
                        {
                            j++;
                        }
                        else
                        {
                            int M = removed_spaces.size();

                            for (int k = j + 1; k < M; k++)
                                removed_spaces[k]++;    //  update count of removed spaces in array

                            removed_spaces.removeAt(j);
                            sub_content.remove(j, 1);
                            N--;
                        }
                    }
                    else
                        j++;
                }

                QString temp_content = sub_content;
                sub_content.clear();
                N = temp_content.size();                //  get actual size of enum body string

                for (int j = 0; j < N; j++)
                {
                    sub_content.push_back(temp_content[j]);

                    if (temp_content[j] == '>')         //  add space character after greater-than characters
                    {
                        int M = removed_spaces.size();

                        for (int k = j + 1; k < M; k++)
                            removed_spaces[k]--;        //  update count of removed spaces in array

                        removed_spaces.insert(j + 1, removed_spaces[j + 0]);
                        sub_content.push_back(' ');
                    }
                }

                N = sub_content.size();                 //  get actual size of enum body string

                bool is_class_enum = false;

                if (sub_content.left(10) == "enum class")
                    is_class_enum = true;

                QTreeWidgetItem * tree_parent = new QTreeWidgetItem;    //  insert actual enum as child item into class tree
                tree_parent->setIcon(0, * enum_icon);

                if (is_class_enum)
                    tree_parent->setToolTip(0, "Class enumeration");
                else
                    tree_parent->setToolTip(0, "Enumeration");

                tree_root->addChild(tree_parent);

                QString class_name = "";

                if (is_class_enum)
                {
                    if (sub_content.indexOf('{') > 9)
                        class_name = sub_content.mid(10, sub_content.indexOf('{') - 10);    //  get enum name from enum body string
                }
                else
                {
                    if (sub_content.indexOf('{') > 4)
                        class_name = sub_content.mid(5, sub_content.indexOf('{') - 5);  //  get enum name from enum body string
                }

                tree_parent->setText(0, class_name);
                class_tree_parents[i].content = class_name;

                vector<QString> attributes;             //  array which will hold strings of all found enum attributes
                                                        //  regular expression to match enum attribute string
                regex.setPattern("([{]|[,])[A-Za-z_][A-Za-z0-9_]*");

                if (regex.isValid())                    //  check if regular expression of rule is valid
                {
                    QRegularExpressionMatchIterator match_iter = regex.globalMatch(sub_content);

                    while (match_iter.hasNext())        //  iterate through all regular expression matches
                    {
                        QRegularExpressionMatch match = match_iter.next();

                        int from = match.capturedStart();   //  save starting index of matched content into variable
                        QString found = match.captured();   //  save matched content into string variable
                        found.remove(0, 1);

                        bool conflict = false;
                        int N = attributes.size();      //  get actual number of found enum attributes

                        for (int j = 0; j < N; j++)     //  check if same enum attribute is already in array of all attributes
                        {
                            if (attributes[j] == found)
                            {
                                conflict = true;
                                break;
                            }
                        }

                        if (conflict == false)          //  enum attribute is not yet in array of all attributes
                        {
                            attributes.push_back(found);    //  push found enum attribute into array

                            Class_tree_child child;     //  create child description of actual class item
                            child.from = from + removed_spaces[from + 1] + 1;   //  get starting position of matched content
                            child.content = found;
                            class_tree_parents[i].children.push_back(child);    //  insert child description into parent attribute array

                            QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  create child of actual class item in class tree
                            tree_child->setText(0, found);  //  set child item text to modified matched string
                                                        //  check visibility of matched content using visibility array
                            tree_child->setIcon(0, * public_attribute_icon);
                            tree_child->setToolTip(0, "Attribute");

                            tree_parent->addChild(tree_child);  //  push child item into actual class item in class tree
                        }
                    }
                }
            }
        }

        int class_count = 0;                            //  holds number of all found C++ classes headers
                                                        //  regular expression to match header of C++ class
        regex.setPattern("class[ \t\n]+[A-Za-z_][A-Za-z0-9_]*[ \t\n]*(:[ \t\n]*[A-Za-z0-9_][A-Za-z0-9_, \t\n]*){0,1}{");
        regex.setPatternOptions(QRegularExpression::DotMatchesEverythingOption);

        if (regex.isValid())                            //  check if regular expression of rule is valid
        {
            int N = content.size();
            QRegularExpressionMatchIterator match_iter = regex.globalMatch(content);     //  check for global match of regular expression from rule

            while (match_iter.hasNext())                //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                int from = match.capturedStart();       //  save range of actual match
                int to = match.capturedEnd();
                int bracket_count = 1;

                for (int i = to; i < N; i++)            //  check if block brackets below class header are matching
                {
                    if (content[i] == '{')
                        bracket_count++;
                    else if (content[i] == '}')
                    {
                        bracket_count--;

                        if (bracket_count == 0)         //  body of actual C++ block found
                        {
                            Class_tree_parent temp_class;   //  push new class item into class tree description array
                            temp_class.from = from;
                            temp_class.to = i + 1;
                            class_tree_parents.push_back(temp_class);
                            class_count++;

                            break;
                        }
                    }
                }
            }
        }

        N = class_tree_parents.size();

        if (class_count)                                //  at least one valid C++ class body found
        {
            for (int i = enum_count; i < N; i++)        //  iterate through all found class bodies
            {                                           //  save class body into separate string object
                QString sub_content = content.mid(class_tree_parents[i].from, class_tree_parents[i].to - class_tree_parents[i].from);
                int N = sub_content.size();             //  get actual size of class body string

                for (int j = sub_content.indexOf('{') + 1; j < N; j++)  //  find starting block bracket in class body string
                {
                    if (sub_content[j] == '{')
                    {
                        int block_bracket_count = 1;
                        j++;

                        while (j < N)
                        {
                            if (sub_content[j] == '{')
                                block_bracket_count++;
                            else if (sub_content[j] == '}')
                                block_bracket_count--;

                            if (block_bracket_count == 0)
                                break;
                            else
                                sub_content[j] = ' ';   //  remove all bodies of all methods location inside body of actual class

                            j++;
                        }
                    }
                }

                for (int j = 0; j < N; j++)             //  replace all tabs and newlines by space characters
                {
                    if (sub_content[j] == '\t' || sub_content[j] == '\n')
                        sub_content[j] = ' ';
                }

                QList<int> removed_spaces;              //  holds number of removed spaces for every index of class body string
                int count = 0;                          //  holds count of removed spaces
                int j = 0;

                while (j < N)                           //  remove all explicit spaces from class body string
                {
                    if (sub_content[j] == ' ')
                    {
                        removed_spaces.push_back(count);

                        while (sub_content[j + 1] == ' ')
                        {
                            count++;
                            sub_content.remove(j + 1, 1);   //  save count of removed spaces into appropriate index of array
                        }

                        j++;
                    }
                    else
                    {
                        removed_spaces.push_back(count);
                        j++;
                    }
                }

                N = sub_content.size() - 1;             //  get actual size of class body string
                j = 1;

                while (j < N)
                {
                    if (sub_content[j] == ' ')          //  remove all spaces from class string except spaces inside identifier valid characters
                    {
                        if ((sub_content[j - 1].isLetterOrNumber() || sub_content[j - 1] == '_') &&
                            (sub_content[j + 1].isLetterOrNumber() || sub_content[j + 1] == '_'))
                        {
                            j++;
                        }
                        else
                        {
                            int M = removed_spaces.size();

                            for (int k = j + 1; k < M; k++)
                                removed_spaces[k]++;    //  update count of removed spaces in array

                            removed_spaces.removeAt(j);
                            sub_content.remove(j, 1);
                            N--;
                        }
                    }
                    else
                        j++;
                }

                QString temp_content = sub_content;
                sub_content.clear();
                N = temp_content.size();                //  get actual size of class body string

                for (int j = 0; j < N; j++)
                {
                    sub_content.push_back(temp_content[j]);

                    if (temp_content[j] == '>')         //  add space character after greater-than characters
                    {
                        int M = removed_spaces.size();

                        for (int k = j + 1; k < M; k++)
                            removed_spaces[k]--;        //  update count of removed spaces in array

                        removed_spaces.insert(j + 1, removed_spaces[j + 0]);
                        sub_content.push_back(' ');
                    }
                }

                N = sub_content.size();                 //  get actual size of class body string

                QString class_name = "";

                QTreeWidgetItem * tree_parent = new QTreeWidgetItem;    //  insert actual class as child item into class tree
                tree_parent->setIcon(0, * class_icon);
                tree_parent->setToolTip(0, "This class has no parents");
                tree_root->addChild(tree_parent);

                for (int j = 0; j < N; j++)             //  iterate through all characters of class body string
                {
                    if (sub_content[j] == ':')          //  check if actual class has parent classes by colon character search
                    {                                   //  actual class has parent classes
                        class_name = sub_content.mid(6, j - 6);     //  get class name from class body string
                        tree_parent->setText(0, class_name);
                        class_tree_parents[i].content = class_name;
                        j++;
                        QString parents = "";           //  string which holds parent classes specification

                        while (sub_content[j] != '{')   //  save string content until starting block bracket is found
                        {
                            parents.push_back(sub_content[j]);
                            j++;
                        }

                        QString original = parents;     //  save parents string for future use

                        while (true)                    //  iterate through parents string
                        {                               //  remove possible qualifiers from beginning of string
                            if (parents.left(8) == "private ")
                            {
                                parents.remove(0, 8);

                                if (parents.left(8) == "virtual ")
                                    parents.remove(0, 8);
                            }
                            else if (parents.left(10) == "protected ")
                            {
                                parents.remove(0, 10);

                                if (parents.left(8) == "virtual ")
                                    parents.remove(0, 8);
                            }
                            else if (parents.left(7) == "public ")
                            {
                                parents.remove(0, 7);

                                if (parents.left(8) == "virtual ")
                                    parents.remove(0, 8);
                            }
                            else if (parents.left(8) == "virtual ")
                            {
                                parents.remove(0, 8);

                                if (parents.left(8) == "private ")
                                    parents.remove(0, 8);
                                else if (parents.left(10) == "protected ")
                                    parents.remove(0, 10);
                                else if (parents.left(7) == "public ")
                                    parents.remove(0, 7);
                            }

                            bool end_of_parents = false;
                            int separator_index = parents.indexOf(',');     //  find comma separator in string

                            if (separator_index == -1)  //  separator found in string
                            {
                                separator_index = parents.size();   //  save separator position
                                end_of_parents = true;
                            }

                            if (separator_index == 0)   //  identifier of parent class is missing
                                break;

                            if (!parents[0].isLetter() && parents[0] != '_')    //   invalid character inside parent class identifier
                                break;

                            bool success = true;

                            for (int k = 1; k < separator_index; k++)   //  check if valid C++ identifier is present
                            {
                                if (!parents[k].isLetterOrNumber() && parents[k] != '_')
                                {                       //  invalid character inside parent class identifier
                                    success = false;
                                    break;
                                }
                            }

                            if (success == false)       //  check if actual parent class specification is valid
                                break;

                            if (end_of_parents)         //  insert parent classes string as tooltip of actual class item of class tree
                            {
                                original.replace(",", ", ");
                                tree_parent->setToolTip(0, QString("Class parents:  %1").arg(original));
                                break;
                            }
                            else
                                parents = parents.mid(separator_index + 1);     //  remove part of string until separator character
                        }

                        break;
                    }
                    else if (sub_content[j] == '{')     //  actual class has no parent classes
                    {
                        class_name = sub_content.mid(6, j - 6);     //  get class name from class body string
                        tree_parent->setText(0, class_name);
                        class_tree_parents[i].content = class_name;
                        break;
                    }
                }

                vector<char> visibility;                //  holds visibility of every character in class body string

                for (int j = 0; j < N; j++)             //  fill visibility array with spaces
                    visibility.push_back(' ');          //  space = not set yet, 0 = private, 1 = protected, 2 = public

                regex.setPatternOptions(QRegularExpression::NoPatternOption);   //  regular expression to find access keywords in class body string
                regex.setPattern("((private:)|(protected:)|(public:))");

                if (regex.isValid())                    //  check if regular expression of rule is valid
                {
                    QRegularExpressionMatchIterator match_iter = regex.globalMatch(sub_content);

                    while (match_iter.hasNext())        //  iterate through all regular expression matches
                    {
                        QRegularExpressionMatch match = match_iter.next();

                        int from = match.capturedStart();   //  save range of match
                        int to = match.capturedEnd();
                        QString found = match.captured();
                                                        //  fill visibility array in range of match with concrete character
                        if (found == "private:")
                        {
                            for (int j = from; j < to; j++)
                                visibility[j] = '0';    //  handle private visibility
                        }
                        else if (found == "protected:")
                        {
                            for (int j = from; j < to; j++)
                                visibility[j] = '1';    //  handle protected visibility
                        }
                        else
                        {
                            for (int j = from; j < to; j++)
                                visibility[j] = '2';    //  handle public visibility
                        }
                    }
                }

                for (int j = 0; j < N; j++)             //  iterate through the visibility array
                {                                       //  fill unset positions of visibility array with appropriate character
                    if (visibility[j] == ' ')
                        visibility[j] = '0';
                    else if (visibility[j] == '0')      //  private visibility subsequence found
                    {
                        j++;

                        while (j < N)
                        {
                            if (visibility[j] == '1' || visibility[j] == '2')
                                break;                  //  break array filling when different visibility subsequence found

                            visibility[j] = '0';
                            j++;
                        }
                    }
                    else if (visibility[j] == '1')      //  protected visibility subsequence found
                    {
                        j++;

                        while (j < N)
                        {
                            if (visibility[j] == '0' || visibility[j] == '2')
                                break;                  //  break array filling when different visibility subsequence found

                            visibility[j] = '1';
                            j++;
                        }
                    }
                    else                                //  public visibility subsequence found
                    {
                        j++;

                        while (j < N)
                        {
                            if (visibility[j] == '0' || visibility[j] == '1')
                                break;                  //  break array filling when different visibility subsequence found

                            visibility[j] = '2';
                            j++;
                        }
                    }
                }

                vector<QString> constructors;           //  array which will hold strings of all found class constructors
                                                        //  regular expression to match class constructor string
                regex.setPattern(QString("[^~]%1\\([A-Za-z0-9_\\<\\>.,*&\\[\\]= ]*\\)((const override)|(const)|(override)){0,1}([{]|[;])").arg(class_name));

                if (regex.isValid())                    //  check if regular expression of rule is valid
                {
                    QRegularExpressionMatchIterator match_iter = regex.globalMatch(sub_content);

                    while (match_iter.hasNext())        //  iterate through all regular expression matches
                    {
                        QRegularExpressionMatch match = match_iter.next();

                        int from = match.capturedStart();   //  save starting index of matched content into variable
                        QString found = match.captured();   //  save matched content into string variable

                        bool is_definition = false;

                        if (found.right(1) == "{")
                            is_definition = true;

                        found.remove(0, 1);
                        found.chop(1);                  //  remove { or ; character from end fo string
                        N = found.size();               //  get length of matched content

                        QString string_tail;

                        while (found.right(1) != ")")   //  remove rest of matched content after closing classic bracket
                        {
                            string_tail.push_front(found.right(1));     //  string tail can contain possible type qualifiers
                            found.chop(1);
                        }

                        int arguments_from = found.indexOf('(');    //  save method arguments substring into variable
                        QString arguments_string = found.mid(arguments_from, match.capturedEnd() - arguments_from);
                        found.remove(arguments_from + 1, match.capturedEnd() - arguments_from);
                                                        //  regular expression to match attribute string of class constructor
                        QRegularExpression arguments_regex;
                        arguments_regex.setPattern("((static )|(const )|(volatile )){0,3}"
                                                   "[A-Za-z_][A-Za-z0-9_]*"
                                                   "(( [A-Za-z_][A-Za-z0-9_]*){0,3}|(\\<[A-Za-z_][A-Za-z0-9_\\<\\>.:,*&\\[\\] ]*\\>))"
                                                   "(( static)|( const)|( volatile)){0,3}"
                                                   "(((([*]+(const){0,1})|(&*))(\\[[A-Za-z0-9.]*\\])*)|"
                                                   "((([*]+(const ){0,1})|&| )[A-Za-z_][A-Za-z0-9_]*(\\[[A-Za-z0-9.]*\\])*))"
                                                   "[),=]");
                        arguments_regex.optimize();

                        if (arguments_regex.isValid())  //  check if regular expression of rule is valid
                        {
                            QRegularExpressionMatchIterator match_iter = arguments_regex.globalMatch(arguments_string);

                            while (match_iter.hasNext())    //  iterate through all regular expression matches
                            {
                                QRegularExpressionMatch match = match_iter.next();
                                QString argument_found = match.captured();  //  save matched content into string variable
                                argument_found.chop(1);

                                if (check_class_element(argument_found))    //  check validity of found argument
                                {                       //  insert found valid argument into constructor content string again
                                    QString rest = "";  //  holds ending array brackets sequence

                                    while (argument_found.right(1) == "]" || argument_found.right(1) == "[")
                                    {
                                        rest.push_front(argument_found.right(1));
                                        argument_found.chop(1);     //  remove all array brackets from end of argument
                                    }

                                    int N = argument_found.size();
                                    bool flag = true;

                                    for (int j = 0; j < N; j++)     //  check if argument do not contain template specification
                                    {
                                        if (!argument_found[j].isLetterOrNumber() && argument_found[j] != '_' && argument_found[j] != ' ')
                                        {
                                            flag = false;
                                            break;
                                        }
                                    }

                                    if (flag)           //  argument not contain template specification
                                    {
                                        QStringList tokens = argument_found.split(" ");     //  separate argument string into separated tokens
                                        int tokens_count = tokens.size();

                                        if (tokens_count >= 2)  //  argument is built at least from two tokens
                                        {
                                            if (is_cplusplus_keyword(tokens.last()) == false)
                                            {           //  remove identifier from argument string
                                                while (argument_found[argument_found.size() - 1].isLetterOrNumber() || argument_found.right(1) == "_")
                                                    argument_found.chop(1);

                                                while (argument_found[argument_found.size() - 1] == ' ')
                                                    argument_found.chop(1);
                                            }
                                        }
                                    }
                                    else                //  argument not contain template specification
                                    {                   //  remove identifier from argument string
                                        while (argument_found[argument_found.size() - 1].isLetterOrNumber() || argument_found.right(1) == "_")
                                            argument_found.chop(1);

                                        while (argument_found[argument_found.size() - 1] == ' ')
                                            argument_found.chop(1);
                                    }

                                    argument_found.push_back(rest);     //  push all array brackets back into argument string

                                    if (found.right(1) == "(")  //  insert first argument into string after starting bracket
                                        found += argument_found;
                                    else
                                        found = found + "," + argument_found;   //  insert rest argument into string
                                }
                            }
                        }

                        found.push_back(')');           //  close pushed arguments with classic bracket

                        if (string_tail.size())
                        {
                            found.push_back(' ');
                            found.push_back(string_tail);   //  push original string tail with possible type qualifiers
                        }

                        found.replace(" ", "  ");       //  double all space characters in content string
                        found.replace(",", ",  ");      //  insert space character after every comma character inside content string
                        found.replace("(", " (");       //  insert space character before every left classic bracket inside content string

                        bool conflict = false;
                        int N = constructors.size();    //  get actual number of found class constructors

                        for (int j = 0; j < N; j++)
                        {
                            if (constructors[j] == found)   //  check if same class constructor is already in array of all constructors
                            {
                                conflict = true;
                                break;
                            }
                        }

                        if (conflict == false)          //  class constructor is not yet in array of all constructors
                        {
                            constructors.push_back(found);  //  push found class constructor into array

                            while (found.right(1) == " ")
                                found.chop(1);          //  removed explicit space characters from end of the string

                            Class_tree_child child;     //  create child description of actual class item

                            if (is_definition)
                                child.to = from + removed_spaces[from + 1] + 1;   //  get starting position of matched content
                            else
                                child.from = from + removed_spaces[from + 1] + 1;   //  get starting position of matched content

                            child.content = found;
                            class_tree_parents[i].children.push_back(child);    //  insert child description into parent attribute array

                            QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  create child of actual class item in class tree
                            tree_child->setText(0, found);  //  set child item text to modified matched string
                                                        //  check visibility of matched content using visibility array
                            if (visibility[from] == '0')    //  visibility of matched content is private
                            {                           //  set appropriate icon and tooltip by class item type and its visibility
                                tree_child->setIcon(0, * private_method_icon);
                                tree_child->setToolTip(0, "Private constructor");
                            }
                            else if (visibility[from] == '1')   //  visibility of matched content is protected
                            {                           //  set appropriate icon and tooltip by class item type and its visibility
                                tree_child->setIcon(0, * protected_method_icon);
                                tree_child->setToolTip(0, "Protected constructor");
                            }
                            else                        //  visibility of matched content is public
                            {                           //  set appropriate icon and tooltip by class item type and its visibility
                                tree_child->setIcon(0, * public_method_icon);
                                tree_child->setToolTip(0, "Public constructor");
                            }

                            tree_parent->addChild(tree_child);  //  push child item into actual class item in class tree
                        }
                    }
                }

                regex.setPattern(QString("~%1\\((void){0,1}\\)([{]|[;])").arg(class_name));      //  regular expression to match class destructor string

                if (regex.isValid())                    //  check if regular expression of rule is valid
                {
                    int count = 0;                      //  holds number of found class destructors

                    QRegularExpressionMatchIterator match_iter = regex.globalMatch(sub_content);

                    while (match_iter.hasNext())        //  iterate through all regular expression matches
                    {
                        QRegularExpressionMatch match = match_iter.next();

                        if (count)                      //  only one class destructor can be present
                            break;

                        int from = match.capturedStart();   //  save starting index of matched content into variable

                        QString found = match.captured();   //  save matched content into string variable

                        if (found.contains("(void)"))
                            found.remove(found.indexOf("(") + 1, 4);

                        bool is_definition = false;

                        if (found.right(1) == "{")
                            is_definition = true;

                        found.chop(1);                  //  remove { or ; character from end fo string

                        Class_tree_child child;         //  create child description of actual class item

                        if (is_definition)
                            child.to = from + removed_spaces[from + 1] + 1;   //  get starting position of matched content
                        else
                            child.from = from + removed_spaces[from + 1] + 1;   //  get starting position of matched content

                        found.replace("(", " (");

                        child.content = found;
                        class_tree_parents[i].children.push_back(child);    //  insert child description into parent attribute array

                        QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  create child of actual class item in class tree
                        tree_child->setText(0, found);  //  set child item text to matched string

                        if (visibility[from] == '0')
                        {                               //  set appropriate icon and tooltip by class item type and its visibility
                            tree_child->setIcon(0, * private_method_icon);
                            tree_child->setToolTip(0, "Private destructor");
                        }
                        else if (visibility[from] == '1')
                        {                               //  set appropriate icon and tooltip by class item type and its visibility
                            tree_child->setIcon(0, * protected_method_icon);
                            tree_child->setToolTip(0, "Protected destructor");
                        }
                        else
                        {                               //  set appropriate icon and tooltip by class item type and its visibility
                            tree_child->setIcon(0, * public_method_icon);
                            tree_child->setToolTip(0, "Public destructor");
                        }

                        tree_parent->addChild(tree_child);  //  push child item into actual class item in class tree
                        count++;                        //  increment destructors counter value
                    }
                }

                vector<QString> methods;                //  array which will hold strings of all found class methods
                                                        //  regular expression to match class method string
                regex.setPattern("((static )|(const )|(volatile )){0,3}"
                                 "[A-Za-z_][A-Za-z0-9_]*"
                                 "(( [A-Za-z_][A-Za-z0-9_]*){0,3}|(\\<[A-Za-z_][A-Za-z0-9_\\<\\>.:,*&\\[\\] ]*\\>))"
                                 "(( static)|( const)|( volatile)){0,3}"
                                 "(([*]+(const ){0,1})|&| )"
                                 "[A-Za-z_][A-Za-z0-9_]*"
                                 "\\([A-Za-z0-9_\\<\\>.,*&\\[\\]= ]*\\)((const override)|(const)|(override)){0,1}"
                                 "([{]|[;])");

                if (regex.isValid())                    //  check if regular expression of rule is valid
                {
                    QRegularExpressionMatchIterator match_iter = regex.globalMatch(sub_content);

                    while (match_iter.hasNext())        //  iterate through all regular expression matches
                    {
                        QRegularExpressionMatch match = match_iter.next();

                        int from = match.capturedStart();   //  save starting index of matched content into variable
                        QString found = match.captured();   //  save matched content into string variable

                        bool is_definition = false;

                        if (found.right(1) == "{")
                            is_definition = true;

                        if (found.left(8) == "explicit")
                            continue;

                        found.chop(1);                  //  remove { or ; character from end fo string

                        QString string_tail;

                        while (found.right(1) != ")")   //  remove rest of matched content after closing classic bracket
                        {
                            string_tail.push_front(found.right(1));
                            found.chop(1);
                        }

                        int arguments_from = found.indexOf('(');    //  save method arguments substring into variable
                        QString arguments_string = found.mid(arguments_from, match.capturedEnd() - arguments_from);
                        found.remove(arguments_from + 1, match.capturedEnd() - arguments_from);

                        if (check_class_element(found))
                        {
                            QRegularExpression arguments_regex;     //  regular expression to match attribute string of class constructor
                            arguments_regex.setPattern("((static )|(const )|(volatile )){0,3}"
                                                       "[A-Za-z_][A-Za-z0-9_]*"
                                                       "(( [A-Za-z_][A-Za-z0-9_]*){0,3}|(\\<[A-Za-z_][A-Za-z0-9_\\<\\>.:,*&\\[\\] ]*\\>))"
                                                       "(( static)|( const)|( volatile)){0,3}"
                                                       "(((([*]+(const){0,1})|(&*))(\\[[A-Za-z0-9.]*\\])*)|"
                                                       "((([*]+(const ){0,1})|&| )[A-Za-z_][A-Za-z0-9_]*(\\[[A-Za-z0-9.]*\\])*))"
                                                       "[),=]");
                            arguments_regex.optimize();

                            if (arguments_regex.isValid())  //  check if regular expression of rule is valid
                            {
                                QRegularExpressionMatchIterator match_iter = arguments_regex.globalMatch(arguments_string);

                                while (match_iter.hasNext())    //  iterate through all regular expression matches
                                {
                                    QRegularExpressionMatch match = match_iter.next();
                                    QString argument_found = match.captured();
                                    argument_found.chop(1);

                                    if (check_class_element(argument_found))    //  check validity of found argument
                                    {
                                        if (argument_found.left(7) == "static ")
                                            argument_found.remove(0, 7);

                                        QString rest = "";  //  holds ending array brackets sequence

                                        while (argument_found.right(1) == "]" || argument_found.right(1) == "[")
                                        {
                                            rest.push_front(argument_found.right(1));
                                            argument_found.chop(1);     //  remove all array brackets from end of argument
                                        }

                                        int N = argument_found.size();
                                        bool flag = true;

                                        for (int j = 0; j < N; j++)     //  check if argument do not contain template specification
                                        {
                                            if (!argument_found[j].isLetterOrNumber() && argument_found[j] != '_' && argument_found[j] != ' ')
                                            {
                                                flag = false;
                                                break;
                                            }
                                        }

                                        if (flag)       //  argument not contain template specification
                                        {
                                            QStringList tokens = argument_found.split(" ");     //  separate argument string into separated tokens
                                            int tokens_count = tokens.size();

                                            if (tokens_count >= 2)  //  argument is built at least from two tokens
                                            {
                                                if (is_cplusplus_keyword(tokens.last()) == false)
                                                {       //  remove identifier from argument string
                                                    while (argument_found[argument_found.size() - 1].isLetterOrNumber() || argument_found.right(1) == "_")
                                                        argument_found.chop(1);

                                                    while (argument_found[argument_found.size() - 1] == ' ')
                                                        argument_found.chop(1);
                                                }
                                            }
                                        }
                                        else            //  argument not contain template specification
                                        {               //  remove identifier from argument string
                                            while (argument_found[argument_found.size() - 1].isLetterOrNumber() || argument_found.right(1) == "_")
                                                argument_found.chop(1);

                                            while (argument_found[argument_found.size() - 1] == ' ')
                                                argument_found.chop(1);
                                        }

                                        argument_found.push_back(rest);     //  push all array brackets back into argument string
                                                        //  insert found valid argument into method content string again
                                        if (found.right(1) == "(")
                                            found += argument_found;    //  insert first argument into string after starting bracket
                                        else
                                            found = found + "," + argument_found;   //  insert rest argument into string
                                    }
                                }
                            }

                            found.push_back(')');       //  close pushed arguments with classic bracket

                            if (string_tail.size())
                            {
                                found.push_back(' ');
                                found.push_back(string_tail);   //  push original string tail with possible type qualifiers
                            }

                            found.replace(" ", "  ");   //  double all space characters in content string
                            found.replace(",", ",  ");  //  insert space character after every comma character inside content string
                            found.replace("(", " (");   //  insert space character before every left classic bracket inside content string

                            bool conflict = false;
                            int N = methods.size();     //  get actual number of found class methods

                            for (int j = 0; j < N; j++)     //  check if same class method is already in array of all methods
                            {
                                if (methods[j] == found)
                                {
                                    conflict = true;
                                    break;
                                }
                            }

                            if (conflict == false)      //  class method is not yet in array of all methods
                            {
                                methods.push_back(found);   //  push found class method into array

                                while (found.right(1) == " ")
                                    found.chop(1);      //  removed explicit space characters from end of the string

                                Class_tree_child child;     //  create child description of actual class item

                                if (is_definition)
                                    child.to = from + removed_spaces[from + 1];   //  get starting position of matched content
                                else
                                    child.from = from + removed_spaces[from + 1];   //  get starting position of matched content

                                child.content = found;
                                class_tree_parents[i].children.push_back(child);    //  insert child description into parent attribute array

                                bool is_static = false;

                                if (found.left(8) == "static  ")    //  check if found method is static
                                {
                                    found.remove(0, 8);
                                    is_static = true;   //  found method is static
                                }

                                QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  create child of actual class item in class tree
                                tree_child->setText(0, found);  //  set child item text to modified matched string
                                                        //  check visibility of matched content using visibility array
                                if (visibility[from] == '0')    //  visibility of matched content is private
                                {
                                    if (is_static)      //  found method is static
                                    {                   //  set appropriate icon and tooltip by class item type and its visibility
                                        tree_child->setIcon(0, * static_private_method_icon);
                                        tree_child->setToolTip(0, "Static private method");
                                    }
                                    else                //  found method is not static
                                    {                   //  set appropriate icon and tooltip by class item type and its visibility
                                        tree_child->setIcon(0, * private_method_icon);
                                        tree_child->setToolTip(0, "Private method");
                                    }
                                }
                                else if (visibility[from] == '1')   //  visibility of matched content is protected
                                {
                                    if (is_static)      //  found method is static
                                    {                   //  set appropriate icon and tooltip by class item type and its visibility
                                        tree_child->setIcon(0, * static_protected_method_icon);
                                        tree_child->setToolTip(0, "Static protected method");
                                    }
                                    else                //  found method is not static
                                    {                   //  set appropriate icon and tooltip by class item type and its visibility
                                        tree_child->setIcon(0, * protected_method_icon);
                                        tree_child->setToolTip(0, "Protected method");
                                    }
                                }
                                else                    //  visibility of matched content is public
                                {
                                    if (is_static)      //  found method is static
                                    {                   //  set appropriate icon and tooltip by class item type and its visibility
                                        tree_child->setIcon(0, * static_public_method_icon);
                                        tree_child->setToolTip(0, "Static public method");
                                    }
                                    else                //  found method is not static
                                    {                   //  set appropriate icon and tooltip by class item type and its visibility
                                        tree_child->setIcon(0, * public_method_icon);
                                        tree_child->setToolTip(0, "Public method");
                                    }
                                }

                                tree_parent->addChild(tree_child);  //  push child item into actual class item in class tree
                            }
                        }
                    }
                }

                vector<QString> attributes;             //  array which will hold strings of all found class attributes
                                                        //  regular expression to match class attribute string
                regex.setPattern("[\\{\\};:]"
                                 "((static )|(const )|(volatile )){0,3}"
                                 "[A-Za-z_][A-Za-z0-9_]*"
                                 "(( [A-Za-z_][A-Za-z0-9_]*){0,3}|(\\<[A-Za-z_][A-Za-z0-9_\\<\\>.:,*&\\[\\] ]*\\>))"
                                 "(( static)|( const)|( volatile)){0,3}"
                                 "(([*]+(const ){0,1})|&| )"
                                 "[A-Za-z_][A-Za-z0-9_]*"
                                 "(\\[[A-Za-z0-9.]*\\])*(?=(;|=|,))");

                if (regex.isValid())                    //  check if regular expression of rule is valid
                {
                    QRegularExpressionMatchIterator match_iter = regex.globalMatch(sub_content);

                    while (match_iter.hasNext())        //  iterate through all regular expression matches
                    {
                        QRegularExpressionMatch match = match_iter.next();

                        int from = match.capturedStart();   //  save starting index of matched content into variable
                        QString found = match.captured();   //  save matched content into string variable
                        found.remove(0, 1);

                        if (check_class_element(found))
                        {
                            found.replace(" ", "  ");   //  double all space characters in content string
                            found.replace(",", ",  ");  //  insert space character after every comma character inside content string

                            bool conflict = false;
                            int N = attributes.size();  //  get actual number of found class attributes

                            for (int j = 0; j < N; j++)     //  check if same class attribute is already in array of all attributes
                            {
                                if (attributes[j] == found)
                                {
                                    conflict = true;
                                    break;
                                }
                            }

                            if (conflict == false)      //  class attribute is not yet in array of all attributes
                            {
                                attributes.push_back(found);    //  push found class attribute into array

                                Class_tree_child child;     //  create child description of actual class item
                                child.from = from + removed_spaces[from + 1] + 1;   //  get starting position of matched content
                                child.content = found;
                                class_tree_parents[i].children.push_back(child);    //  insert child description into parent attribute array

                                bool is_static = false;

                                if (found.left(8) == "static  ")    //  check if found attribute is static
                                {
                                    found.remove(0, 8);
                                    is_static = true;   //  found attribute is static
                                }

                                QStringList tokens = found.split(" ");     //  separate string into separated tokens

                                if (is_cplusplus_keyword(tokens.last()))
                                    continue;

                                QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  create child of actual class item in class tree
                                tree_child->setText(0, found);  //  set child item text to modified matched string
                                                        //  check visibility of matched content using visibility array
                                if (visibility[from] == '0')    //  visibility of matched content is private
                                {
                                    if (is_static)      //  found attribute is static
                                    {                   //  set appropriate icon and tooltip by class item type and its visibility
                                        tree_child->setIcon(0, * static_private_attribute_icon);
                                        tree_child->setToolTip(0, "Static private attribute");
                                    }
                                    else                //  found attribute is not static
                                    {                   //  set appropriate icon and tooltip by class item type and its visibility
                                        tree_child->setIcon(0, * private_attribute_icon);
                                        tree_child->setToolTip(0, "Private attribute");
                                    }
                                }
                                else if (visibility[from] == '1')   //  visibility of matched content is private
                                {
                                    if (is_static)      //  found attribute is static
                                    {                   //  set appropriate icon and tooltip by class item type and its visibility
                                        tree_child->setIcon(0, * static_protected_attribute_icon);
                                        tree_child->setToolTip(0, "Static protected attribute");
                                    }
                                    else                //  found attribute is not static
                                    {                   //  set appropriate icon and tooltip by class item type and its visibility
                                        tree_child->setIcon(0, * protected_attribute_icon);
                                        tree_child->setToolTip(0, "Protected attribute");
                                    }
                                }
                                else                    //  visibility of matched content is private
                                {
                                    if (is_static)      //  found attribute is static
                                    {                   //  set appropriate icon and tooltip by class item type and its visibility
                                        tree_child->setIcon(0, * static_public_attribute_icon);
                                        tree_child->setToolTip(0, "Static public attribute");
                                    }
                                    else                //  found attribute is not static
                                    {                   //  set appropriate icon and tooltip by class item type and its visibility
                                        tree_child->setIcon(0, * public_attribute_icon);
                                        tree_child->setToolTip(0, "Public attribute");
                                    }
                                }

                                tree_parent->addChild(tree_child);  //  push child item into actual class item in class tree
                            }
                        }
                    }
                }
            }
        }

        int struct_count = 0;                           //  holds number of found headers of C++ structures

        regex.setPattern("struct[ \t\n]+[A-Za-z_][A-Za-z0-9_]*[ \t\n]*{");
        regex.setPatternOptions(QRegularExpression::DotMatchesEverythingOption);

        if (regex.isValid())                            //  check if regular expression of rule is valid
        {
            int N = content.size();
            QRegularExpressionMatchIterator match_iter = regex.globalMatch(content);     //  check for global match of regular expression from rule

            while (match_iter.hasNext())                //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                int from = match.capturedStart();       //  save range of actual match
                int to = match.capturedEnd();
                int bracket_count = 1;

                for (int i = to; i < N; i++)            //  check if block brackets below structure header are matching
                {
                    if (content[i] == '{')
                        bracket_count++;
                    else if (content[i] == '}')
                    {
                        bracket_count--;

                        if (bracket_count == 0)         //  body of actual C++ block found
                        {
                            Class_tree_parent temp_structure;   //  push new class item into class tree description array
                            temp_structure.from = from;
                            temp_structure.to = i + 1;
                            class_tree_parents.push_back(temp_structure);
                            struct_count++;

                            break;
                        }
                    }
                }
            }
        }

        N = class_tree_parents.size();

        if (struct_count)                               //  at least one valid C++ structure body found
        {
            for (int i = enum_count + class_count; i < N; i++)  //  iterate through all found structure bodies
            {                                           //  save structure body into separate string object
                QString sub_content = content.mid(class_tree_parents[i].from, class_tree_parents[i].to - class_tree_parents[i].from);
                int N = sub_content.size();             //  get actual size of structure body string

                for (int j = sub_content.indexOf('{') + 1; j < N; j++)  //  find starting block bracket in structure body string
                {
                    if (sub_content[j] == '{')
                    {
                        int block_bracket_count = 1;
                        j++;

                        while (j < N)
                        {
                            if (sub_content[j] == '{')
                                block_bracket_count++;
                            else if (sub_content[j] == '}')
                                block_bracket_count--;

                            if (block_bracket_count == 0)
                                break;
                            else
                                sub_content[j] = ' ';   //  remove all bodies of all methods location inside body of actual structure

                            j++;
                        }
                    }
                }

                for (int j = 0; j < N; j++)             //  replace all tabs and newlines by space characters
                {
                    if (sub_content[j] == '\t' || sub_content[j] == '\n')
                        sub_content[j] = ' ';
                }

                QList<int> removed_spaces;              //  holds number of removed spaces for every index of structure body string
                int count = 0;                          //  holds count of removed spaces
                int j = 0;

                while (j < N)                           //  remove all explicit spaces from structure body string
                {
                    if (sub_content[j] == ' ')
                    {
                        removed_spaces.push_back(count);

                        while (sub_content[j + 1] == ' ')
                        {
                            count++;
                            sub_content.remove(j + 1, 1);   //  save count of removed spaces into appropriate index of array
                        }

                        j++;
                    }
                    else
                    {
                        removed_spaces.push_back(count);
                        j++;
                    }
                }

                N = sub_content.size() - 1;             //  get actual size of structure body string
                j = 1;

                while (j < N)
                {
                    if (sub_content[j] == ' ')          //  remove all spaces from structure string except spaces inside identifier valid characters
                    {
                        if ((sub_content[j - 1].isLetterOrNumber() || sub_content[j - 1] == '_') &&
                            (sub_content[j + 1].isLetterOrNumber() || sub_content[j + 1] == '_'))
                        {
                            j++;
                        }
                        else
                        {
                            int M = removed_spaces.size();

                            for (int k = j + 1; k < M; k++)
                                removed_spaces[k]++;    //  update count of removed spaces in array

                            removed_spaces.removeAt(j);
                            sub_content.remove(j, 1);
                            N--;
                        }
                    }
                    else
                        j++;
                }

                QString temp_content = sub_content;
                sub_content.clear();
                N = temp_content.size();                //  get actual size of structure body string

                for (int j = 0; j < N; j++)
                {
                    sub_content.push_back(temp_content[j]);

                    if (temp_content[j] == '>')         //  add space character after greater-than characters
                    {
                        int M = removed_spaces.size();

                        for (int k = j + 1; k < M; k++)
                            removed_spaces[k]--;        //  update count of removed spaces in array

                        removed_spaces.insert(j + 1, removed_spaces[j + 0]);
                        sub_content.push_back(' ');
                    }
                }

                N = sub_content.size();                 //  get actual size of structure body string

                QTreeWidgetItem * tree_parent = new QTreeWidgetItem;    //  insert actual class as child item into class tree
                tree_parent->setIcon(0, * struct_icon);
                tree_parent->setToolTip(0, "Struct");
                tree_root->addChild(tree_parent);

                QString structure_name = sub_content.mid(7, sub_content.indexOf('{') - 7);     //  get structure name from structure body string
                tree_parent->setText(0, structure_name);
                class_tree_parents[i].content = structure_name;

                vector<QString> attributes;             //  array which will hold strings of all found structure attributes
                                                        //  regular expression to match structure attribute string
                regex.setPattern("[\\{\\};]"
                                 "((static )|(const )|(volatile )){0,3}"
                                 "[A-Za-z_][A-Za-z0-9_]*"
                                 "(( [A-Za-z_][A-Za-z0-9_]*){0,3}|(\\<[A-Za-z_][A-Za-z0-9_\\<\\>.:,*&\\[\\] ]*\\>))"
                                 "(( static)|( const)|( volatile)){0,3}"
                                 "(([*]+(const ){0,1})|&| )"
                                 "[A-Za-z_][A-Za-z0-9_]*"
                                 "(\\[[A-Za-z0-9.]*\\])*(?=(;|=|,))");

                if (regex.isValid())                    //  check if regular expression of rule is valid
                {
                    QRegularExpressionMatchIterator match_iter = regex.globalMatch(sub_content);

                    while (match_iter.hasNext())        //  iterate through all regular expression matches
                    {
                        QRegularExpressionMatch match = match_iter.next();

                        int from = match.capturedStart();   //  save starting index of matched content into variable
                        QString found = match.captured();   //  save matched content into string variable
                        found.remove(0, 1);

                        if (check_class_element(found))
                        {
                            found.replace(" ", "  ");   //  double all space characters in content string
                            found.replace(",", ",  ");  //  insert space character after every comma character inside content string

                            bool conflict = false;
                            int N = attributes.size();  //  get actual number of found structure attributes

                            for (int j = 0; j < N; j++)     //  check if same structure attribute is already in array of all attributes
                            {
                                if (attributes[j] == found)
                                {
                                    conflict = true;
                                    break;
                                }
                            }

                            if (conflict == false)      //  structure attribute is not yet in array of all attributes
                            {
                                attributes.push_back(found);    //  push found structure attribute into array

                                Class_tree_child child;     //  create child description of actual class item
                                child.from = from + removed_spaces[from + 1] + 1;   //  get starting position of matched content
                                child.content = found;
                                class_tree_parents[i].children.push_back(child);    //  insert child description into parent attribute array

                                bool is_static = false;

                                if (found.left(8) == "static  ")    //  check if found attribute is static
                                {
                                    found.remove(0, 8);
                                    is_static = true;   //  found attribute is static
                                }

                                QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  create child of actual class item in class tree
                                tree_child->setText(0, found);  //  set child item text to modified matched string
                                                        //  check visibility of matched content using visibility array
                                if (is_static)          //  found attribute is static
                                {                       //  set appropriate icon and tooltip by class item type and its visibility
                                    tree_child->setIcon(0, * static_public_attribute_icon);
                                    tree_child->setToolTip(0, "Static attribute");
                                }
                                else                    //  found attribute is not static
                                {                       //  set appropriate icon and tooltip by class item type and its visibility
                                    tree_child->setIcon(0, * public_attribute_icon);
                                    tree_child->setToolTip(0, "Attribute");
                                }

                                tree_parent->addChild(tree_child);  //  push child item into actual class item in class tree
                            }
                        }
                    }
                }
            }
        }

        int union_count = 0;                            //  holds number of found headers of C++ unions

        regex.setPattern("union[ \t\n]+[A-Za-z_][A-Za-z0-9_]*[ \t\n]*{");
        regex.setPatternOptions(QRegularExpression::DotMatchesEverythingOption);

        if (regex.isValid())                            //  check if regular expression of rule is valid
        {
            int N = content.size();
            QRegularExpressionMatchIterator match_iter = regex.globalMatch(content);     //  check for global match of regular expression from rule

            while (match_iter.hasNext())                //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                int from = match.capturedStart();       //  save range of actual match
                int to = match.capturedEnd();
                int bracket_count = 1;

                for (int i = to; i < N; i++)            //  check if block brackets below union header are matching
                {
                    if (content[i] == '{')
                        bracket_count++;
                    else if (content[i] == '}')
                    {
                        bracket_count--;

                        if (bracket_count == 0)         //  body of actual C++ block found
                        {
                            Class_tree_parent temp_union;   //  push new class item into class tree description array
                            temp_union.from = from;
                            temp_union.to = i + 1;
                            class_tree_parents.push_back(temp_union);
                            union_count++;

                            break;
                        }
                    }
                }
            }
        }

        N = class_tree_parents.size();

        if (union_count)                                //  at least one valid C++ union body found
        {
            for (int i = enum_count + class_count + struct_count; i < N; i++)    //  iterate through all found union bodies
            {                                           //  save union body into separate string object
                QString sub_content = content.mid(class_tree_parents[i].from, class_tree_parents[i].to - class_tree_parents[i].from);
                int N = sub_content.size();             //  get actual size of union body string

                for (int j = sub_content.indexOf('{') + 1; j < N; j++)  //  find starting block bracket in union body string
                {
                    if (sub_content[j] == '{')
                    {
                        int block_bracket_count = 1;
                        j++;

                        while (j < N)
                        {
                            if (sub_content[j] == '{')
                                block_bracket_count++;
                            else if (sub_content[j] == '}')
                                block_bracket_count--;

                            if (block_bracket_count == 0)
                                break;
                            else
                                sub_content[j] = ' ';   //  remove all bodies of all methods location inside body of actual union

                            j++;
                        }
                    }
                }

                for (int j = 0; j < N; j++)             //  replace all tabs and newlines by space characters
                {
                    if (sub_content[j] == '\t' || sub_content[j] == '\n')
                        sub_content[j] = ' ';
                }

                QList<int> removed_spaces;              //  holds number of removed spaces for every index of union body string
                int count = 0;                          //  holds count of removed spaces
                int j = 0;

                while (j < N)                           //  remove all explicit spaces from union body string
                {
                    if (sub_content[j] == ' ')
                    {
                        removed_spaces.push_back(count);

                        while (sub_content[j + 1] == ' ')
                        {
                            count++;
                            sub_content.remove(j + 1, 1);   //  save count of removed spaces into appropriate index of array
                        }

                        j++;
                    }
                    else
                    {
                        removed_spaces.push_back(count);
                        j++;
                    }
                }

                N = sub_content.size() - 1;             //  get actual size of union body string
                j = 1;

                while (j < N)
                {
                    if (sub_content[j] == ' ')          //  remove all spaces from union string except spaces inside identifier valid characters
                    {
                        if ((sub_content[j - 1].isLetterOrNumber() || sub_content[j - 1] == '_') &&
                            (sub_content[j + 1].isLetterOrNumber() || sub_content[j + 1] == '_'))
                        {
                            j++;
                        }
                        else
                        {
                            int M = removed_spaces.size();

                            for (int k = j + 1; k < M; k++)
                                removed_spaces[k]++;    //  update count of removed spaces in array

                            removed_spaces.removeAt(j);
                            sub_content.remove(j, 1);
                            N--;
                        }
                    }
                    else
                        j++;
                }

                QString temp_content = sub_content;
                sub_content.clear();
                N = temp_content.size();                //  get actual size of union body string

                for (int j = 0; j < N; j++)
                {
                    sub_content.push_back(temp_content[j]);

                    if (temp_content[j] == '>')         //  add space character after greater-than characters
                    {
                        int M = removed_spaces.size();

                        for (int k = j + 1; k < M; k++)
                            removed_spaces[k]--;        //  update count of removed spaces in array

                        removed_spaces.insert(j + 1, removed_spaces[j + 0]);
                        sub_content.push_back(' ');
                    }
                }

                N = sub_content.size();                 //  get actual size of union body string

                QTreeWidgetItem * tree_parent = new QTreeWidgetItem;    //  insert actual class as child item into class tree
                tree_parent->setIcon(0, * struct_icon);
                tree_parent->setToolTip(0, "Union");
                tree_root->addChild(tree_parent);

                QString class_name = sub_content.mid(6, sub_content.indexOf('{') - 6);  //  get union name from union body string
                tree_parent->setText(0, class_name);
                class_tree_parents[i].content = class_name;

                vector<QString> attributes;             //  array which will hold strings of all found union attributes
                                                        //  regular expression to match union attribute string
                regex.setPattern("[\\{\\};]"
                                 "((static )|(const )|(volatile )){0,3}"
                                 "[A-Za-z_][A-Za-z0-9_]*"
                                 "(( [A-Za-z_][A-Za-z0-9_]*){0,3}|(\\<[A-Za-z_][A-Za-z0-9_\\<\\>.:,*&\\[\\] ]*\\>))"
                                 "(( static)|( const)|( volatile)){0,3}"
                                 "(([*]+(const ){0,1})|&| )"
                                 "[A-Za-z_][A-Za-z0-9_]*"
                                 "(\\[[A-Za-z0-9.]*\\])*(?=(;|=|,))");

                if (regex.isValid())                    //  check if regular expression of rule is valid
                {
                    QRegularExpressionMatchIterator match_iter = regex.globalMatch(sub_content);

                    while (match_iter.hasNext())        //  iterate through all regular expression matches
                    {
                        QRegularExpressionMatch match = match_iter.next();

                        int from = match.capturedStart();   //  save starting index of matched content into variable
                        QString found = match.captured();   //  save matched content into string variable
                        found.remove(0, 1);

                        if (check_class_element(found))
                        {
                            found.replace(" ", "  ");   //  double all space characters in content string
                            found.replace(",", ",  ");  //  insert space character after every comma character inside content string

                            bool conflict = false;
                            int N = attributes.size();  //  get actual number of found union attributes

                            for (int j = 0; j < N; j++)     //  check if same union attribute is already in array of all attributes
                            {
                                if (attributes[j] == found)
                                {
                                    conflict = true;
                                    break;
                                }
                            }

                            if (conflict == false)      //  union attribute is not yet in array of all attributes
                            {
                                attributes.push_back(found);    //  push found union attribute into array

                                Class_tree_child child;     //  create child description of actual class item
                                child.from = from + removed_spaces[from + 1] + 1;   //  get starting position of matched content
                                child.content = found;
                                class_tree_parents[i].children.push_back(child);    //  insert child description into parent attribute array

                                bool is_static = false;

                                if (found.left(8) == "static  ")    //  check if found attribute is static
                                {
                                    found.remove(0, 8);
                                    is_static = true;   //  found attribute is static
                                }

                                QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  create child of actual class item in class tree
                                tree_child->setText(0, found);  //  set child item text to modified matched string
                                                        //  check visibility of matched content using visibility array
                                if (is_static)          //  found attribute is static
                                {                       //  set appropriate icon and tooltip by class item type and its visibility
                                    tree_child->setIcon(0, * static_public_attribute_icon);
                                    tree_child->setToolTip(0, "Static attribute");
                                }
                                else                    //  found attribute is not static
                                {                       //  set appropriate icon and tooltip by class item type and its visibility
                                    tree_child->setIcon(0, * public_attribute_icon);
                                    tree_child->setToolTip(0, "Attribute");
                                }

                                tree_parent->addChild(tree_child);  //  push child item into actual class item in class tree
                            }
                        }
                    }
                }
            }
        }

        for (int i = 0; i < N; i++)                     //  iterate through all found class bodies
        {
            for (int j = class_tree_parents[i].from; j < class_tree_parents[i].to; j++)
                content[j] = ' ';
        }

        N = content.size();                             //  get actual size of class body string

        for (int j = 0; j < N; j++)                     //  find starting block bracket in class body string
        {
            if (content[j] == '{')
            {
                int block_bracket_count = 1;
                j++;

                while (j < N)
                {
                    if (content[j] == '{')
                        block_bracket_count++;
                    else if (content[j] == '}')
                        block_bracket_count--;

                    if (block_bracket_count == 0)
                        break;
                    else
                        content[j] = ' ';               //  remove all bodies of all methods location inside body of actual class

                    j++;
                }
            }
        }

        for (int j = 0; j < N; j++)                     //  replace all tabs and newlines by space characters
        {
            if (content[j] == '\t' || content[j] == '\n')
                content[j] = ' ';
        }

        QList<int> removed_spaces;                      //  holds number of removed spaces for every index of class body string
        int count = 0;                                  //  holds count of removed spaces
        int j = 0;

        while (j < N)                                   //  remove all explicit spaces from class body string
        {
            if (content[j] == ' ')
            {
                removed_spaces.push_back(count);

                while (content[j + 1] == ' ')
                {
                    count++;
                    content.remove(j + 1, 1);           //  save count of removed spaces into appropriate index of array
                }

                j++;
            }
            else
            {
                removed_spaces.push_back(count);
                j++;
            }
        }

        N = content.size() - 1;                         //  get actual size of class body string
        j = 1;

        while (j < N)
        {
            if (content[j] == ' ')                      //  remove all spaces from class string except spaces inside identifier valid characters
            {
                if ((content[j - 1].isLetterOrNumber() || content[j - 1] == '_') &&
                    (content[j + 1].isLetterOrNumber() || content[j + 1] == '_'))
                {
                    j++;
                }
                else
                {
                    int M = removed_spaces.size();

                    for (int k = j + 1; k < M; k++)
                        removed_spaces[k]++;            //  update count of removed spaces in array

                    removed_spaces.removeAt(j);
                    content.remove(j, 1);
                    N--;
                }
            }
            else
                j++;
        }

        QString temp_content = content;
        content.clear();
        N = temp_content.size();                        //  get actual size of class body string

        for (int j = 0; j < N; j++)
        {
            content.push_back(temp_content[j]);

            if (temp_content[j] == '>')                 //  add space character after greater-than characters
            {
                int M = removed_spaces.size();

                for (int k = j + 1; k < M; k++)
                    removed_spaces[k]--;                //  update count of removed spaces in array

                removed_spaces.insert(j + 1, removed_spaces[j + 0]);
                content.push_back(' ');
            }
        }

        vector<QString> constructors;                   //  array which will hold strings of all found class constructors
                                                        //  regular expression to match class constructor string
        regex.setPattern(QString("[A-Za-z_][A-Za-z0-9_]*::[A-Za-z_][A-Za-z0-9_]*"
                                 "\\([A-Za-z0-9_\\<\\>.,*&\\[\\]= ]*\\)"
                                 "((const override)|(const)|(override)){0,1}"
                                 "[{]"));

        if (regex.isValid())                            //  check if regular expression of rule is valid
        {
            QRegularExpressionMatchIterator match_iter = regex.globalMatch(content);

            while (match_iter.hasNext())                //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                int from = match.capturedStart();       //  save starting index of matched content into variable
                QString found = match.captured();       //  save matched content into string variable
                QString string_tail = "";

                while (found.right(1) != ")")           //  remove rest of matched content after closing classic bracket
                {
                    string_tail.push_front(found.right(1));
                    found.chop(1);
                }

                QString prefix = found.mid(0, found.indexOf('('));  //  get only prefix of found string without body with arguments

                int colon_index = found.indexOf(':');
                QString class_name = prefix.mid(0, colon_index);    //  get class name from found string
                QString right = prefix.mid(colon_index + 2);

                if (class_name != right)
                    continue;

                found.remove(0, colon_index + 2);       //  remove prefix part from string

                bool flag = true;
                N = class_tree_parents.size();

                for (int j = 0; j < N; j++)             //  check if found class name is present in actual class tree parent class items
                {
                    if (class_tree_parents[j].is_class)
                    {
                        if (class_tree_parents[j].content == class_name)
                        {
                            flag = false;               //  appropriate class found
                            break;
                        }
                    }
                }

                if (flag)
                    continue;                           //  move to next match if class name not found

                int arguments_from = found.indexOf('(');    //  save method arguments substring into variable
                QString arguments_string = found.mid(arguments_from, match.capturedEnd() - arguments_from);
                found.remove(arguments_from + 1, match.capturedEnd() - arguments_from);

                QRegularExpression arguments_regex;     //  regular expression to match attribute string of class constructor
                arguments_regex.setPattern("((static )|(const )|(volatile )){0,3}"
                                           "[A-Za-z_][A-Za-z0-9_]*"
                                           "(( [A-Za-z_][A-Za-z0-9_]*){0,3}|(\\<[A-Za-z_][A-Za-z0-9_\\<\\>.:,*&\\[\\] ]*\\>))"
                                           "(( static)|( const)|( volatile)){0,3}"
                                           "(((([*]+(const){0,1})|(&*))(\\[[A-Za-z0-9.]*\\])*)|"
                                           "((([*]+(const ){0,1})|&| )[A-Za-z_][A-Za-z0-9_]*(\\[[A-Za-z0-9.]*\\])*))"
                                           "[),=]");
                arguments_regex.optimize();

                if (arguments_regex.isValid())          //  check if regular expression of rule is valid
                {
                    QRegularExpressionMatchIterator match_iter = arguments_regex.globalMatch(arguments_string);

                    while (match_iter.hasNext())        //  iterate through all regular expression matches
                    {
                        QRegularExpressionMatch match = match_iter.next();
                        QString argument_found = match.captured();
                        argument_found.chop(1);

                        if (check_class_element(argument_found))    //  check validity of found argument
                        {
                            if (argument_found.left(7) == "static ")
                                argument_found.remove(0, 7);

                            QString rest = "";          //  holds ending array brackets sequence

                            while (argument_found.right(1) == "]" || argument_found.right(1) == "[")
                            {
                                rest.push_front(argument_found.right(1));
                                argument_found.chop(1);     //  remove all array brackets from end of argument
                            }

                            int N = argument_found.size();
                            bool flag = true;

                            for (int j = 0; j < N; j++)     //  check if argument do not contain template specification
                            {
                                if (!argument_found[j].isLetterOrNumber() && argument_found[j] != '_' && argument_found[j] != ' ')
                                {
                                    flag = false;
                                    break;
                                }
                            }

                            if (flag)                   //  argument not contain template specification
                            {
                                QStringList tokens = argument_found.split(" ");     //  separate argument string into separated tokens
                                int tokens_count = tokens.size();

                                if (tokens_count >= 2)  //  argument is built at least from two tokens
                                {
                                    if (is_cplusplus_keyword(tokens.last()) == false)
                                    {                   //  remove identifier from argument string
                                        while (argument_found[argument_found.size() - 1].isLetterOrNumber() || argument_found.right(1) == "_")
                                            argument_found.chop(1);

                                        while (argument_found[argument_found.size() - 1] == ' ')
                                            argument_found.chop(1);
                                    }
                                }
                            }
                            else                        //  argument not contain template specification
                            {                           //  remove identifier from argument string
                                while (argument_found[argument_found.size() - 1].isLetterOrNumber() || argument_found.right(1) == "_")
                                    argument_found.chop(1);

                                while (argument_found[argument_found.size() - 1] == ' ')
                                    argument_found.chop(1);
                            }

                            argument_found.push_back(rest);     //  push all array brackets back into argument string
                                                        //  insert found valid argument into method content string again
                            if (found.right(1) == "(")
                                found += argument_found;    //  insert first argument into string after starting bracket
                            else
                                found = found + "," + argument_found;   //  insert rest argument into string
                        }
                    }
                }

                found.push_back(')');                   //  close pushed arguments with classic bracket

                if (string_tail.size())
                {
                    found.push_back(' ');
                    found.push_back(string_tail);       //  push original string tail with possible type qualifiers
                }

                found.replace(" ", "  ");               //  double all space characters in content string
                found.replace(",", ",  ");              //  insert space character after every comma character inside content string
                found.replace("(", " (");               //  insert space character before every left classic bracket inside content string

                bool conflict = false;
                int N = constructors.size();            //  get actual number of found class constructors

                for (int j = 0; j < N; j++)             //  check if same class method is already in array of all constructors
                {
                    if (constructors[j] == found)
                    {
                        conflict = true;
                        break;
                    }
                }

                if (conflict == false)                  //  class method is not yet in array of all constructors
                {
                    constructors.push_back(found);      //  push found class method into array
                    found.chop(1);                      //  remove { or ; character from end fo string

                    while (found.right(1) == " ")
                        found.chop(1);                  //  removed explicit space characters from end of the string

                    N = class_tree_parents.size();

                    for (int j = 0; j < N; j++)         //  iterate through all items in class tree
                    {
                        if (class_tree_parents[j].is_class)     //  check if actual item is class
                        {
                            if (class_tree_parents[j].content == class_name)    //  check if names of classes are same
                            {
                                int len = class_tree_parents[j].children.size();

                                for (int k = 0; k < len; k++)   //  iterate through all children of actual class
                                {
                                    if (class_tree_parents[j].children[k].content == found)     //  check if child string is same as match string
                                    {
                                        if (class_tree_parents[j].children[k].to == -1)     //  check if item definition is present
                                            class_tree_parents[j].children[k].to = from + removed_spaces[from + 1];
                                                        //  add location of found definition into actual child item
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
                                                        //  regular expression to match class destructor string
        regex.setPattern(QString("[A-Za-z_][A-Za-z0-9_]*::~[A-Za-z_][A-Za-z0-9_]*\\((void){0,1}\\)[{]"));

        if (regex.isValid())                            //  check if regular expression of rule is valid
        {
            QRegularExpressionMatchIterator match_iter = regex.globalMatch(content);

            while (match_iter.hasNext())                //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                int from = match.capturedStart();       //  save starting index of matched content into variable

                Class_tree_child child;                 //  create child description of actual class item
                child.from = from + removed_spaces[from + 1] + 1;   //  get starting position of matched content

                QString found = match.captured();       //  save matched content into string variable

                if (found.contains("(void)"))
                    found.remove(found.indexOf("(") + 1, 4);

                QString prefix = found.mid(0, found.indexOf('('));  //  get only prefix of found string without body with arguments

                int colon_index = found.indexOf(':');
                QString class_name = prefix.mid(0, colon_index);    //  get class name from found string
                QString right = prefix.mid(colon_index + 3);

                if (class_name != right)
                    continue;

                found.remove(0, colon_index + 2);       //  remove prefix part from string

                bool flag = true;
                N = class_tree_parents.size();

                for (int j = 0; j < N; j++)             //  check if found class name is present in actual class tree parent class items
                {
                    if (class_tree_parents[j].is_class)
                    {
                        if (class_tree_parents[j].content == class_name)
                        {
                            flag = false;               //  appropriate class found
                            break;
                        }
                    }
                }

                if (flag)
                    continue;                           //  move to next match if class name not found

                found.replace("(", " (");               //  insert space character before every left classic bracket inside content string
                found.chop(1);

                N = class_tree_parents.size();

                for (int j = 0; j < N; j++)             //  iterate through all items in class tree
                {
                    if (class_tree_parents[j].is_class)     //  check if actual item is class
                    {
                        if (class_tree_parents[j].content == class_name)    //  check if names of classes are same
                        {
                            int len = class_tree_parents[j].children.size();

                            for (int k = 0; k < len; k++)   //  iterate through all children of actual class
                            {
                                if (class_tree_parents[j].children[k].content == found)     //  check if child string is same as match string
                                {
                                    if (class_tree_parents[j].children[k].to == -1)     //  check if item definition is present
                                        class_tree_parents[j].children[k].to = from + removed_spaces[from + 1];
                                                        //  add location of found definition into actual child item
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }

        vector<QString> functions;                      //  array which will hold strings of all found class functions
                                                        //  regular expression to match class method string
        regex.setPattern("((static )|(const )|(volatile )){0,3}"
                         "[A-Za-z_][A-Za-z0-9_]*"
                         "(( [A-Za-z_][A-Za-z0-9_]*){0,3}|(\\<[A-Za-z_][A-Za-z0-9_\\<\\>.:,*&\\[\\] ]*\\>))"
                         "(( static)|( const)|( volatile)){0,3}"
                         "(([*]+(const ){0,1})|&| )"
                         "[A-Za-z_][A-Za-z0-9_]*"
                         "\\([A-Za-z0-9_\\<\\>.,*&\\[\\]= ]*\\)"
                         "([{]|[;])");

        if (regex.isValid())                            //  check if regular expression of rule is valid
        {
            QRegularExpressionMatchIterator match_iter = regex.globalMatch(content);

            while (match_iter.hasNext())                //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                int from = match.capturedStart();       //  save starting index of matched content into variable
                QString found = match.captured();       //  save matched content into string variable

                bool is_definition = false;

                if (found.right(1) == "{")
                    is_definition = true;

                QString string_tail;

                while (found.right(1) != ")")           //  remove rest of matched content after closing classic bracket
                {
                    string_tail.push_front(found.right(1));
                    found.chop(1);
                }

                int arguments_from = found.indexOf('(');    //  save method arguments substring into variable
                QString arguments_string = found.mid(arguments_from, match.capturedEnd() - arguments_from);
                found.remove(arguments_from + 1, match.capturedEnd() - arguments_from);

                QRegularExpression arguments_regex;     //  regular expression to match attribute string of class constructor
                arguments_regex.setPattern("((static )|(const )|(volatile )){0,3}"
                                           "[A-Za-z_][A-Za-z0-9_]*"
                                           "(( [A-Za-z_][A-Za-z0-9_]*){0,3}|(\\<[A-Za-z_][A-Za-z0-9_\\<\\>.:,*&\\[\\] ]*\\>))"
                                           "(( static)|( const)|( volatile)){0,3}"
                                           "(((([*]+(const){0,1})|(&*))(\\[[A-Za-z0-9.]*\\])*)|"
                                           "((([*]+(const ){0,1})|&| )[A-Za-z_][A-Za-z0-9_]*(\\[[A-Za-z0-9.]*\\])*))"
                                           "[),=]");
                arguments_regex.optimize();

                if (arguments_regex.isValid())          //  check if regular expression of rule is valid
                {
                    QRegularExpressionMatchIterator match_iter = arguments_regex.globalMatch(arguments_string);

                    while (match_iter.hasNext())        //  iterate through all regular expression matches
                    {
                        QRegularExpressionMatch match = match_iter.next();
                        QString argument_found = match.captured();
                        argument_found.chop(1);

                        if (check_class_element(argument_found))    //  check validity of found argument
                        {
                            if (argument_found.left(7) == "static ")
                                argument_found.remove(0, 7);

                            QString rest = "";          //  holds ending array brackets sequence

                            while (argument_found.right(1) == "]" || argument_found.right(1) == "[")
                            {
                                rest.push_front(argument_found.right(1));
                                argument_found.chop(1);     //  remove all array brackets from end of argument
                            }

                            int N = argument_found.size();
                            bool flag = true;

                            for (int j = 0; j < N; j++)     //  check if argument do not contain template specification
                            {
                                if (!argument_found[j].isLetterOrNumber() && argument_found[j] != '_' && argument_found[j] != ' ')
                                {
                                    flag = false;
                                    break;
                                }
                            }

                            if (flag)                   //  argument not contain template specification
                            {
                                QStringList tokens = argument_found.split(" ");     //  separate argument string into separated tokens
                                int tokens_count = tokens.size();

                                if (tokens_count >= 2)  //  argument is built at least from two tokens
                                {
                                    if (is_cplusplus_keyword(tokens.last()) == false)
                                    {                   //  remove identifier from argument string
                                        while (argument_found[argument_found.size() - 1].isLetterOrNumber() || argument_found.right(1) == "_")
                                            argument_found.chop(1);

                                        while (argument_found[argument_found.size() - 1] == ' ')
                                            argument_found.chop(1);
                                    }
                                }
                            }
                            else                        //  argument not contain template specification
                            {                           //  remove identifier from argument string
                                while (argument_found[argument_found.size() - 1].isLetterOrNumber() || argument_found.right(1) == "_")
                                    argument_found.chop(1);

                                while (argument_found[argument_found.size() - 1] == ' ')
                                    argument_found.chop(1);
                            }

                            argument_found.push_back(rest);     //  push all array brackets back into argument string
                                                        //  insert found valid argument into method content string again
                            if (found.right(1) == "(")
                                found += argument_found;    //  insert first argument into string after starting bracket
                            else
                                found = found + "," + argument_found;   //  insert rest argument into string
                        }
                    }
                }

                found.push_back(')');                   //  close pushed arguments with classic bracket

                if (string_tail.size())
                {
                    found.push_back(' ');
                    found.push_back(string_tail);       //  push original string tail with possible type qualifiers
                }

                found.replace(" ", "  ");               //  double all space characters in content string
                found.replace(",", ",  ");              //  insert space character after every comma character inside content string
                found.replace("(", " (");               //  insert space character before every left classic bracket inside content string

                bool conflict = false;
                int N = functions.size();               //  get actual number of found class functions

                for (int j = 0; j < N; j++)             //  check if same class method is already in array of all functions
                {
                    if (functions[j] == found)
                    {
                        conflict = true;
                        break;
                    }
                }

                if (conflict == false)                  //  class method is not yet in array of all functions
                {
                    functions.push_back(found);         //  push found class method into array
                    found.chop(1);                      //  remove { or ; character from end fo string

                    while (found.right(1) == " ")
                        found.chop(1);                  //  removed explicit space characters from end of the string

                    N = class_tree_parents.size();
                    conflict = false;

                    for (int j = 0; j < N; j++)         //  iterate through all items in class tree
                    {
                        if (class_tree_parents[j].is_class == false)    //  check if actual item is not class
                        {
                            if (class_tree_parents[j].content == found)     //  check if items of classes are same
                            {
                                if (is_definition)      //  check if item found string is declaration definition
                                    class_tree_parents[j].to = from + removed_spaces[from + 1];     //  refresh appropriate value in item
                                else
                                    class_tree_parents[j].from = from + removed_spaces[from + 1];   //  refresh appropriate value in item

                                conflict = true;        //  definition conflict found
                                break;
                            }
                        }
                    }

                    if (conflict == false)
                    {
                        Class_tree_parent temp_function;    //  push new function item into class tree description array

                        if (is_definition)
                            temp_function.to = from + removed_spaces[from + 1];     //  get starting position of matched content
                        else
                            temp_function.from = from + removed_spaces[from + 1];   //  get starting position of matched content

                        temp_function.is_class = false;
                        temp_function.content = found;
                        class_tree_parents.push_back(temp_function);

                        bool is_static = false;

                        if (found.left(8) == "static  ")    //  check if found method is static
                        {
                            found.remove(0, 8);
                            is_static = true;           //  found method is static
                        }

                        QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  create child of actual class item in class tree
                        tree_child->setText(0, found);  //  set child item text to modified matched string
                                                        //  check visibility of matched content using visibility array
                        if (is_static)                  //  found method is static
                        {                               //  set appropriate icon and tooltip by class item type and its visibility
                            tree_child->setIcon(0, * static_public_method_icon);
                            tree_child->setToolTip(0, "Static function");
                        }
                        else                            //  found method is not static
                        {                               //  set appropriate icon and tooltip by class item type and its visibility
                            tree_child->setIcon(0, * public_method_icon);
                            tree_child->setToolTip(0, "Function");
                        }

                        tree_root->addChild(tree_child);    //  push child item into actual class item in class tree
                    }
                }
            }
        }

        vector<QString> methods;                        //  array which will hold strings of all found class methods
                                                        //  regular expression to match class method string
        regex.setPattern("((static )|(const )|(volatile )){0,3}"
                         "[A-Za-z_][A-Za-z0-9_]*"
                         "(( [A-Za-z_][A-Za-z0-9_]*){0,3}|(\\<[A-Za-z_][A-Za-z0-9_\\<\\>.:,*&\\[\\] ]*\\>))"
                         "(( static)|( const)|( volatile)){0,3}"
                         "(([*]+(const ){0,1})|&| )"
                         "[A-Za-z_][A-Za-z0-9_]*::[A-Za-z_][A-Za-z0-9_]*"
                         "\\([A-Za-z0-9_\\<\\>.,*&\\[\\]= ]*\\)"
                         "[{]");

        if (regex.isValid())                            //  check if regular expression of rule is valid
        {
            QRegularExpressionMatchIterator match_iter = regex.globalMatch(content);

            while (match_iter.hasNext())                //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                int from = match.capturedStart();       //  save starting index of matched content into variable
                QString found = match.captured();       //  save matched content into string variable

                QString string_tail;

                while (found.right(1) != ")")           //  remove rest of matched content after closing classic bracket
                {
                    string_tail.push_front(found.right(1));
                    found.chop(1);
                }

                int j = found.indexOf('(');
                QString class_name = "";                //  holds name of class in string

                while (j >= 0)
                {
                    if (found[j] == ':')                //  try to search colon in string
                    {
                        int from = j;
                        j -= 2;

                        while (found[j].isLetterOrNumber() || found[j] == '_')      //  iterate through string while characters represent identifier
                        {
                            class_name.push_front(found[j]);    //  fill class name string with appropriate substring
                            j--;
                        }

                        found.remove(j + 1, from - j);  //  remove class name from found match string
                        break;
                    }

                    j--;
                }

                bool flag = true;
                N = class_tree_parents.size();

                for (int j = 0; j < N; j++)             //  iterate through all items in class tree
                {
                    if (class_tree_parents[j].is_class)     //  check if actual item is class
                    {
                        if (class_tree_parents[j].content == class_name)    //  check if names of classes are same
                        {
                            flag = false;
                            break;
                        }
                    }
                }

                if (flag)                               //  check if class item conflict is present
                    continue;

                int arguments_from = found.indexOf('(');    //  save method arguments substring into variable
                QString arguments_string = found.mid(arguments_from, match.capturedEnd() - arguments_from);
                found.remove(arguments_from + 1, match.capturedEnd() - arguments_from);

                QRegularExpression arguments_regex;     //  regular expression to match attribute string of class constructor
                arguments_regex.setPattern("((static )|(const )|(volatile )){0,3}"
                                           "[A-Za-z_][A-Za-z0-9_]*"
                                           "(( [A-Za-z_][A-Za-z0-9_]*){0,3}|(\\<[A-Za-z_][A-Za-z0-9_\\<\\>.:,*&\\[\\] ]*\\>))"
                                           "(( static)|( const)|( volatile)){0,3}"
                                           "(((([*]+(const){0,1})|(&*))(\\[[A-Za-z0-9.]*\\])*)|"
                                           "((([*]+(const ){0,1})|&| )[A-Za-z_][A-Za-z0-9_]*(\\[[A-Za-z0-9.]*\\])*))"
                                           "[),=]");
                arguments_regex.optimize();

                if (arguments_regex.isValid())          //  check if regular expression of rule is valid
                {
                    QRegularExpressionMatchIterator match_iter = arguments_regex.globalMatch(arguments_string);

                    while (match_iter.hasNext())        //  iterate through all regular expression matches
                    {
                        QRegularExpressionMatch match = match_iter.next();
                        QString argument_found = match.captured();
                        argument_found.chop(1);

                        if (check_class_element(argument_found))    //  check validity of found argument
                        {
                            if (argument_found.left(7) == "static ")
                                argument_found.remove(0, 7);

                            QString rest = "";          //  holds ending array brackets sequence

                            while (argument_found.right(1) == "]" || argument_found.right(1) == "[")
                            {
                                rest.push_front(argument_found.right(1));
                                argument_found.chop(1);     //  remove all array brackets from end of argument
                            }

                            int N = argument_found.size();
                            bool flag = true;

                            for (int j = 0; j < N; j++)     //  check if argument do not contain template specification
                            {
                                if (!argument_found[j].isLetterOrNumber() && argument_found[j] != '_' && argument_found[j] != ' ')
                                {
                                    flag = false;
                                    break;
                                }
                            }

                            if (flag)                   //  argument not contain template specification
                            {
                                QStringList tokens = argument_found.split(" ");     //  separate argument string into separated tokens
                                int tokens_count = tokens.size();

                                if (tokens_count >= 2)  //  argument is built at least from two tokens
                                {
                                    if (is_cplusplus_keyword(tokens.last()) == false)
                                    {                   //  remove identifier from argument string
                                        while (argument_found[argument_found.size() - 1].isLetterOrNumber() || argument_found.right(1) == "_")
                                            argument_found.chop(1);

                                        while (argument_found[argument_found.size() - 1] == ' ')
                                            argument_found.chop(1);
                                    }
                                }
                            }
                            else                        //  argument not contain template specification
                            {                           //  remove identifier from argument string
                                while (argument_found[argument_found.size() - 1].isLetterOrNumber() || argument_found.right(1) == "_")
                                    argument_found.chop(1);

                                while (argument_found[argument_found.size() - 1] == ' ')
                                    argument_found.chop(1);
                            }

                            argument_found.push_back(rest);     //  push all array brackets back into argument string
                                                        //  insert found valid argument into method content string again
                            if (found.right(1) == "(")
                                found += argument_found;    //  insert first argument into string after starting bracket
                            else
                                found = found + "," + argument_found;   //  insert rest argument into string
                        }
                    }
                }

                found.push_back(')');                   //  close pushed arguments with classic bracket

                if (string_tail.size())
                {
                    found.push_back(' ');
                    found.push_back(string_tail);       //  push original string tail with possible type qualifiers
                }

                found.replace(" ", "  ");               //  double all space characters in content string
                found.replace(",", ",  ");              //  insert space character after every comma character inside content string
                found.replace("(", " (");               //  insert space character before every left classic bracket inside content string

                methods.push_back(found);               //  push found class method into array
                found.chop(1);                          //  remove { or ; character from end fo string

                while (found.right(1) == " ")
                    found.chop(1);                      //  removed explicit space characters from end of the string

                N = class_tree_parents.size();

                for (int j = 0; j < N; j++)             //  iterate through all items in class tree
                {
                    if (class_tree_parents[j].is_class)     //  check if actual item is class
                    {
                        if (class_tree_parents[j].content == class_name)    //  check if names of classes are same
                        {
                            int len = class_tree_parents[j].children.size();

                            for (int k = 0; k < len; k++)   //  iterate through all children of actual class
                            {
                                if (class_tree_parents[j].children[k].content == found)     //  check if child string is same as match string
                                {
                                    if (class_tree_parents[j].children[k].to == -1)     //  check if item definition is present
                                        class_tree_parents[j].children[k].to = from + removed_spaces[from + 1];
                                                        //  add location of found definition into actual child item
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }

        N = content.size();                             //  get actual size of class body string

        for (int j = content.indexOf('('); j < N; j++)  //  find starting block bracket in class body string
        {
            if (content[j] == '(')
            {
                int classic_bracket_count = 1;
                j++;

                while (j < N)
                {
                    if (content[j] == '(')
                        classic_bracket_count++;
                    else if (content[j] == ')')
                        classic_bracket_count--;

                    if (classic_bracket_count == 0)
                        break;
                    else
                        content[j] = ' ';               //  remove all bodies of all methods location inside body of actual class

                    j++;
                }
            }
        }

        vector<QString> variables;                      //  array which will hold strings of all found class variables
                                                        //  regular expression to match variable string
        regex.setPattern("((static )|(const )|(volatile )){0,3}"
                         "[A-Za-z_][A-Za-z0-9_]*"
                         "(( [A-Za-z_][A-Za-z0-9_]*){0,3}|(\\<[A-Za-z_][A-Za-z0-9_\\<\\>.:,*&\\[\\] ]*\\>))"
                         "(( static)|( const)|( volatile)){0,3}"
                         "(([*]+(const ){0,1})|&| )"
                         "[A-Za-z_][A-Za-z0-9_]*"
                         "(\\[[A-Za-z0-9.]*\\])*(?=(;|=|,))");

        if (regex.isValid())                            //  check if regular expression of rule is valid
        {
            QRegularExpressionMatchIterator match_iter = regex.globalMatch(content);

            while (match_iter.hasNext())                //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                int from = match.capturedStart();       //  save starting index of matched content into variable
                QString found = match.captured();       //  save matched content into string variable

                if (check_class_element(found))
                {
                    found.replace(" ", "  ");           //  double all space characters in content string
                    found.replace(",", ",  ");          //  insert space character after every comma character inside content string

                    bool conflict = false;
                    int N = variables.size();           //  get actual number of found class variables

                    for (int j = 0; j < N; j++)         //  check if same class attribute is already in array of all variables
                    {
                        if (variables[j] == found)
                        {
                            conflict = true;
                            break;
                        }
                    }

                    if (conflict == false)              //  class attribute is not yet in array of all variables
                    {
                        variables.push_back(found);     //  push found class attribute into array

                        Class_tree_parent temp_attribute;   //  create child description of actual class item
                        temp_attribute.from = from + removed_spaces[from + 1];  //  get starting position of matched content
                        temp_attribute.content = found;
                        temp_attribute.is_class = false;
                        class_tree_parents.push_back(temp_attribute);   //  insert child description into parent attribute array

                        bool is_static = false;

                        if (found.left(8) == "static  ")    //  check if found attribute is static
                        {
                            found.remove(0, 8);
                            is_static = true;           //  found attribute is static
                        }

                        QStringList tokens = found.split(" ");     //  separate string into separated tokens

                        if (is_cplusplus_keyword(tokens.last()))
                            continue;

                        QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  create child of actual class item in class tree
                        tree_child->setText(0, found);  //  set child item text to modified matched string
                                                        //  check visibility of matched content using visibility array
                        if (is_static)                  //  found attribute is static
                        {                               //  set appropriate icon and tooltip by class item type and its visibility
                            tree_child->setIcon(0, * static_public_attribute_icon);
                            tree_child->setToolTip(0, "Static variable");
                        }
                        else                            //  found attribute is not static
                        {                               //  set appropriate icon and tooltip by class item type and its visibility
                            tree_child->setIcon(0, * public_attribute_icon);
                            tree_child->setToolTip(0, "Variable");
                        }

                        tree_root->addChild(tree_child);    //  push child item into actual class item in class tree
                    }
                }
            }
        }
    }
    else if (actual_language == java)                   //  selected language of actual text editor tab is Java
    {
        QString content = "";
        QStringList files_list;

        if (projects->currentIndex())                   //  check if there is at least one opened project
            files_list = active_projects[projects->currentIndex() - 1].files;
        else
            content = editor[index].document()->toPlainText();

        while (files_list.size())
        {
            int tabs_size = active_tabs.size();
            bool success = true;

            for (int i = 0; i < tabs_size; i++)         //  check if desired file to open is not already opened is text editor
            {
                if (active_tabs[i].file_path == files_list[0])  //  same file cannot be opened twice
                {
                    content.push_back(editor[active_tabs[i].index_in_tabs].document()->toPlainText());
                    success = false;
                    break;
                }
            }

            if (success)
            {
                QFile file(files_list[0]);

                if (file.open(QFile::ReadOnly | QFile::Text))
                {
                    QTextStream fin(&file);
                    content.push_back(fin.readAll());   //  get content of file from disk
                    file.close();
                }
            }

            files_list.pop_front();
        }

        int content_len = content.size();
        remove_comments_and_quotation(content, active_tabs[actual].language);  //  remove all comments and quotation from source code string

        QRegularExpression enum_regex("enum[ \t\n]+[A-Za-z_][A-Za-z0-9_]*[ \t\n]*{");
        enum_regex.optimize();

        if (enum_regex.isValid())                       //  check if regular expression of rule is valid
        {
            QRegularExpressionMatchIterator match_iter = enum_regex.globalMatch(content);   //  check for global match of regular expression from rule

            while (match_iter.hasNext())                //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                int from = match.capturedStart();       //  save starting index of matched content into variable
                int to = match.capturedEnd();           //  save ending index of matched content into variable
                QString header = match.captured();      //  save matched content into string variable

                header.chop(1);
                header.replace('\t', ' ');              //  replace tabs with spaces in matched string
                header.replace('\n', ' ');              //  replace newlines with spaces in matched string
                header = header.simplified();           //  remove explicit white characters using simplify method
                header.remove(0, 5);

                QTreeWidgetItem * tree_parent = new QTreeWidgetItem;    //  create new class tree item
                tree_parent->setIcon(0, * enum_icon);
                tree_parent->setText(0, header);        //  set class name as new class tree item text
                tree_parent->setToolTip(0, "Enumeration");
                tree_root->addChild(tree_parent);

                int bracket_counter = 1;
                QString class_body = "";

                for (int i = to; i < content_len; i++)
                {
                    if (bracket_counter == 0)
                        break;

                    class_body.push_back(content[i]);

                    if (content[i] == '{')
                        bracket_counter++;
                    else if (content[i] == '}')
                        bracket_counter--;
                }

                Class_tree_parent temp_class;           //  save class item into description array
                temp_class.from = from;                 //  save coordinates of class body into description array
                temp_class.to = to + class_body.size();
                class_tree_parents.push_back(temp_class);   //  push new description array item
            }
        }

        QRegularExpression interface_regex("interface[ \t\n]+[A-Za-z_][A-Za-z0-9_]*"
                                       "([ \t\n]+extends[ \t\n]+[A-Za-z_][A-Za-z0-9_]*([ \t\n]*[,][ \t\n]*[A-Za-z_][A-Za-z0-9_]*)*){0,1}"
                                       "[ \t\n]*{"
                                       );
        interface_regex.optimize();

        if (interface_regex.isValid())                  //  check if regular expression of rule is valid
        {
            QRegularExpressionMatchIterator match_iter = interface_regex.globalMatch(content);    //  check for global match of regular expression from rule

            while (match_iter.hasNext())                //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                int from = match.capturedStart();       //  save starting index of matched content into variable
                int to = match.capturedEnd();           //  save ending index of matched content into variable
                QString header = match.captured();      //  save matched content into string variable
                int header_size = header.size();

                header.chop(1);
                header.replace('\t', ' ');              //  replace tabs with spaces in matched string
                header.replace('\n', ' ');              //  replace newlines with spaces in matched string
                header = header.simplified();           //  remove explicit white characters using simplify method

                QStringList parts = header.split(' ');
                parts.pop_front();

                QTreeWidgetItem * tree_parent = new QTreeWidgetItem;    //  create new class tree item
                tree_parent->setIcon(0, * struct_icon);
                tree_parent->setText(0, parts.first());     //  set class name as new class tree item text
                parts.pop_front();

                if (parts.size() > 1)                   //  set string with parent classes specification as new class tree tooltip
                {
                    parts.pop_front();
                    QString extends = "Extends:  ";

                    while (parts.size())
                    {
                        extends.push_back(parts.first());
                        parts.pop_front();
                    }

                    extends.replace(",", ",  ");        //  add space characters after all comma characters
                    tree_parent->setToolTip(0, extends);
                }
                else
                    tree_parent->setToolTip(0, "This interface has no parents");

                tree_root->addChild(tree_parent);

                int bracket_counter = 1;
                QString class_body = "";

                for (int i = to; i < content_len; i++)
                {
                    if (bracket_counter == 0)
                        break;

                    class_body.push_back(content[i]);

                    if (content[i] == '{')
                        bracket_counter++;
                    else if (content[i] == '}')
                        bracket_counter--;
                }

                Class_tree_parent temp_class;           //  save class item into description array
                temp_class.from = from;                 //  save coordinates of class body into description array
                temp_class.to = to + class_body.size();
                class_tree_parents.push_back(temp_class);   //  push new description array item

                QRegularExpression function_regex("([A-Za-z_][A-Za-z0-9_\\[\\]\\<\\> \t\n]*){0,1}"
                                                  "[ \t\n]+[A-Za-z_][A-Za-z0-9_]*"
                                                  "[ \t\n]*[(][A-Za-z0-9_\\[\\]\\<\\> \t\n,]*[)][ \t\n]*[;]"
                                                  );
                function_regex.optimize();

                if (function_regex.isValid())           //  check if regular expression of rule is valid
                {
                    QRegularExpressionMatchIterator match_iter = function_regex.globalMatch(class_body);    //  check for global match of regular expression from rule

                    while (match_iter.hasNext())        //  iterate through all regular expression matches
                    {
                        QRegularExpressionMatch match = match_iter.next();

                        Class_tree_child child;         //  save attribute item into description array
                        child.from = header_size + match.capturedStart();   //  save coordinates of matched string into description array
                        class_tree_parents[class_tree_parents.size() - 1].children.push_back(child);    //  push new item as class description parent

                        QString found = match.captured();   //  save matched content into string variable
                        found.chop(1);
                        found.replace('\t', ' ');       //  replace tabs with spaces in matched string
                        found.replace('\n', ' ');       //  replace newlines with spaces in matched string
                        found = found.simplified();     //  remove explicit white characters using simplify method

                        int i = 1;
                        int N = found.size();           //  get length of matched string

                        while (i < N)                   //  iterate through matched string content
                        {
                            if (found[i] == ' ')        //  remove explicit spaces characters from matched string content
                            {
                                if ((found[i - 1].isLetterOrNumber() || found[i - 1] == '_') &&
                                    (found[i + 1].isLetterOrNumber() || found[i + 1] == '_'))
                                {
                                    i++;
                                }
                                else
                                {
                                    found.remove(i, 1);
                                    N--;
                                }
                            }
                            else
                                i++;
                        }

                        QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  add new child into actual class item class tree

                        bool is_static = false;
                        bool is_private = false;
                        bool is_protected = false;
                        bool is_public = false;
                        bool is_final = false;

                        for (int i = 0; i < 3; i++)
                        {
                            if (found.startsWith("static "))
                            {
                                is_static = true;
                                found.remove(0, 7);
                            }
                            else if (found.startsWith("private "))
                            {
                                is_private = true;
                                found.remove(0, 8);
                            }
                            else if (found.startsWith("protected "))
                            {
                                is_protected = true;
                                found.remove(0, 10);
                            }
                            else if (found.startsWith("public "))
                            {
                                is_public = true;
                                found.remove(0, 7);
                            }
                            else if (found.startsWith("final "))
                            {
                                is_final = true;
                                found.remove(0, 6);
                            }
                        }

                        if (is_final)
                            found = "final " + found;

                        if (is_private)
                        {
                            if (is_static)
                            {
                                tree_child->setIcon(0, * static_private_method_icon);
                                tree_child->setToolTip(0, "Static private method");
                            }
                            else
                            {
                                tree_child->setIcon(0, * private_method_icon);
                                tree_child->setToolTip(0, "Private method");
                            }
                        }
                        else if (is_protected)
                        {
                            if (is_static)
                            {
                                tree_child->setIcon(0, * static_protected_method_icon);
                                tree_child->setToolTip(0, "Static protected method");
                            }
                            else
                            {
                                tree_child->setIcon(0, * protected_method_icon);
                                tree_child->setToolTip(0, "Protected method");
                            }
                        }
                        else if (is_public)
                        {
                            if (is_static)
                            {
                                tree_child->setIcon(0, * static_public_method_icon);
                                tree_child->setToolTip(0, "Static public method");
                            }
                            else
                            {
                                tree_child->setIcon(0, * public_method_icon);
                                tree_child->setToolTip(0, "Public method");
                            }
                        }
                        else
                        {
                            if (is_static)
                            {
                                tree_child->setIcon(0, * static_public_method_icon);
                                tree_child->setToolTip(0, "Static method with no modifier");
                            }
                            else
                            {
                                tree_child->setIcon(0, * public_method_icon);
                                tree_child->setToolTip(0, "Method with no modifier");
                            }
                        }

                        found.replace(" ", "  ");       //  double space characters in string
                        found.replace(",", ",  ");      //  add space characters after all comma characters
                        found.replace("]", "]  ");      //  add space characters after all comma characters
                        found.replace(">", ">  ");      //  add space characters after all comma characters
                        found.replace("$", "  $");      //  add space characters after all dollar characters
                        found = found.simplified();     //  remove explicit white characters using simplify method
                        found.replace(" ", "  ");       //  double space characters in string
                        found.replace("(  ", "(");      //  remove space characters after left bracket

                        tree_child->setText(0, found);  //  set text of new class tree child
                        tree_parent->addChild(tree_child);  //  push new class tree child item
                    }
                }
            }
        }
                                                        //  extends must be always before implements
        QRegularExpression class_regex("class[ \t\n]+[A-Za-z_][A-Za-z0-9_]*"
                                       "([ \t\n]+extends[ \t\n]+[A-Za-z_][A-Za-z0-9_]*){0,1}"
                                       "([ \t\n]+implements[ \t\n]+[A-Za-z_][A-Za-z0-9_]*([ \t\n]*,[ \t\n]*[A-Za-z_][A-Za-z0-9_]*)*){0,1}"
                                       "[ \t\n]*{"
                                       );
        class_regex.optimize();

        if (class_regex.isValid())                      //  check if regular expression of rule is valid
        {
            QRegularExpressionMatchIterator match_iter = class_regex.globalMatch(content);    //  check for global match of regular expression from rule

            while (match_iter.hasNext())                //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                int from = match.capturedStart();       //  save starting index of matched content into variable
                int to = match.capturedEnd();           //  save ending index of matched content into variable
                QString header = match.captured();      //  save matched content into string variable
                int header_size = header.size();

                header.chop(1);
                header.replace('\t', ' ');              //  replace tabs with spaces in matched string
                header.replace('\n', ' ');              //  replace newlines with spaces in matched string
                header = header.simplified();           //  remove explicit white characters using simplify method

                QStringList parts = header.split(' ');
                parts.pop_front();

                QTreeWidgetItem * tree_parent = new QTreeWidgetItem;    //  create new class tree item
                tree_parent->setIcon(0, * class_icon);
                tree_parent->setText(0, parts.first());    //  set class name as new class tree item text
                tree_parent->setToolTip(0, "This class has no parents");
                parts.pop_front();

                QString parents = "";

                if (parts.size() > 1)                   //  set string with parent classes specification as new class tree tooltip
                {
                    parts.pop_front();
                    parents.push_back("Extends:  ");
                    parents.push_back(parts.first());
                    parts.pop_front();
                }

                if (parts.size() > 1)                   //  set string with parent classes specification as new class tree tooltip
                {
                    if (parents.size())
                        parents.push_back("\n");

                    parts.pop_front();
                    parents.push_back("Implements:  ");

                    while (parts.size())
                    {
                        parents.push_back(parts.first());
                        parts.pop_front();
                    }
                }

                if (parents.size())
                {
                    parents.replace(",", ",  ");        //  add space characters after all comma characters
                    tree_parent->setToolTip(0, parents);
                }

                tree_root->addChild(tree_parent);

                int bracket_counter = 1;
                QString class_body = "";

                for (int i = to; i < content_len; i++)
                {
                    if (bracket_counter == 0)
                        break;

                    class_body.push_back(content[i]);

                    if (content[i] == '{')
                        bracket_counter++;
                    else if (content[i] == '}')
                        bracket_counter--;
                }

                Class_tree_parent temp_class;           //  save class item into description array
                temp_class.from = from;                 //  save coordinates of class body into description array
                temp_class.to = to + class_body.size();
                class_tree_parents.push_back(temp_class);   //  push new description array item

                class_body.chop(1);
                int class_body_len = class_body.size();

                for (int j = 0; j < class_body_len; j++)           //  find starting block bracket in class body string
                {
                    if (class_body[j] == '{')
                    {
                        int block_bracket_count = 1;
                        j++;

                        while (j < class_body_len)
                        {
                            if (class_body[j] == '{')
                                block_bracket_count++;
                            else if (class_body[j] == '}')
                                block_bracket_count--;

                            if (block_bracket_count == 0)
                                break;
                            else
                                class_body[j] = ' ';               //  remove all bodies of all methods location inside body of actual class

                            j++;
                        }
                    }
                }

                for (int j = 0; j < class_body_len; j++)           //  replace all tabs and newlines by space characters
                {
                    if (class_body[j] == '\t' || class_body[j] == '\n')
                        class_body[j] = ' ';
                }

                QRegularExpression variable_regex("([A-Za-z_][A-Za-z0-9_\\[\\]\\<\\> \t\n]*){0,1}"
                                                  "[ \t\n]+[A-Za-z_][A-Za-z0-9_]*[ \t\n]*[;=]"
                                                  );
                variable_regex.optimize();

                if (variable_regex.isValid())           //  check if regular expression of rule is valid
                {
                    QRegularExpressionMatchIterator match_iter = variable_regex.globalMatch(class_body);    //  check for global match of regular expression from rule

                    while (match_iter.hasNext())        //  iterate through all regular expression matches
                    {
                        QRegularExpressionMatch match = match_iter.next();

                        Class_tree_child child;     //  save attribute item into description array
                        child.from = header_size + match.capturedStart();   //  save coordinates of matched string into description array
                        class_tree_parents[class_tree_parents.size() - 1].children.push_back(child);    //  push new item as class description parent

                        QString found = match.captured();       //  save matched content into string variable
                        found.chop(1);
                        found.replace('\t', ' ');       //  replace tabs with spaces in matched string
                        found.replace('\n', ' ');       //  replace newlines with spaces in matched string
                        found = found.simplified();             //  remove explicit white characters using simplify method

                        int i = 1;
                        int N = found.size();           //  get length of matched string

                        while (i < N)                   //  iterate through matched string content
                        {
                            if (found[i] == ' ')        //  remove explicit spaces characters from matched string content
                            {
                                if ((found[i - 1].isLetterOrNumber() || found[i - 1] == '_') &&
                                    (found[i + 1].isLetterOrNumber() || found[i + 1] == '_'))
                                {
                                    i++;
                                }
                                else
                                {
                                    found.remove(i, 1);
                                    N--;
                                }
                            }
                            else
                                i++;
                        }

                        QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  add new child into actual class item class tree

                        bool is_static = false;
                        bool is_private = false;
                        bool is_protected = false;
                        bool is_public = false;
                        bool is_final = false;
                        bool is_volatile = false;

                        for (int i = 0; i < 3; i++)
                        {
                            if (found.startsWith("static "))
                            {
                                is_static = true;
                                found.remove(0, 7);
                            }
                            else if (found.startsWith("private "))
                            {
                                is_private = true;
                                found.remove(0, 8);
                            }
                            else if (found.startsWith("protected "))
                            {
                                is_protected = true;
                                found.remove(0, 10);
                            }
                            else if (found.startsWith("public "))
                            {
                                is_public = true;
                                found.remove(0, 7);
                            }
                            else if (found.startsWith("final "))
                            {
                                is_final = true;
                                found.remove(0, 6);
                            }
                            else if (found.startsWith("volatile "))
                            {
                                is_volatile = true;
                                found.remove(0, 9);
                            }
                        }

                        if (is_final && is_volatile)
                            continue;

                        if (is_final)
                            found = "final " + found;
                        else if (is_volatile)
                            found = "volatile " + found;

                        if (is_private)
                        {
                            if (is_static)
                            {
                                tree_child->setIcon(0, * static_private_attribute_icon);
                                tree_child->setToolTip(0, "Static private attribute");
                            }
                            else
                            {
                                tree_child->setIcon(0, * private_attribute_icon);
                                tree_child->setToolTip(0, "Private attribute");
                            }
                        }
                        else if (is_protected)
                        {
                            if (is_static)
                            {
                                tree_child->setIcon(0, * static_protected_attribute_icon);
                                tree_child->setToolTip(0, "Static protected attribute");
                            }
                            else
                            {
                                tree_child->setIcon(0, * protected_attribute_icon);
                                tree_child->setToolTip(0, "Protected attribute");
                            }
                        }
                        else if (is_public)
                        {
                            if (is_static)
                            {
                                tree_child->setIcon(0, * static_public_attribute_icon);
                                tree_child->setToolTip(0, "Static public attribute");
                            }
                            else
                            {
                                tree_child->setIcon(0, * public_attribute_icon);
                                tree_child->setToolTip(0, "Public attribute");
                            }
                        }
                        else
                        {
                            if (is_static)
                            {
                                tree_child->setIcon(0, * static_public_attribute_icon);
                                tree_child->setToolTip(0, "Static attribute with no modifier");
                            }
                            else
                            {
                                tree_child->setIcon(0, * public_attribute_icon);
                                tree_child->setToolTip(0, "Attribute with no modifier");
                            }
                        }

                        found.replace(" ", "  ");       //  double space characters in string
                        found.replace(",", ",  ");      //  add space characters after all comma characters
                        found.replace("]", "]  ");      //  add space characters after all comma characters
                        found.replace(">", ">  ");      //  add space characters after all comma characters
                        found.replace("$", "  $");      //  add space characters after all dollar characters
                        found = found.simplified();     //  remove explicit white characters using simplify method
                        found.replace(" ", "  ");       //  double space characters in string
                        found.replace("(  ", "(");      //  remove space characters after left bracket

                        tree_child->setText(0, found);  //  set text of new class tree child
                        tree_parent->addChild(tree_child);  //  push new class tree child item
                    }
                }

                QRegularExpression function_regex("([A-Za-z_][A-Za-z0-9_\\[\\]\\<\\> \t\n]*){0,1}"
                                                  "[ \t\n]+[A-Za-z_][A-Za-z0-9_]*"
                                                  "[ \t\n]*[(][A-Za-z0-9_\\[\\]\\<\\> \t\n,]*[)][ \t\n]*{"
                                                  );
                function_regex.optimize();

                if (function_regex.isValid())           //  check if regular expression of rule is valid
                {
                    QRegularExpressionMatchIterator match_iter = function_regex.globalMatch(class_body);    //  check for global match of regular expression from rule

                    while (match_iter.hasNext())        //  iterate through all regular expression matches
                    {
                        QRegularExpressionMatch match = match_iter.next();

                        Class_tree_child child;         //  save attribute item into description array
                        child.from = header_size + match.capturedStart();   //  save coordinates of matched string into description array
                        class_tree_parents[class_tree_parents.size() - 1].children.push_back(child);    //  push new item as class description parent

                        QString found = match.captured();   //  save matched content into string variable
                        found.chop(1);
                        found.replace('\t', ' ');       //  replace tabs with spaces in matched string
                        found.replace('\n', ' ');       //  replace newlines with spaces in matched string
                        found = found.simplified();     //  remove explicit white characters using simplify method

                        int i = 1;
                        int N = found.size();           //  get length of matched string

                        while (i < N)                   //  iterate through matched string content
                        {
                            if (found[i] == ' ')        //  remove explicit spaces characters from matched string content
                            {
                                if ((found[i - 1].isLetterOrNumber() || found[i - 1] == '_') &&
                                    (found[i + 1].isLetterOrNumber() || found[i + 1] == '_'))
                                {
                                    i++;
                                }
                                else
                                {
                                    found.remove(i, 1);
                                    N--;
                                }
                            }
                            else
                                i++;
                        }

                        QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  add new child into actual class item class tree

                        bool is_static = false;
                        bool is_private = false;
                        bool is_protected = false;
                        bool is_public = false;
                        bool is_final = false;

                        for (int i = 0; i < 3; i++)
                        {
                            if (found.startsWith("static "))
                            {
                                is_static = true;
                                found.remove(0, 7);
                            }
                            else if (found.startsWith("private "))
                            {
                                is_private = true;
                                found.remove(0, 8);
                            }
                            else if (found.startsWith("protected "))
                            {
                                is_protected = true;
                                found.remove(0, 10);
                            }
                            else if (found.startsWith("public "))
                            {
                                is_public = true;
                                found.remove(0, 7);
                            }
                            else if (found.startsWith("final "))
                            {
                                is_final = true;
                                found.remove(0, 6);
                            }
                        }

                        if (is_final)
                            found = "final " + found;

                        if (is_private)
                        {
                            if (is_static)
                            {
                                tree_child->setIcon(0, * static_private_method_icon);
                                tree_child->setToolTip(0, "Static private method");
                            }
                            else
                            {
                                tree_child->setIcon(0, * private_method_icon);
                                tree_child->setToolTip(0, "Private method");
                            }
                        }
                        else if (is_protected)
                        {
                            if (is_static)
                            {
                                tree_child->setIcon(0, * static_protected_method_icon);
                                tree_child->setToolTip(0, "Static protected method");
                            }
                            else
                            {
                                tree_child->setIcon(0, * protected_method_icon);
                                tree_child->setToolTip(0, "Protected method");
                            }
                        }
                        else if (is_public)
                        {
                            if (is_static)
                            {
                                tree_child->setIcon(0, * static_public_method_icon);
                                tree_child->setToolTip(0, "Static public method");
                            }
                            else
                            {
                                tree_child->setIcon(0, * public_method_icon);
                                tree_child->setToolTip(0, "Public method");
                            }
                        }
                        else
                        {
                            if (is_static)
                            {
                                tree_child->setIcon(0, * static_public_method_icon);
                                tree_child->setToolTip(0, "Static method with no modifier");
                            }
                            else
                            {
                                tree_child->setIcon(0, * public_method_icon);
                                tree_child->setToolTip(0, "Method with no modifier");
                            }
                        }

                        found.replace(" ", "  ");       //  double space characters in string
                        found.replace(",", ",  ");      //  add space characters after all comma characters
                        found.replace("]", "]  ");      //  add space characters after all comma characters
                        found.replace(">", ">  ");      //  add space characters after all comma characters
                        found.replace("$", "  $");      //  add space characters after all dollar characters
                        found = found.simplified();     //  remove explicit white characters using simplify method
                        found.replace(" ", "  ");       //  double space characters in string
                        found.replace("(  ", "(");      //  remove space characters after left bracket

                        tree_child->setText(0, found);  //  set text of new class tree child
                        tree_parent->addChild(tree_child);  //  push new class tree child item
                    }
                }
            }
        }
    }
    else if (actual_language == php)                    //  selected language of actual text editor tab is PHP
    {
        QString content = editor[index].document()->toPlainText();
        int content_len = content.size();
        remove_comments_and_quotation(content, active_tabs[actual].language);  //  remove all comments and quotation from source code string

        QRegularExpression interface_regex("interface[ \t\n]+[A-Za-z_][A-Za-z0-9_]*"
                                       "([ \t\n]+extends[ \t\n]+[A-Za-z_][A-Za-z0-9_]*([ \t\n]*[,][ \t\n]*[A-Za-z_][A-Za-z0-9_]*)*){0,1}"
                                       "[ \t\n]*{"
                                       );
        interface_regex.optimize();

        if (interface_regex.isValid())                  //  check if regular expression of rule is valid
        {
            QRegularExpressionMatchIterator match_iter = interface_regex.globalMatch(content);    //  check for global match of regular expression from rule

            while (match_iter.hasNext())                //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                int from = match.capturedStart();       //  save starting index of matched content into variable
                int to = match.capturedEnd();           //  save ending index of matched content into variable
                QString header = match.captured();      //  save matched content into string variable
                int header_size = header.size();

                header.chop(1);
                header.replace('\t', ' ');              //  replace tabs with spaces in matched string
                header.replace('\n', ' ');              //  replace newlines with spaces in matched string
                header = header.simplified();           //  remove explicit white characters using simplify method

                QStringList parts = header.split(' ');
                parts.pop_front();

                QTreeWidgetItem * tree_parent = new QTreeWidgetItem;    //  create new class tree item
                tree_parent->setIcon(0, * struct_icon);
                tree_parent->setText(0, parts.first());     //  set class name as new class tree item text
                parts.pop_front();

                if (parts.size() > 1)                   //  set string with parent classes specification as new class tree tooltip
                {
                    parts.pop_front();
                    QString extends = "Extends:  ";

                    while (parts.size())
                    {
                        extends.push_back(parts.first());
                        parts.pop_front();
                    }

                    extends.replace(",", ",  ");        //  add space characters after all comma characters
                    tree_parent->setToolTip(0, extends);
                }
                else
                    tree_parent->setToolTip(0, "This interface has no parents");

                tree_root->addChild(tree_parent);

                int bracket_counter = 1;
                QString class_body = "";

                for (int i = to; i < content_len; i++)
                {
                    if (bracket_counter == 0)
                        break;

                    class_body.push_back(content[i]);

                    if (content[i] == '{')
                        bracket_counter++;
                    else if (content[i] == '}')
                        bracket_counter--;
                }

                Class_tree_parent temp_class;           //  save class item into description array
                temp_class.from = from;                 //  save coordinates of class body into description array
                temp_class.to = to + class_body.size();
                class_tree_parents.push_back(temp_class);   //  push new description array item

                QRegularExpression const_regex("const[ \t\n]+[A-Za-z_][A-Za-z0-9_]*");
                const_regex.optimize();

                if (const_regex.isValid())                            //  check if regular expression of rule is valid
                {
                    QRegularExpressionMatchIterator match_iter = const_regex.globalMatch(class_body);    //  check for global match of regular expression from rule

                    while (match_iter.hasNext())                //  iterate through all regular expression matches
                    {
                        QRegularExpressionMatch match = match_iter.next();

                        Class_tree_child child;         //  save attribute item into description array
                        child.from = header_size + match.capturedStart();   //  save coordinates of matched string into description array
                        class_tree_parents[class_tree_parents.size() - 1].children.push_back(child);    //  push new item as class description parent

                        QString found = match.captured();   //  save matched content into string variable
                        found.replace('\t', ' ');       //  replace tabs with spaces in matched string
                        found.replace('\n', ' ');       //  replace newlines with spaces in matched string
                        found = found.simplified();     //  remove explicit white characters using simplify method

                        int i = 1;
                        int N = found.size();           //  get length of matched string

                        while (i < N)                   //  iterate through matched string content
                        {
                            if (found[i] == ' ')        //  remove explicit spaces characters from matched string content
                            {
                                if ((found[i - 1].isLetterOrNumber() || found[i - 1] == '_') &&
                                    (found[i + 1].isLetterOrNumber() || found[i + 1] == '_'))
                                {
                                    i++;
                                }
                                else
                                {
                                    found.remove(i, 1);
                                    N--;
                                }
                            }
                            else
                                i++;
                        }

                        QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  add new child into actual class item class tree
                        tree_child->setIcon(0, * public_attribute_icon);
                        tree_child->setToolTip(0, "Public attribute");

                        found.replace(" ", "  ");       //  double space characters in string
                        found.replace(",", ",  ");      //  add space characters after all comma characters
                        found.replace("$", "  $");      //  add space characters after all dollar characters
                        found = found.simplified();     //  remove explicit white characters using simplify method
                        found.replace(" ", "  ");       //  double space characters in string
                        found.replace("(  ", "(");      //  remove space characters after left bracket

                        tree_child->setText(0, found);  //  set text of new class tree child
                        tree_parent->addChild(tree_child);  //  push new class tree child item
                    }
                }

                QRegularExpression function_regex("("
                                                    "(static[ \t\n]+(public|private|protected)[ \t\n]+)|"
                                                    "((public|private|protected)[ \t\n]+static[ \t\n]+)|"
                                                    "(static[ \t\n]+)|"
                                                    "((public|private|protected)[ \t\n]+)"
                                                  "){0,1}"
                                                  "function[ \t\n]+[A-Za-z_][A-Za-z0-9_]*"
                                                  "[ \t\n]*([^;]*)[ \t\n]*[;]"
                                                  );
                function_regex.optimize();

                if (function_regex.isValid())           //  check if regular expression of rule is valid
                {
                    QRegularExpressionMatchIterator match_iter = function_regex.globalMatch(class_body);    //  check for global match of regular expression from rule

                    while (match_iter.hasNext())        //  iterate through all regular expression matches
                    {
                        QRegularExpressionMatch match = match_iter.next();

                        Class_tree_child child;         //  save attribute item into description array
                        child.from = header_size + match.capturedStart();   //  save coordinates of matched string into description array
                        class_tree_parents[class_tree_parents.size() - 1].children.push_back(child);    //  push new item as class description parent

                        QString found = match.captured();   //  save matched content into string variable
                        found.chop(1);
                        found.replace('\t', ' ');       //  replace tabs with spaces in matched string
                        found.replace('\n', ' ');       //  replace newlines with spaces in matched string
                        found = found.simplified();     //  remove explicit white characters using simplify method

                        int i = 1;
                        int N = found.size();           //  get length of matched string

                        while (i < N)                   //  iterate through matched string content
                        {
                            if (found[i] == ' ')        //  remove explicit spaces characters from matched string content
                            {
                                if ((found[i - 1].isLetterOrNumber() || found[i - 1] == '_') &&
                                    (found[i + 1].isLetterOrNumber() || found[i + 1] == '_'))
                                {
                                    i++;
                                }
                                else
                                {
                                    found.remove(i, 1);
                                    N--;
                                }
                            }
                            else
                                i++;
                        }

                        QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  add new child into actual class item class tree

                        bool is_static = false;
                        bool is_private = false;
                        bool is_protected = false;
                        bool is_public = false;

                        if (found.startsWith("static "))
                        {
                            is_static = true;
                            found.remove(0, 7);

                            if (found.startsWith("private "))
                            {
                                is_private = true;
                                found.remove(0, 8);
                            }
                            else if (found.startsWith("protected "))
                            {
                                is_protected = true;
                                found.remove(0, 10);
                            }
                            else if (found.startsWith("public "))
                            {
                                is_public = true;
                                found.remove(0, 7);
                            }
                        }

                        if (found.startsWith("private "))
                        {
                            is_private = true;
                            found.remove(0, 8);

                            if (found.startsWith("static "))
                            {
                                is_static = true;
                                found.remove(0, 7);
                            }
                        }
                        else if (found.startsWith("protected "))
                        {
                            is_protected = true;
                            found.remove(0, 10);

                            if (found.startsWith("static "))
                            {
                                is_static = true;
                                found.remove(0, 7);
                            }
                        }
                        else if (found.startsWith("public "))
                        {
                            is_public = true;
                            found.remove(0, 7);

                            if (found.startsWith("static "))
                            {
                                is_static = true;
                                found.remove(0, 7);
                            }
                        }

                        if (is_private == false && is_protected == false && is_public == false)
                            is_public = true;

                        if (is_private)
                        {
                            if (is_static)
                            {
                                tree_child->setIcon(0, * static_private_method_icon);
                                tree_child->setToolTip(0, "Static private method");
                            }
                            else
                            {
                                tree_child->setIcon(0, * private_method_icon);
                                tree_child->setToolTip(0, "Private method");
                            }
                        }
                        else if (is_protected)
                        {
                            if (is_static)
                            {
                                tree_child->setIcon(0, * static_protected_method_icon);
                                tree_child->setToolTip(0, "Static protected method");
                            }
                            else
                            {
                                tree_child->setIcon(0, * protected_method_icon);
                                tree_child->setToolTip(0, "Protected method");
                            }
                        }
                        else if (is_public)
                        {
                            if (is_static)
                            {
                                tree_child->setIcon(0, * static_public_method_icon);
                                tree_child->setToolTip(0, "Static public method");
                            }
                            else
                            {
                                tree_child->setIcon(0, * public_method_icon);
                                tree_child->setToolTip(0, "Public method");
                            }
                        }

                        if (found.startsWith("function "))
                            found.remove(0, 9);

                        found.replace(" ", "  ");       //  double space characters in string
                        found.replace(",", ",  ");      //  add space characters after all comma characters
                        found.replace("$", "  $");      //  add space characters after all dollar characters
                        found = found.simplified();     //  remove explicit white characters using simplify method
                        found.replace(" ", "  ");       //  double space characters in string
                        found.replace("(  ", "(");      //  remove space characters after left bracket

                        tree_child->setText(0, found);  //  set text of new class tree child
                        tree_parent->addChild(tree_child);  //  push new class tree child item
                    }
                }


            }
        }
                                                        //  extends must be always before implements
        QRegularExpression class_regex("class[ \t\n]+[A-Za-z_][A-Za-z0-9_]*"
                                       "([ \t\n]+extends[ \t\n]+[A-Za-z_][A-Za-z0-9_]*){0,1}"
                                       "([ \t\n]+implements[ \t\n]+[A-Za-z_][A-Za-z0-9_]*([ \t\n]*,[ \t\n]*[A-Za-z_][A-Za-z0-9_]*)*){0,1}"
                                       "[ \t\n]*{"
                                       );
        class_regex.optimize();

        if (class_regex.isValid())                      //  check if regular expression of rule is valid
        {
            QRegularExpressionMatchIterator match_iter = class_regex.globalMatch(content);    //  check for global match of regular expression from rule

            while (match_iter.hasNext())                //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                int from = match.capturedStart();       //  save starting index of matched content into variable
                int to = match.capturedEnd();           //  save ending index of matched content into variable
                QString header = match.captured();      //  save matched content into string variable
                int header_size = header.size();

                header.chop(1);
                header.replace('\t', ' ');              //  replace tabs with spaces in matched string
                header.replace('\n', ' ');              //  replace newlines with spaces in matched string
                header = header.simplified();           //  remove explicit white characters using simplify method

                QStringList parts = header.split(' ');
                parts.pop_front();

                QTreeWidgetItem * tree_parent = new QTreeWidgetItem;    //  create new class tree item
                tree_parent->setIcon(0, * class_icon);
                tree_parent->setText(0, parts.first());    //  set class name as new class tree item text
                tree_parent->setToolTip(0, "This class has no parents");
                parts.pop_front();

                QString parents = "";

                if (parts.size() > 1)                   //  set string with parent classes specification as new class tree tooltip
                {
                    parts.pop_front();
                    parents.push_back("Extends:  ");
                    parents.push_back(parts.first());
                    parts.pop_front();
                }

                if (parts.size() > 1)                   //  set string with parent classes specification as new class tree tooltip
                {
                    if (parents.size())
                        parents.push_back("\n");

                    parts.pop_front();
                    parents.push_back("Implements:  ");

                    while (parts.size())
                    {
                        parents.push_back(parts.first());
                        parts.pop_front();
                    }
                }

                if (parents.size())
                {
                    parents.replace(",", ",  ");        //  add space characters after all comma characters
                    tree_parent->setToolTip(0, parents);
                }

                tree_root->addChild(tree_parent);

                int bracket_counter = 1;
                QString class_body = "";

                for (int i = to; i < content_len; i++)
                {
                    if (bracket_counter == 0)
                        break;

                    class_body.push_back(content[i]);

                    if (content[i] == '{')
                        bracket_counter++;
                    else if (content[i] == '}')
                        bracket_counter--;
                }

                Class_tree_parent temp_class;           //  save class item into description array
                temp_class.from = from;                 //  save coordinates of class body into description array
                temp_class.to = to + class_body.size();
                class_tree_parents.push_back(temp_class);   //  push new description array item

                QRegularExpression variable_regex("("
                                                    "(static[ \t\n]+(public|private|protected)[ \t\n]+)|"
                                                    "((public|private|protected)[ \t\n]+static[ \t\n]+)|"
                                                    "((public|private|protected)[ \t\n]+)"
                                                  ")"
                                                  "[$][A-Za-z_][A-Za-z0-9_]*"
                                                  );
                variable_regex.optimize();

                if (variable_regex.isValid())           //  check if regular expression of rule is valid
                {
                    QRegularExpressionMatchIterator match_iter = variable_regex.globalMatch(class_body);    //  check for global match of regular expression from rule

                    while (match_iter.hasNext())        //  iterate through all regular expression matches
                    {
                        QRegularExpressionMatch match = match_iter.next();

                        Class_tree_child child;         //  save attribute item into description array
                        child.from = header_size + match.capturedStart();   //  save coordinates of matched string into description array
                        class_tree_parents[class_tree_parents.size() - 1].children.push_back(child);    //  push new item as class description parent

                        QString found = match.captured();   //  save matched content into string variable
                        found.replace('\t', ' ');       //  replace tabs with spaces in matched string
                        found.replace('\n', ' ');       //  replace newlines with spaces in matched string
                        found = found.simplified();     //  remove explicit white characters using simplify method

                        int i = 1;
                        int N = found.size();           //  get length of matched string

                        while (i < N)                   //  iterate through matched string content
                        {
                            if (found[i] == ' ')        //  remove explicit spaces characters from matched string content
                            {
                                if ((found[i - 1].isLetterOrNumber() || found[i - 1] == '_') &&
                                    (found[i + 1].isLetterOrNumber() || found[i + 1] == '_'))
                                {
                                    i++;
                                }
                                else
                                {
                                    found.remove(i, 1);
                                    N--;
                                }
                            }
                            else
                                i++;
                        }

                        QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  add new child into actual class item class tree

                        bool is_static = false;
                        bool is_private = false;
                        bool is_protected = false;
                        bool is_public = false;

                        if (found.startsWith("static "))
                        {
                            is_static = true;
                            found.remove(0, 7);

                            if (found.startsWith("private "))
                            {
                                is_private = true;
                                found.remove(0, 8);
                            }
                            else if (found.startsWith("protected "))
                            {
                                is_protected = true;
                                found.remove(0, 10);
                            }
                            else if (found.startsWith("public "))
                            {
                                is_public = true;
                                found.remove(0, 7);
                            }
                        }

                        if (found.startsWith("private "))
                        {
                            is_private = true;
                            found.remove(0, 8);

                            if (found.startsWith("static "))
                            {
                                is_static = true;
                                found.remove(0, 7);
                            }
                        }
                        else if (found.startsWith("protected "))
                        {
                            is_protected = true;
                            found.remove(0, 10);

                            if (found.startsWith("static "))
                            {
                                is_static = true;
                                found.remove(0, 7);
                            }
                        }
                        else if (found.startsWith("public "))
                        {
                            is_public = true;
                            found.remove(0, 7);

                            if (found.startsWith("static "))
                            {
                                is_static = true;
                                found.remove(0, 7);
                            }
                        }

                        if (is_private == false && is_protected == false && is_public == false)
                            continue;

                        if (is_private)
                        {
                            if (is_static)
                            {
                                tree_child->setIcon(0, * static_private_attribute_icon);
                                tree_child->setToolTip(0, "Static private attribute");
                            }
                            else
                            {
                                tree_child->setIcon(0, * private_attribute_icon);
                                tree_child->setToolTip(0, "Private attribute");
                            }
                        }
                        else if (is_protected)
                        {
                            if (is_static)
                            {
                                tree_child->setIcon(0, * static_protected_attribute_icon);
                                tree_child->setToolTip(0, "Static protected attribute");
                            }
                            else
                            {
                                tree_child->setIcon(0, * protected_attribute_icon);
                                tree_child->setToolTip(0, "Protected attribute");
                            }
                        }
                        else if (is_public)
                        {
                            if (is_static)
                            {
                                tree_child->setIcon(0, * static_public_attribute_icon);
                                tree_child->setToolTip(0, "Static public attribute");
                            }
                            else
                            {
                                tree_child->setIcon(0, * public_attribute_icon);
                                tree_child->setToolTip(0, "Public attribute");
                            }
                        }

                        found.replace(" ", "  ");       //  double space characters in string
                        found.replace(",", ",  ");      //  add space characters after all comma characters
                        found.replace("$", "  $");      //  add space characters after all dollar characters
                        found = found.simplified();     //  remove explicit white characters using simplify method
                        found.replace(" ", "  ");       //  double space characters in string
                        found.replace("(  ", "(");      //  remove space characters after left bracket

                        tree_child->setText(0, found);  //  set text of new class tree child
                        tree_parent->addChild(tree_child);  //  push new class tree child item
                    }
                }

                QRegularExpression var_regex("var[ \t\n]+[$][A-Za-z_][A-Za-z0-9_]*");
                var_regex.optimize();

                if (var_regex.isValid())                            //  check if regular expression of rule is valid
                {
                    QRegularExpressionMatchIterator match_iter = var_regex.globalMatch(class_body);    //  check for global match of regular expression from rule

                    while (match_iter.hasNext())                //  iterate through all regular expression matches
                    {
                        QRegularExpressionMatch match = match_iter.next();

                        Class_tree_child child;     //  save attribute item into description array
                        child.from = header_size + match.capturedStart();   //  save coordinates of matched string into description array
                        class_tree_parents[class_tree_parents.size() - 1].children.push_back(child);    //  push new item as class description parent

                        QString found = match.captured();       //  save matched content into string variable
                        found.replace('\t', ' ');       //  replace tabs with spaces in matched string
                        found.replace('\n', ' ');       //  replace newlines with spaces in matched string
                        found = found.simplified();             //  remove explicit white characters using simplify method

                        int i = 1;
                        int N = found.size();           //  get length of matched string

                        while (i < N)                   //  iterate through matched string content
                        {
                            if (found[i] == ' ')        //  remove explicit spaces characters from matched string content
                            {
                                if ((found[i - 1].isLetterOrNumber() || found[i - 1] == '_') &&
                                    (found[i + 1].isLetterOrNumber() || found[i + 1] == '_'))
                                {
                                    i++;
                                }
                                else
                                {
                                    found.remove(i, 1);
                                    N--;
                                }
                            }
                            else
                                i++;
                        }

                        QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  add new child into actual class item class tree
                        tree_child->setIcon(0, * public_attribute_icon);
                        tree_child->setToolTip(0, "Public attribute");

                        found.remove(0, 4);
                        found.replace(" ", "  ");       //  double space characters in string
                        found.replace(",", ",  ");      //  add space characters after all comma characters
                        found.replace("$", "  $");      //  add space characters after all dollar characters
                        found = found.simplified();     //  remove explicit white characters using simplify method
                        found.replace(" ", "  ");       //  double space characters in string
                        found.replace("(  ", "(");      //  remove space characters after left bracket

                        tree_child->setText(0, found);  //  set text of new class tree child
                        tree_parent->addChild(tree_child);  //  push new class tree child item
                    }
                }

                QRegularExpression const_regex("const[ \t\n]+[A-Za-z_][A-Za-z0-9_]*");
                const_regex.optimize();

                if (const_regex.isValid())                            //  check if regular expression of rule is valid
                {
                    QRegularExpressionMatchIterator match_iter = const_regex.globalMatch(class_body);    //  check for global match of regular expression from rule

                    while (match_iter.hasNext())                //  iterate through all regular expression matches
                    {
                        QRegularExpressionMatch match = match_iter.next();

                        Class_tree_child child;         //  save attribute item into description array
                        child.from = header_size + match.capturedStart();   //  save coordinates of matched string into description array
                        class_tree_parents[class_tree_parents.size() - 1].children.push_back(child);    //  push new item as class description parent

                        QString found = match.captured();       //  save matched content into string variable
                        found.replace('\t', ' ');       //  replace tabs with spaces in matched string
                        found.replace('\n', ' ');       //  replace newlines with spaces in matched string
                        found = found.simplified();             //  remove explicit white characters using simplify method

                        int i = 1;
                        int N = found.size();           //  get length of matched string

                        while (i < N)                   //  iterate through matched string content
                        {
                            if (found[i] == ' ')        //  remove explicit spaces characters from matched string content
                            {
                                if ((found[i - 1].isLetterOrNumber() || found[i - 1] == '_') &&
                                    (found[i + 1].isLetterOrNumber() || found[i + 1] == '_'))
                                {
                                    i++;
                                }
                                else
                                {
                                    found.remove(i, 1);
                                    N--;
                                }
                            }
                            else
                                i++;
                        }

                        QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  add new child into actual class item class tree
                        tree_child->setIcon(0, * public_attribute_icon);
                        tree_child->setToolTip(0, "Public attribute");

                        found.replace(" ", "  ");       //  double space characters in string
                        found.replace(",", ",  ");      //  add space characters after all comma characters
                        found.replace("$", "  $");      //  add space characters after all dollar characters
                        found = found.simplified();     //  remove explicit white characters using simplify method
                        found.replace(" ", "  ");       //  double space characters in string
                        found.replace("(  ", "(");      //  remove space characters after left bracket

                        tree_child->setText(0, found);  //  set text of new class tree child
                        tree_parent->addChild(tree_child);  //  push new class tree child item
                    }
                }

                QRegularExpression function_regex("("
                                                    "(static[ \t\n]+(public|private|protected)[ \t\n]+)|"
                                                    "((public|private|protected)[ \t\n]+static[ \t\n]+)|"
                                                    "(static[ \t\n]+)|"
                                                    "((public|private|protected)[ \t\n]+)"
                                                  "){0,1}"
                                                  "function[ \t\n]+[A-Za-z_][A-Za-z0-9_]*"
                                                  "[ \t\n]*[(][^{]*[)][ \t\n]*{"
                                                  );
                function_regex.optimize();

                if (function_regex.isValid())                            //  check if regular expression of rule is valid
                {
                    QRegularExpressionMatchIterator match_iter = function_regex.globalMatch(class_body);    //  check for global match of regular expression from rule

                    while (match_iter.hasNext())                //  iterate through all regular expression matches
                    {
                        QRegularExpressionMatch match = match_iter.next();

                        Class_tree_child child;     //  save attribute item into description array
                        child.from = header_size + match.capturedStart();   //  save coordinates of matched string into description array
                        class_tree_parents[class_tree_parents.size() - 1].children.push_back(child);    //  push new item as class description parent

                        QString found = match.captured();       //  save matched content into string variable
                        found.chop(1);
                        found.replace('\t', ' ');       //  replace tabs with spaces in matched string
                        found.replace('\n', ' ');       //  replace newlines with spaces in matched string
                        found = found.simplified();             //  remove explicit white characters using simplify method

                        int i = 1;
                        int N = found.size();           //  get length of matched string

                        while (i < N)                   //  iterate through matched string content
                        {
                            if (found[i] == ' ')        //  remove explicit spaces characters from matched string content
                            {
                                if ((found[i - 1].isLetterOrNumber() || found[i - 1] == '_') &&
                                    (found[i + 1].isLetterOrNumber() || found[i + 1] == '_'))
                                {
                                    i++;
                                }
                                else
                                {
                                    found.remove(i, 1);
                                    N--;
                                }
                            }
                            else
                                i++;
                        }

                        QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  add new child into actual class item class tree

                        bool is_static = false;
                        bool is_private = false;
                        bool is_protected = false;
                        bool is_public = false;

                        if (found.startsWith("static "))
                        {
                            is_static = true;
                            found.remove(0, 7);

                            if (found.startsWith("private "))
                            {
                                is_private = true;
                                found.remove(0, 8);
                            }
                            else if (found.startsWith("protected "))
                            {
                                is_protected = true;
                                found.remove(0, 10);
                            }
                            else if (found.startsWith("public "))
                            {
                                is_public = true;
                                found.remove(0, 7);
                            }
                        }

                        if (found.startsWith("private "))
                        {
                            is_private = true;
                            found.remove(0, 8);

                            if (found.startsWith("static "))
                            {
                                is_static = true;
                                found.remove(0, 7);
                            }
                        }
                        else if (found.startsWith("protected "))
                        {
                            is_protected = true;
                            found.remove(0, 10);

                            if (found.startsWith("static "))
                            {
                                is_static = true;
                                found.remove(0, 7);
                            }
                        }
                        else if (found.startsWith("public "))
                        {
                            is_public = true;
                            found.remove(0, 7);

                            if (found.startsWith("static "))
                            {
                                is_static = true;
                                found.remove(0, 7);
                            }
                        }

                        if (is_private == false && is_protected == false && is_public == false)
                            is_public = true;

                        if (is_private)
                        {
                            if (is_static)
                            {
                                tree_child->setIcon(0, * static_private_method_icon);
                                tree_child->setToolTip(0, "Static private method");
                            }
                            else
                            {
                                tree_child->setIcon(0, * private_method_icon);
                                tree_child->setToolTip(0, "Private method");
                            }
                        }
                        else if (is_protected)
                        {
                            if (is_static)
                            {
                                tree_child->setIcon(0, * static_protected_method_icon);
                                tree_child->setToolTip(0, "Static protected method");
                            }
                            else
                            {
                                tree_child->setIcon(0, * protected_method_icon);
                                tree_child->setToolTip(0, "Protected method");
                            }
                        }
                        else if (is_public)
                        {
                            if (is_static)
                            {
                                tree_child->setIcon(0, * static_public_method_icon);
                                tree_child->setToolTip(0, "Static public method");
                            }
                            else
                            {
                                tree_child->setIcon(0, * public_method_icon);
                                tree_child->setToolTip(0, "Public method");
                            }
                        }

                        if (found.startsWith("function "))
                            found.remove(0, 9);

                        found.replace(" ", "  ");       //  double space characters in string
                        found.replace(",", ",  ");      //  add space characters after all comma characters
                        found.replace("$", "  $");      //  add space characters after all dollar characters
                        found = found.simplified();     //  remove explicit white characters using simplify method
                        found.replace(" ", "  ");       //  double space characters in string
                        found.replace("(  ", "(");      //  remove space characters after left bracket

                        tree_child->setText(0, found);  //  set text of new class tree child
                        tree_parent->addChild(tree_child);  //  push new class tree child item
                    }
                }
            }
        }

        for (int j = 0; j < content_len; j++)           //  find starting block bracket in class body string
        {
            if (content[j] == '{')
            {
                int block_bracket_count = 1;
                j++;

                while (j < content_len)
                {
                    if (content[j] == '{')
                        block_bracket_count++;
                    else if (content[j] == '}')
                        block_bracket_count--;

                    if (block_bracket_count == 0)
                        break;
                    else
                        content[j] = ' ';               //  remove all bodies of all methods location inside body of actual class

                    j++;
                }
            }
        }

        for (int j = 0; j < content_len; j++)           //  replace all tabs and newlines by space characters
        {
            if (content[j] == '\t' || content[j] == '\n')
                content[j] = ' ';
        }

        QRegularExpression variable_regex("(static[ \t\n]+)"
                                          "[$][A-Za-z_][A-Za-z0-9_]*"
                                          );
        variable_regex.optimize();

        if (variable_regex.isValid())           //  check if regular expression of rule is valid
        {
            QRegularExpressionMatchIterator match_iter = variable_regex.globalMatch(content);    //  check for global match of regular expression from rule

            while (match_iter.hasNext())        //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                Class_tree_parent temp_variable;    //  save method item into description array
                temp_variable.from = match.capturedStart();     //  save coordinates of matched string into description array
                temp_variable.is_class = false;
                class_tree_parents.push_back(temp_variable);    //  push new item as class description parent

                QString found = match.captured();   //  save matched content into string variable
                found.replace('\t', ' ');       //  replace tabs with spaces in matched string
                found.replace('\n', ' ');       //  replace newlines with spaces in matched string
                found = found.simplified();     //  remove explicit white characters using simplify method

                int i = 1;
                int N = found.size();           //  get length of matched string

                while (i < N)                   //  iterate through matched string content
                {
                    if (found[i] == ' ')        //  remove explicit spaces characters from matched string content
                    {
                        if ((found[i - 1].isLetterOrNumber() || found[i - 1] == '_') &&
                            (found[i + 1].isLetterOrNumber() || found[i + 1] == '_'))
                        {
                            i++;
                        }
                        else
                        {
                            found.remove(i, 1);
                            N--;
                        }
                    }
                    else
                        i++;
                }

                QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  add new child into actual class item class tree

                bool is_static = false;

                if (found.startsWith("static "))
                {
                    is_static = true;
                    found.remove(0, 7);
                }

                if (is_static)
                {
                    tree_child->setIcon(0, * static_public_attribute_icon);
                    tree_child->setToolTip(0, "Static Variable");
                }
                else
                {
                    tree_child->setIcon(0, * public_attribute_icon);
                    tree_child->setToolTip(0, "Variable");
                }

                found.replace(" ", "  ");       //  double space characters in string
                found.replace(",", ",  ");      //  add space characters after all comma characters
                found.replace("$", "  $");      //  add space characters after all dollar characters
                found = found.simplified();     //  remove explicit white characters using simplify method
                found.replace(" ", "  ");       //  double space characters in string
                found.replace("(  ", "(");      //  remove space characters after left bracket

                tree_child->setText(0, found);  //  set text of new class tree child
                tree_root->addChild(tree_child);  //  push new class tree child item
            }
        }

        QRegularExpression const_regex("const[ \t\n]+[A-Za-z_][A-Za-z0-9_]*");
        const_regex.optimize();

        if (const_regex.isValid())                            //  check if regular expression of rule is valid
        {
            QRegularExpressionMatchIterator match_iter = const_regex.globalMatch(content);    //  check for global match of regular expression from rule

            while (match_iter.hasNext())                //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                Class_tree_parent temp_variable;    //  save method item into description array
                temp_variable.from = match.capturedStart();     //  save coordinates of matched string into description array
                temp_variable.is_class = false;
                class_tree_parents.push_back(temp_variable);    //  push new item as class description parent

                QString found = match.captured();       //  save matched content into string variable
                found.replace('\t', ' ');       //  replace tabs with spaces in matched string
                found.replace('\n', ' ');       //  replace newlines with spaces in matched string
                found = found.simplified();             //  remove explicit white characters using simplify method

                int i = 1;
                int N = found.size();           //  get length of matched string

                while (i < N)                   //  iterate through matched string content
                {
                    if (found[i] == ' ')        //  remove explicit spaces characters from matched string content
                    {
                        if ((found[i - 1].isLetterOrNumber() || found[i - 1] == '_') &&
                            (found[i + 1].isLetterOrNumber() || found[i + 1] == '_'))
                        {
                            i++;
                        }
                        else
                        {
                            found.remove(i, 1);
                            N--;
                        }
                    }
                    else
                        i++;
                }

                QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  add new child into actual class item class tree
                tree_child->setIcon(0, * public_attribute_icon);
                tree_child->setToolTip(0, "Variable");

                found.replace(" ", "  ");       //  double space characters in string
                found.replace(",", ",  ");      //  add space characters after all comma characters
                found.replace("$", "  $");      //  add space characters after all dollar characters
                found = found.simplified();     //  remove explicit white characters using simplify method
                found.replace(" ", "  ");       //  double space characters in string
                found.replace("(  ", "(");      //  remove space characters after left bracket

                tree_child->setText(0, found);  //  set text of new class tree child
                tree_root->addChild(tree_child);  //  push new class tree child item
            }
        }

        QRegularExpression function_regex("function[ \t\n]+[A-Za-z_][A-Za-z0-9_]*"
                                          "[ \t\n]*[(][^{]*[)][ \t\n]*{"
                                          );
        function_regex.optimize();

        if (function_regex.isValid())                            //  check if regular expression of rule is valid
        {
            QRegularExpressionMatchIterator match_iter = function_regex.globalMatch(content);   //  check for global match of regular expression from rule

            while (match_iter.hasNext())                //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                Class_tree_parent temp_function;    //  save method item into description array
                temp_function.from = match.capturedStart();     //  save coordinates of matched string into description array
                temp_function.is_class = false;
                class_tree_parents.push_back(temp_function);    //  push new item as class description parent

                QString found = match.captured();       //  save matched content into string variable
                found.chop(1);
                found.replace('\t', ' ');       //  replace tabs with spaces in matched string
                found.replace('\n', ' ');       //  replace newlines with spaces in matched string
                found = found.simplified();             //  remove explicit white characters using simplify method

                int i = 1;
                int N = found.size();           //  get length of matched string

                while (i < N)                   //  iterate through matched string content
                {
                    if (found[i] == ' ')        //  remove explicit spaces characters from matched string content
                    {
                        if ((found[i - 1].isLetterOrNumber() || found[i - 1] == '_') &&
                            (found[i + 1].isLetterOrNumber() || found[i + 1] == '_'))
                        {
                            i++;
                        }
                        else
                        {
                            found.remove(i, 1);
                            N--;
                        }
                    }
                    else
                        i++;
                }

                QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  add new child into actual class item class tree
                tree_child->setIcon(0, * public_method_icon);
                tree_child->setToolTip(0, "Function");

                if (found.startsWith("function "))
                    found.remove(0, 9);

                found.replace(" ", "  ");       //  double space characters in string
                found.replace(",", ",  ");      //  add space characters after all comma characters
                found.replace("$", "  $");      //  add space characters after all dollar characters
                found = found.simplified();     //  remove explicit white characters using simplify method
                found.replace(" ", "  ");       //  double space characters in string
                found.replace("(  ", "(");      //  remove space characters after left bracket

                tree_child->setText(0, found);  //  set text of new class tree child
                tree_root->addChild(tree_child);  //  push new class tree child item
            }
        }
    }
    else if (actual_language == python)                 //  selected language of actual text editor tab is Python
    {
        QString content = editor[index].document()->toPlainText();
        remove_comments_and_quotation(content, active_tabs[actual].language);  //  remove all comments and quotation from source code string

        QRegularExpression regex("[\n][ \t]*class[ \t]+[A-Za-z_][A-Za-z0-9_]*[ \t]*"
                                 "(\\([ \t]*[A-Za-z_][A-Za-z0-9_]*[ \t]*([ \t]*,[ \t]*[A-Za-z_][A-Za-z0-9_]*[ \t]*)*\\)){0,1}[ \t]*:");
        regex.optimize();

        if (regex.isValid())                            //  check if regular expression of rule is valid
        {
            QRegularExpressionMatchIterator match_iter = regex.globalMatch(content);    //  check for global match of regular expression from rule

            while (match_iter.hasNext())                //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                int from = match.capturedStart();       //  save starting index of matched content into variable
                int to = match.capturedEnd();           //  save ending index of matched content into variable
                QString found = match.captured();       //  save matched content into string variable
                QString parents = "";

                int position = found.indexOf('(');      //  check if parent classes specification is present

                if (position != -1)                     //  parent classes specification is present
                {
                    parents = found.mid(position, found.indexOf(')') - 1);  //  save parent classes specification into string variable
                    parents.remove(0, 1);
                    parents.chop(2);
                    parents = parents.simplified();     //  remove explicit white characters using simplify method
                }

                int indent = 0;                         //  Python command indentation counter
                int i = 1;

                while (found[i] == ' ' || found[i] == '\t')     //  only space and tab characters are allowed for indentation
                {
                    if (found[i] == ' ')
                        indent++;
                    else
                        indent += 8;                    //  tab character can be replaced using eight space characters when indent

                    i++;
                }

                bool end_reached = true;                //  holds if explicit end of class body found
                int body_end = content.size();          //  position of explicit end of class body
                QRegularExpression class_indent_regex("[\n][ \t]*[A-Za-z_]");
                class_indent_regex.optimize();
                                                        //  regular expression to find explicit end of class body
                if (class_indent_regex.isValid())       //  check if regular expression of rule is valid
                {                                       //  check for global match of regular expression from rule
                    QRegularExpressionMatchIterator match_iter = class_indent_regex.globalMatch(content, to);

                    while (match_iter.hasNext())        //  iterate through all regular expression matches
                    {
                        QRegularExpressionMatch match = match_iter.next();

                        QString found = match.captured();   //  save matched content into string variable

                        int end_indent = 0;             //  Python command indentation counter
                        int i = 1;

                        while (found[i] == ' ' || found[i] == '\t')     //  only space and tab characters are allowed for indentation
                        {
                            if (found[i] == ' ')
                                end_indent++;
                            else
                                end_indent += 8;        //  tab character can be replaced using eight space characters when indent

                            i++;
                        }

                        if (end_indent <= indent)       //  explicit end of class body found
                        {
                            body_end = match.capturedStart();
                            end_reached = false;        //  refresh appropriate flag value
                            break;
                        }
                    }
                }

                QString class_content = "";             //  save class body content into string variable

                if (end_reached)                        //  explicit end of class body found
                    class_content = content.mid(from);
                else                                    //  explicit end of class body not found
                    class_content = content.mid(from, body_end - from);

                int offset = 0;

                while (class_content[0] == ' ' || class_content[0] == '\t' || class_content[0] == '\n')
                {
                    class_content.remove(0, 1);
                    offset++;                           //  remove indentation from beginning of class body string
                }

                Class_tree_parent temp_class;           //  save class item into description array
                temp_class.from = from + offset;        //  save coordinates of class body into description array
                temp_class.to = body_end;
                class_tree_parents.push_back(temp_class);   //  push new description array item

                QString class_name = "";

                i = 0;

                while (class_content[i] != ' ' && class_content[i] != '\t')
                    i++;

                while (class_content[i] == ' ' || class_content[i] == '\t')
                    i++;

                while (class_content[i].isLetterOrNumber() || class_content[i] == '_')
                {
                    class_name.push_back(class_content[i]);     //  parse class name from class body string
                    i++;
                }

                QTreeWidgetItem * tree_parent = new QTreeWidgetItem;    //  create new class tree item
                tree_parent->setIcon(0, * class_icon);

                if (parents.size())                     //  set string with parent classes specification as new class tree tooltip
                    tree_parent->setToolTip(0, QString("Parents:  %1").arg(parents));
                else
                    tree_parent->setToolTip(0, "This class has no parents");

                tree_parent->setText(0, class_name);    //  set class name as new class tree item text
                tree_root->addChild(tree_parent);

                vector<QString> methods;                //  array which will hold strings of all found class methods
                                                        //  regular expression to match class method head
                QRegularExpression method_regex("\\bdef[ \t]+[A-Za-z_][A-Za-z0-9_]*[ \t]*"
                                                "\\([ \t]*self[ \t]*([ \t]*,[ \t]*[*]{0,1}[ \t]*[A-Za-z_][A-Za-z0-9_]*[ \t]*)*\\)[ \t]*:\\B");
                method_regex.optimize();

                if (method_regex.isValid())             //  check if regular expression of rule is valid
                {
                    QRegularExpressionMatchIterator match_iter = method_regex.globalMatch(class_content);

                    while (match_iter.hasNext())        //  iterate through all regular expression matches
                    {
                        QRegularExpressionMatch match = match_iter.next();

                        QString found = match.captured();

                        found.replace('\t', ' ');       //  replace tabs with spaces in matched string
                        found = found.simplified();     //  remove explicit white characters using simplify method

                        int i = 1;
                        int N = found.size();           //  get length of matched string

                        while (i < N)                   //  iterate through matched string content
                        {
                            if (found[i] == ' ')        //  remove explicit spaces characters from matched string content
                            {
                                if ((found[i - 1].isLetterOrNumber() || found[i - 1] == '_') &&
                                    (found[i + 1].isLetterOrNumber() || found[i + 1] == '_'))
                                {
                                    i++;
                                }
                                else
                                {
                                    found.remove(i, 1);
                                    N--;
                                }
                            }
                            else
                                i++;
                        }

                        QString ID = "";                //  holds method identifier
                        i = found.indexOf(' ') + 1;

                        while (i && (found[i].isLetterOrNumber() || found[i] == '_'))
                        {
                            if (!found[i].isLetterOrNumber() && found[i] != '_')
                                break;

                            ID.push_back(found[i]);     //  parse method identifier from matched string content
                            i++;
                        }

                        QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  add new child into actual class item class tree

                        if (ID == "__init__")           //  method is class constructor
                        {                               //  set appropriate icon and tooltip by class item type and its visibility
                            tree_child->setIcon(0, * public_method_icon);
                            tree_child->setToolTip(0, "Class constructor");
                        }
                        else if (ID == "__del__")       //  method is class destructor
                        {                               //  set appropriate icon and tooltip by class item type and its visibility
                            tree_child->setIcon(0, * public_method_icon);
                            tree_child->setToolTip(0, "Class destructor");
                        }
                        else if (ID.left(2) == "__")    //  method is private
                        {                               //  set appropriate icon and tooltip by class item type and its visibility
                            tree_child->setIcon(0, * private_method_icon);
                            tree_child->setToolTip(0, "Private method");
                        }
                        else                            //  method is public
                        {                               //  set appropriate icon and tooltip by class item type and its visibility
                            tree_child->setIcon(0, * public_method_icon);
                            tree_child->setToolTip(0, "Public method");
                        }

                        found.remove(0, 4);             //  remove def keyword from beginning of string
                        found.chop(1);
                        found.replace(" ", "  ");       //  double space characters in string
                        found.replace(",", ",  ");      //  add space characters after all comma characters

                        bool conflict = false;
                        N = methods.size();             //  get actual number of found class methods

                        for (int j = 0; j < N; j++)     //  check if same class method is already in array of all methods
                        {
                            if (methods[j] == found)
                            {
                                conflict = true;
                                break;
                            }
                        }

                        if (conflict == false)          //  class method is not yet in array of all methods
                        {
                            methods.push_back(found);   //  push found class method into array

                            tree_child->setText(0, found);  //  set text of new class tree child
                            tree_parent->addChild(tree_child);  //  push new class tree child item

                            Class_tree_child child;     //  save method item into description array
                            child.from = match.capturedStart();     //  save coordinates of matched string into description array
                            class_tree_parents[class_tree_parents.size() - 1].children.push_back(child);    //  push new item as class description parent
                        }
                    }
                }

                vector<QString> attributes;             //  array which will hold strings of all found class attributes
                                                        //  regular expression to match class attribute
                QRegularExpression attribute_regex("\\bself[ \t]*[.][ \t]*[A-Za-z_][A-Za-z0-9_]*\\b");
                attribute_regex.optimize();

                if (attribute_regex.isValid())          //  check if regular expression of rule is valid
                {
                    QRegularExpressionMatchIterator match_iter = attribute_regex.globalMatch(class_content);

                    while (match_iter.hasNext())        //  iterate through all regular expression matches
                    {
                        QRegularExpressionMatch match = match_iter.next();

                        QString found = match.captured();

                        found.replace('\t', ' ');       //  replace tabs with spaces in matched string
                        found = found.simplified();     //  remove explicit white characters using simplify attribute

                        int i = 1;
                        int N = found.size();           //  get length of matched string

                        while (i < N)                   //  iterate through matched string content
                        {
                            if (found[i] == ' ')        //  remove explicit spaces characters from matched string content
                            {
                                if ((found[i - 1].isLetterOrNumber() || found[i - 1] == '_') &&
                                    (found[i + 1].isLetterOrNumber() || found[i + 1] == '_'))
                                {
                                    i++;
                                }
                                else
                                {
                                    found.remove(i, 1);
                                    N--;
                                }
                            }
                            else
                                i++;
                        }

                        QString ID = found.mid(found.indexOf('.') + 1);     //  find attribute identifier
                        i = found.indexOf('.') + 1;

                        QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  add new child into actual class item class tree

                        if (ID.left(2) == "__")         //  attribute is private
                        {                               //  set appropriate icon and tooltip by class item type and its visibility
                            tree_child->setIcon(0, * private_attribute_icon);
                            tree_child->setToolTip(0, "Private attribute");
                        }
                        else if (ID.left(1) == "_")     //  attribute is only for internal use
                        {                               //  set appropriate icon and tooltip by class item type and its visibility
                            tree_child->setIcon(0, * protected_attribute_icon);
                            tree_child->setToolTip(0, "Attribute for internal use");
                        }
                        else                            //  attribute is public
                        {                               //  set appropriate icon and tooltip by class item type and its visibility
                            tree_child->setIcon(0, * public_attribute_icon);
                            tree_child->setToolTip(0, "Public attribute");
                        }

                        found.remove(0, 5);             //  remove self. from beginning of string
                        found.replace(" ", "  ");       //  double space characters in string
                        found.replace(",", ",  ");      //  add space characters after all comma characters

                        bool conflict = false;
                        N = attributes.size();          //  get actual number of found class attributes

                        for (int j = 0; j < N; j++)     //  check if same class attribute is already in array of all attributes
                        {
                            if (attributes[j] == found)
                            {
                                conflict = true;
                                break;
                            }
                        }

                        N = methods.size();             //  get actual number of found class methods

                        for (int j = 0; j < N; j++)     //  check if found attribute string is not some class method calling
                        {
                            QString temp = methods[j];

                            if (temp.left(temp.indexOf('(')) == found)
                            {
                                conflict = true;
                                break;
                            }
                        }

                        if (conflict == false)          //  class attribute is not yet in array of all attributes
                        {
                            attributes.push_back(found);    //  push found class attribute into array

                            tree_child->setText(0, found);  //  set text of new class tree child
                            tree_parent->addChild(tree_child);  //  push new class tree child item

                            Class_tree_child child;     //  save attribute item into description array
                            child.from = match.capturedStart(); //  save coordinates of matched string into description array
                            class_tree_parents[class_tree_parents.size() - 1].children.push_back(child);    //  push new item as class description parent
                        }
                    }
                }
            }
        }

        int N = class_tree_parents.size();

        for (int i = 0; i < N; i++)                     //  iterate through all found classes
        {
            int from = class_tree_parents[i].from;      //  get position of found class
            int to = class_tree_parents[i].to;

            for (int j = from; j < to; j++)
                content[j] = ' ';                       //  insert space character instead of actual character
        }

        vector<QString> functions;                      //  array which will hold strings of all found class functions
                                                        //  regular expression to match class method head
        QRegularExpression method_regex("\\bdef[ \t]+[A-Za-z_][A-Za-z0-9_]*[ \t]*"
                                        "\\(([ \t]*[*]{0,1}[ \t]*[A-Za-z_][A-Za-z0-9_]*[ \t]*"
                                        "([ \t]*,[ \t]*[*]{0,1}[ \t]*[A-Za-z_][A-Za-z0-9_]*[ \t]*)*){0,1}\\)[ \t]*:\\B");
        method_regex.optimize();

        if (method_regex.isValid())                     //  check if regular expression of rule is valid
        {
            QRegularExpressionMatchIterator match_iter = method_regex.globalMatch(content);

            while (match_iter.hasNext())                //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                QString found = match.captured();

                found.replace('\t', ' ');               //  replace tabs with spaces in matched string
                found = found.simplified();             //  remove explicit white characters using simplify method

                int i = 1;
                int N = found.size();                   //  get length of matched string

                while (i < N)                           //  iterate through matched string content
                {
                    if (found[i] == ' ')                //  remove explicit spaces characters from matched string content
                    {
                        if ((found[i - 1].isLetterOrNumber() || found[i - 1] == '_') &&
                            (found[i + 1].isLetterOrNumber() || found[i + 1] == '_'))
                        {
                            i++;
                        }
                        else
                        {
                            found.remove(i, 1);
                            N--;
                        }
                    }
                    else
                        i++;
                }

                QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  add new child into actual class item class tree
                tree_child->setIcon(0, * public_method_icon);
                tree_child->setToolTip(0, "Function");

                found.remove(0, 4);                     //  remove def keyword from beginning of string
                found.chop(1);
                found.replace(" ", "  ");               //  double space characters in string
                found.replace(",", ",  ");              //  add space characters after all comma characters

                bool conflict = false;
                N = functions.size();                   //  get actual number of found class functions

                for (int j = 0; j < N; j++)             //  check if same class method is already in array of all functions
                {
                    if (functions[j] == found)
                    {
                        conflict = true;
                        break;
                    }
                }

                if (conflict == false)                  //  class method is not yet in array of all functions
                {
                    functions.push_back(found);         //  push found class method into array

                    tree_child->setText(0, found);      //  set text of new class tree child
                    tree_root->addChild(tree_child);    //  push new class tree child item

                    Class_tree_parent temp_function;    //  save method item into description array
                    temp_function.from = match.capturedStart();     //  save coordinates of matched string into description array
                    temp_function.is_class = false;
                    class_tree_parents.push_back(temp_function);    //  push new item as class description parent
                }
            }
        }

        vector<QString> variables;                      //  array which will hold strings of all found class variables
                                                        //  regular expression to match class attribute
        QRegularExpression attribute_regex("\\b[A-Za-z_][A-Za-z0-9_]*[ \t\n]*=");
        attribute_regex.optimize();

        if (attribute_regex.isValid())                  //  check if regular expression of rule is valid
        {
            QRegularExpressionMatchIterator match_iter = attribute_regex.globalMatch(content);

            while (match_iter.hasNext())                //  iterate through all regular expression matches
            {
                QRegularExpressionMatch match = match_iter.next();

                QString found = match.captured();

                found.replace('\t', ' ');               //  replace tabs with spaces in matched string
                found = found.simplified();             //  remove explicit white characters using simplify method

                int i = 1;
                int N = found.size();                   //  get length of matched string

                while (i < N)                           //  iterate through matched string content
                {
                    if (found[i] == ' ')                //  remove explicit spaces characters from matched string content
                    {
                        if ((found[i - 1].isLetterOrNumber() || found[i - 1] == '_') &&
                            (found[i + 1].isLetterOrNumber() || found[i + 1] == '_'))
                        {
                            i++;
                        }
                        else
                        {
                            found.remove(i, 1);
                            N--;
                        }
                    }
                    else
                        i++;
                }

                QTreeWidgetItem * tree_child = new QTreeWidgetItem;     //  add new child into actual class item class tree
                tree_child->setIcon(0, * public_attribute_icon);
                tree_child->setToolTip(0, "Variable");

                found.chop(1);
                found.replace(" ", "  ");               //  double space characters in string
                found.replace(",", ",  ");              //  add space characters after all comma characters

                bool conflict = false;
                N = variables.size();                   //  get actual number of found class variables

                for (int j = 0; j < N; j++)             //  check if same class method is already in array of all variables
                {
                    if (variables[j] == found)
                    {
                        conflict = true;
                        break;
                    }
                }

                if (conflict == false)                  //  class method is not yet in array of all variables
                {
                    variables.push_back(found);         //  push found class method into array

                    tree_child->setText(0, found);      //  set text of new class tree child
                    tree_root->addChild(tree_child);    //  push new class tree child item

                    Class_tree_parent temp_variable;    //  save method item into description array
                    temp_variable.from = match.capturedStart();     //  save coordinates of matched string into description array
                    temp_variable.is_class = false;
                    class_tree_parents.push_back(temp_variable);    //  push new item as class description parent
                }
            }
        }
    }

    ui->class_tree->expandAll();
}


/// Reaction to key press in Vim mode with description of key in parameters
///
/// @param  Integer representation of concrete key
/// @param  String representation of concrete key
void Spade::vim_key_press(int type, QString text)
{
    if (vim_replace_flag)                               //  Vim replace mode is active
    {
        if (text.size() == 1 && text[0].isPrint())      //  single character has been pressed
        {                                               //  mark actual character in text with selection
            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            text_cursor->clearSelection();              //  clear actual text cursor selection
            text_cursor->setPosition(text_cursor->position() + 1, QTextCursor::KeepAnchor);
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                                        //  replace selection by appropriate character
            editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText(text);
            return;
        }
        else if (type == Qt::Key_Tab)                   //  tab key has been pressed
        {                                               //  mark actual character in text with selection
            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            text_cursor->clearSelection();              //  clear actual text cursor selection
            text_cursor->setPosition(text_cursor->position() + 1, QTextCursor::KeepAnchor);
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                                        //  replace selection by appropriate character
            editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("\t");
            return;
        }
    }

    if (vim_character_queue.right(1) == "r" && text.size() == 1)    //  replace command has been used
    {
        vim_character_queue.chop(1);

        int times = 1;

        QRegExp re("\\d+");

        if (re.exactMatch(vim_character_queue))         //  check if there is multiplier present
           times = vim_character_queue.toInt();         //  convert characters sequence into the multiplier number

        for (int i = 0; i < times; i++)                 //  replace desired number of characters by specified character
        {
            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            text_cursor->clearSelection();              //  clear actual text cursor selection
            text_cursor->setPosition(text_cursor->position() + 1, QTextCursor::KeepAnchor);
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                                        //  matk single character by selection and insert specified character
            editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText(text);
        }

        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
        text_cursor->setPosition(text_cursor->position() - 1);  //  move text cursor to correct position
        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

        vim_character_queue = "";
        return;
    }

    if (type == Qt::Key_F11)                            //  fullscreen button has been pressed
    {
        fullscreen_button_pressed();
        return;
    }
    else if (type == Qt::Key_Delete)                    //  delete command has been used
    {
        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
        text_cursor->deleteChar();
        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
    }
    else if (type == Qt::Key_Escape)                    //  Vim leave command has been used
    {
        vim_edit->clear();
        vim_visual_flag = false;                        //  disable Vim visual flag
        vim_replace_flag = false;                       //  toggle appropriate flags

        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
        text_cursor->clearSelection();                  //  remove text selection       //  clear actual text cursor selection
        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
    }
    else if (vim_character_queue.right(1) == "f" && text.size() == 1 && text[0].isPrint())  //  character find command has been used
    {
        vim_character_queue.chop(1);

        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        int times = 1;

        QRegExp re("\\d+");

        if (re.exactMatch(vim_character_queue))         //  get multiplier value from command
           times = vim_character_queue.toInt();         //  convert characters sequence into the multiplier number

        for (int i = 0; i < times; i++)                 //  use multiplier value using loop
        {
            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            int actual = text_cursor->columnNumber();
            text_cursor->movePosition(QTextCursor::StartOfBlock);
            text_cursor->movePosition(QTextCursor::EndOfBlock, QTextCursor::KeepAnchor);

            QString selected_text = text_cursor->selection().toPlainText();
            int len = selected_text.size();

            for (int j = actual + 1; j < len; j++)      //  try to find nearest position of desired character using loop
            {
                if (selected_text[j] == text[0])        //  desired character found
                {
                    actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position() + j - actual;

                    if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag has been used   //  delete, lowercase or uppercase flag is active
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->clearSelection();  //  clear actual text cursor selection
                        text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                        if (delete_flag)                //  recognize concrete flag
                            editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                        else if (lower_flag)
                            lower_case_button_pressed();    //  convert selected text into lowercase text
                        else
                            upper_case_button_pressed();    //  convert selected text into uppercase text
                    }
                    else if (vim_visual_flag)           //  Vim visual mode is active           //  Vim visual mode is active                           //  Vim visual mode is active
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                    }
                    else                                //  Vim visual mode is inactive
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->setPosition(actual);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                    }

                    break;
                }
            }
        }

        if (insert_flag)                                //  insert command has been used
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if (vim_character_queue.right(1) == "F" && text.size() == 1 && text[0].isPrint())  //  backwards character find command has been used
    {
        vim_character_queue.chop(1);

        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        int times = 1;

        QRegExp re("\\d+");

        if (re.exactMatch(vim_character_queue))         //  get multiplier value from command
           times = vim_character_queue.toInt();         //  convert characters sequence into the multiplier number

        for (int i = 0; i < times; i++)                 //  use multiplier value using loop
        {
            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            int actual = text_cursor->columnNumber();
            text_cursor->movePosition(QTextCursor::StartOfBlock);
            text_cursor->movePosition(QTextCursor::EndOfBlock, QTextCursor::KeepAnchor);

            QString selected_text = text_cursor->selection().toPlainText();

            for (int j = actual - 1; j >= 0; j--)
            {
                if (selected_text[j] == text[0])
                {
                    actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position() + j - actual;

                    if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->clearSelection();  //  clear actual text cursor selection
                        text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                        if (delete_flag)
                            editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                        else if (lower_flag)
                            lower_case_button_pressed();    //  convert selected text into lowercase text
                        else
                            upper_case_button_pressed();    //  convert selected text into uppercase text
                    }
                    else if (vim_visual_flag)           //  Vim visual mode is active
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                    }
                    else
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->setPosition(actual);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                    }

                    break;
                }
            }
        }

        if (insert_flag)                                //  insert command has been used
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if (vim_character_queue.right(1) == "t" && text.size() == 1 && text[0].isPrint())  //  character find command has been used
    {
        vim_character_queue.chop(1);

        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        int times = 1;

        QRegExp re("\\d+");

        if (re.exactMatch(vim_character_queue))         //  get multiplier value from command
           times = vim_character_queue.toInt();         //  convert characters sequence into the multiplier number

        for (int i = 0; i < times; i++)                 //  use multiplier value using loop
        {
            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            int actual = text_cursor->columnNumber();
            text_cursor->movePosition(QTextCursor::StartOfBlock);
            text_cursor->movePosition(QTextCursor::EndOfBlock, QTextCursor::KeepAnchor);

            QString selected_text = text_cursor->selection().toPlainText();
            int len = selected_text.size();

            for (int j = actual + 1; j < len; j++)
            {
                if (selected_text[j] == text[0])
                {
                    actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position() + j - actual - 1;

                    if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->clearSelection();      //  clear actual text cursor selection
                        text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                        if (delete_flag)
                            editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                        else if (lower_flag)
                            lower_case_button_pressed();    //  convert selected text into lowercase text
                        else
                            upper_case_button_pressed();    //  convert selected text into uppercase text
                    }
                    else if (vim_visual_flag)           //  Vim visual mode is active                           //  Vim visual mode is active
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                    }
                    else
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->setPosition(actual);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                    }

                    break;
                }
            }
        }

        if (insert_flag)                                //  insert command has been used
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if (vim_character_queue.right(1) == "T" && text.size() == 1 && text[0].isPrint())  //  backwards character find command has been used
    {
        vim_character_queue.chop(1);

        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        int times = 1;

        QRegExp re("\\d+");

        if (re.exactMatch(vim_character_queue))         //  get multiplier value from command
           times = vim_character_queue.toInt();         //  convert characters sequence into the multiplier number

        for (int i = 0; i < times; i++)                 //  use multiplier value using loop
        {
            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            int actual = text_cursor->columnNumber();
            text_cursor->movePosition(QTextCursor::StartOfBlock);
            text_cursor->movePosition(QTextCursor::EndOfBlock, QTextCursor::KeepAnchor);

            QString selected_text = text_cursor->selection().toPlainText();

            for (int j = actual - 1; j >= 0; j--)
            {
                if (selected_text[j] == text[0])
                {
                    actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position() + j - actual + 1;

                    if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->clearSelection();      //  clear actual text cursor selection
                        text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                        if (delete_flag)
                            editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                        else if (lower_flag)
                            lower_case_button_pressed();    //  convert selected text into lowercase text
                        else
                            upper_case_button_pressed();    //  convert selected text into uppercase text
                    }
                    else if (vim_visual_flag)           //  Vim visual mode is active                           //  Vim visual mode is active
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                    }
                    else
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->setPosition(actual);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                    }

                    break;
                }
            }
        }

        if (insert_flag)                                //  insert command has been used
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if (type == Qt::Key_Enter || type == Qt::Key_Return)   //  enter command has been used
    {
        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        int times = 1;

        QRegExp re("\\d+");

        if (re.exactMatch(vim_character_queue))         //  get multiplier value from command
           times = vim_character_queue.toInt();         //  convert characters sequence into the multiplier number

        for (int i = 0; i < times; i++)                 //  use multiplier value using loop
        {
            int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().blockNumber();

            if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
            {
                QTextCursor line_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(actual + 1));

                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->clearSelection();          //  clear actual text cursor selection
                text_cursor->setPosition(line_cursor.position(), QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                QString editor_content = editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText();
                int len = editor_content.size();
                int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();

                while (actual < len && editor_content[actual].isSpace())
                    actual++;

                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                if (delete_flag)
                    editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                else if (lower_flag)
                    lower_case_button_pressed();        //  convert selected text into lowercase text
                else
                    upper_case_button_pressed();        //  convert selected text into uppercase text
            }
            else if (vim_visual_flag)                   //  Vim visual mode is active
            {
                QTextCursor line_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(actual + 1));

                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->setPosition(line_cursor.position(), QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                QString editor_content = editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText();
                int len = editor_content.size();
                int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();

                while (actual < len && editor_content[actual].isSpace())
                    actual++;

                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
            }
            else
            {
                QTextCursor line_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(actual + 1));
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(line_cursor);

                QString editor_content = editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText();
                int len = editor_content.size();
                int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();

                while (actual < len && editor_content[actual].isSpace())
                    actual++;

                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->setPosition(actual);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
            }
        }

        if (insert_flag)                                //  insert command has been used
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if (type == Qt::Key_Y)                         //  text copy command has been used
    {
        if (vim_visual_flag)                            //  Vim visual mode is active
        {
            editor[active_tabs[files->currentIndex()].index_in_tabs].copy();

            vim_edit->clear();
            vim_visual_flag = false;                    //  disable Vim visual flag
            vim_replace_flag = false;                   //  disable Vim replace flag

            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();

            QString selected_text = text_cursor->selection().toPlainText();
            int lines = selected_text.count("\n") + 1;

            if (lines >= 2)
                vim_edit->setText(QString("%1 lines yanked").arg(lines));

            text_cursor->clearSelection();              //  clear actual text cursor selection
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
        }
        else
        {
            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            text_cursor->movePosition(QTextCursor::StartOfBlock);
            text_cursor->movePosition(QTextCursor::EndOfBlock, QTextCursor::KeepAnchor);

            editor[active_tabs[files->currentIndex()].index_in_tabs].copy();
        }
    }
    else if (type == Qt::Key_P)                         //  text paste command has been used
    {
        if (vim_visual_flag)                            //  Vim visual mode is active
        {
            vim_edit->clear();
            vim_visual_flag = false;                    //  disable Vim visual flag
            vim_replace_flag = false;                   //  disable Vim replace flag

            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            text_cursor->clearSelection();              //  clear actual text cursor selection
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
        }

        editor[active_tabs[files->currentIndex()].index_in_tabs].paste();
    }
    else if (type == Qt::Key_U && vim_character_queue.right(1) != "g")  //  text undo command has been used
    {
        if (vim_visual_flag)                            //  Vim visual mode is active
        {
            vim_edit->clear();
            vim_visual_flag = false;                    //  disable Vim visual flag
            vim_replace_flag = false;                   //  disable Vim replace flag

            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            text_cursor->clearSelection();              //  clear actual text cursor selection
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
        }
        else
        {
            editor[active_tabs[files->currentIndex()].index_in_tabs].undo();
        }
    }
    else if (type == Qt::Key_R && text == "control")    //  text redo command has been used
    {
        if (vim_visual_flag)                            //  Vim visual mode is active
        {
            vim_edit->clear();
            vim_visual_flag = false;                    //  disable Vim visual flag
            vim_replace_flag = false;                   //  disable Vim replace flag

            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            text_cursor->clearSelection();              //  clear actual text cursor selection
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
        }
        else
        {
            editor[active_tabs[files->currentIndex()].index_in_tabs].redo();
        }
    }
    else if (text == "R")                               //  Vim replace mode is going to be active
    {
        if (vim_visual_flag)                            //  Vim visual mode is active
        {
            vim_edit->clear();
            vim_visual_flag = false;                    //  disable Vim visual flag
            vim_replace_flag = false;                   //  disable Vim replace flag

            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            text_cursor->clearSelection();              //  clear actual text cursor selection
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
        }
        else
        {
            vim_edit->setText("- -  REPLACE  - -");     //  use replace mode sign in Vim tray
            vim_replace_flag = true;
        }
    }
    else if (text == "n")                               //  next pattern search command has been used
    {
        if (vim_find_pattern.size())
        {
            bool delete_flag = false;                   //  clear appropriate flags
            bool insert_flag = false;
            bool lower_flag = false;
            bool upper_flag = false;

            if (vim_character_queue.right(1) == "d")    //  delete command has been combined with desired command
            {
                delete_flag = true;                     //  set delete flag
                vim_character_queue.chop(1);
            }
            else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
            {
                delete_flag = true;                     //  set delete flag
                insert_flag = true;                     //  set insert flag
                vim_character_queue.chop(1);
            }
            else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
            {
                lower_flag = true;                      //  set lowercase flag
                vim_character_queue.chop(2);
            }
            else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
            {
                upper_flag = true;                      //  set uppercase flag
                vim_character_queue.chop(2);
            }

            int times = 1;

            QRegExp re("\\d+");

            if (re.exactMatch(vim_character_queue))     //  get multiplier value from command
               times = vim_character_queue.toInt();     //  convert characters sequence into the multiplier number

            if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->clearSelection();          //  clear actual text cursor selection
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
            }

            for (int j = 1; j <= times; j++)
            {
                if (delete_flag || lower_flag || upper_flag || vim_visual_flag)
                {
                    QRegularExpression expr(vim_find_pattern);
                    expr.setPatternOptions(QRegularExpression::DotMatchesEverythingOption);     //  allow multiline match for regular expression
                    expr.optimize();

                    if (expr.isValid())                 //  check if regular expression is valid
                    {
                        vector<int> from_array;         //  array with starting positions of all regular expression matches
                        vector<int> to_array;           //  array with ending positions of all regular expression matches

                        QRegularExpressionMatchIterator iter = expr.globalMatch(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText());
                                                        //  check for global match of regular expression and save result into match iterator
                        while (iter.hasNext())          //  iterate through all matches
                        {
                            QRegularExpressionMatch match = iter.next();

                            if (match.hasMatch())       //  regular expression match found
                            {
                                from_array.push_back(match.capturedStart(0));   //  push coordinates of match into appropriate arrays
                                to_array.push_back(match.capturedEnd(0));
                            }
                        }

                        int N = from_array.size();      //  get number of regular expression matches

                        if (N)                          //  at least one match must be present
                        {                               //  get actual text cursor position
                            int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();

                            if (N == 1)                 //  just highlight one and only match by text cursor selection
                            {
                                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                text_cursor->setPosition(from_array[0], QTextCursor::KeepAnchor);
                                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                                return;                 //  stop searching
                            }

                            bool found = false;         //  holds if appropriate match was selected

                            for (int i = 0; i < N; i++)     //  iterate again through all matches
                            {
                                if (from_array[i] <= actual && actual <= to_array[i])   //  cursor position is at location of actual match
                                {
                                    if (i == N - 1)     //  actual match is last in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[0], QTextCursor::KeepAnchor);    //  highlight first match of file content
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }
                                    else                //  actual match is not last in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[i + 1], QTextCursor::KeepAnchor);    //  highlight next match
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }

                                    found = true;
                                    break;              //  stop searching
                                }
                                else if (actual < from_array[i])    //  cursor position is before location of actual match
                                {
                                    * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                    text_cursor->setPosition(from_array[i], QTextCursor::KeepAnchor);    //  highlight actual match
                                    editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                                    found = true;
                                    break;              //  stop searching
                                }
                            }

                            if (found == false)
                            {                           //  select first match if flag is not set
                                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                text_cursor->setPosition(from_array[0], QTextCursor::KeepAnchor);    //  highlight first match of file content
                                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                            }
                        }
                    }
                }
                else
                {
                    QRegularExpression expr(vim_find_pattern);
                    expr.setPatternOptions(QRegularExpression::DotMatchesEverythingOption);     //  allow multiline match for regular expression
                    expr.optimize();

                    if (expr.isValid())                 //  check if regular expression is valid
                    {
                        vector<int> from_array;         //  array with starting positions of all regular expression matches
                        vector<int> to_array;           //  array with ending positions of all regular expression matches

                        QRegularExpressionMatchIterator iter = expr.globalMatch(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText());
                                                        //  check for global match of regular expression and save result into match iterator
                        while (iter.hasNext())          //  iterate through all matches
                        {
                            QRegularExpressionMatch match = iter.next();

                            if (match.hasMatch())       //  regular expression match found
                            {
                                from_array.push_back(match.capturedStart(0));   //  push coordinates of match into appropriate arrays
                                to_array.push_back(match.capturedEnd(0));
                            }
                        }

                        int N = from_array.size();      //  get number of regular expression matches

                        if (N)                          //  at least one match must be present
                        {                               //  get actual text cursor position
                            int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();

                            if (N == 1)                 //  just highlight one and only match by text cursor selection
                            {
                                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                text_cursor->setPosition(from_array[0]);
                                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                                return;                 //  stop searching
                            }

                            bool found = false;         //  holds if appropriate match was selected

                            for (int i = 0; i < N; i++)     //  iterate again through all matches
                            {
                                if (from_array[i] <= actual && actual <= to_array[i])   //  cursor position is at location of actual match
                                {
                                    if (i == N - 1)     //  actual match is last in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[0]);    //  highlight first match of file content by text cursor selection
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }
                                    else                //  actual match is not last in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[i + 1]);    //  highlight next match by text cursor selection
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }

                                    found = true;
                                    break;              //  stop searching
                                }
                                else if (actual < from_array[i])    //  cursor position is before location of actual match
                                {
                                    * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                    text_cursor->setPosition(from_array[i]);    //  highlight actual match by text cursor selection
                                    editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                                    found = true;
                                    break;              //  stop searching
                                }
                            }

                            if (found == false)
                            {                           //  select first match if flag is not set
                                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                text_cursor->setPosition(from_array[0]);    //  highlight first match of file content by text cursor selection
                                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                            }
                        }
                    }
                }
            }

            if (delete_flag)
                editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
            else if (lower_flag)
                lower_case_button_pressed();            //  convert selected text into lowercase text
            else if (upper_flag)
                upper_case_button_pressed();            //  convert selected text into uppercase text

            if (insert_flag)                            //  insert command has been used
            {
                int index = active_tabs[files->currentIndex()].index_in_tabs;

                vim_edit->setText("- -  INSERT  - -");  //  activate Vim insert mode
                editor[index].vim_active = false;       //  activate overwrite mode in text editor
                editor[index].setOverwriteMode(insert_mode);
            }
        }
    }
    else if (text == "N")                               //  previous pattern search command has been used
    {
        if (vim_find_pattern.size())
        {
            bool delete_flag = false;                   //  clear appropriate flags
            bool insert_flag = false;
            bool lower_flag = false;
            bool upper_flag = false;

            if (vim_character_queue.right(1) == "d")    //  delete command has been combined with desired command
            {
                delete_flag = true;                     //  set delete flag
                vim_character_queue.chop(1);
            }
            else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
            {
                delete_flag = true;                     //  set delete flag
                insert_flag = true;                     //  set insert flag
                vim_character_queue.chop(1);
            }
            else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
            {
                lower_flag = true;                      //  set lowercase flag
                vim_character_queue.chop(2);
            }
            else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
            {
                upper_flag = true;                      //  set uppercase flag
                vim_character_queue.chop(2);
            }

            int times = 1;

            QRegExp re("\\d+");

            if (re.exactMatch(vim_character_queue))     //  get multiplier value from command
               times = vim_character_queue.toInt();     //  convert characters sequence into the multiplier number

            if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->clearSelection();          //  clear actual text cursor selection
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
            }

            for (int j = 1; j <= times; j++)
            {
                if (delete_flag || lower_flag || upper_flag || vim_visual_flag)
                {
                    QRegularExpression expr(vim_find_pattern);
                    expr.setPatternOptions(QRegularExpression::DotMatchesEverythingOption);     //  allow multiline match for regular expression
                    expr.optimize();

                    if (expr.isValid())                 //  check if regular expression is valid
                    {
                        vector<int> from_array;         //  array with starting positions of all regular expression matches
                        vector<int> to_array;           //  array with ending positions of all regular expression matches

                        QRegularExpressionMatchIterator iter = expr.globalMatch(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText());
                                                        //  check for global match of regular expression and save result into match iterator
                        while (iter.hasNext())          //  iterate through all matches
                        {
                            QRegularExpressionMatch match = iter.next();

                            if (match.hasMatch())       //  regular expression match found
                            {
                                from_array.push_back(match.capturedStart(0));   //  push coordinates of match into appropriate arrays
                                to_array.push_back(match.capturedEnd(0));
                            }
                        }

                        int N = from_array.size();      //  get number of regular expression matches

                        if (N)                          //  at least one match must be present
                        {                               //  get actual text cursor position
                            int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();

                            if (N == 1)                 //  just highlight one and only match by text cursor selection
                            {
                                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                text_cursor->setPosition(from_array[0], QTextCursor::KeepAnchor);
                                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                                return;                 //  stop searching
                            }

                            bool found = false;         //  holds if appropriate match was selected

                            for (int i = 0; i < N; i++)     //  iterate again through all matches
                            {
                                if (from_array[i] <= actual && actual <= to_array[i])   //  cursor position is at location of actual match
                                {
                                    if (i)              //  actual match is not first in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[i - 1], QTextCursor::KeepAnchor);    //  highlight previous match
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }
                                    else                //  actual match is first in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[N - 1], QTextCursor::KeepAnchor);    //  highlight last match of file content
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }

                                    found = true;
                                    break;              //  stop searching
                                }
                                else if (actual < from_array[i])    //  cursor position is before location of actual match
                                {
                                    if (i)              //  actual match is not first in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[i - 1], QTextCursor::KeepAnchor);    //  highlight previous match
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }
                                    else                //  actual match is first in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[N - 1], QTextCursor::KeepAnchor);    //  highlight last match of file content
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }

                                    found = true;
                                    break;              //  stop searching
                                }
                            }

                            if (found == false)
                            {                           //  select last match if flag is not set
                                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                text_cursor->setPosition(from_array[N - 1], QTextCursor::KeepAnchor);    //  highlight last match of file content
                                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                            }
                        }
                    }
                }
                else
                {
                    QRegularExpression expr(vim_find_pattern);
                    expr.setPatternOptions(QRegularExpression::DotMatchesEverythingOption);     //  allow multiline match for regular expression
                    expr.optimize();

                    if (expr.isValid())                 //  check if regular expression is valid
                    {
                        vector<int> from_array;         //  array with starting positions of all regular expression matches
                        vector<int> to_array;           //  array with ending positions of all regular expression matches

                        QRegularExpressionMatchIterator iter = expr.globalMatch(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText());
                                                        //  check for global match of regular expression and save result into match iterator
                        while (iter.hasNext())          //  iterate through all matches
                        {
                            QRegularExpressionMatch match = iter.next();

                            if (match.hasMatch())       //  regular expression match found
                            {
                                from_array.push_back(match.capturedStart(0));   //  push coordinates of match into appropriate arrays
                                to_array.push_back(match.capturedEnd(0));
                            }
                        }

                        int N = from_array.size();      //  get number of regular expression matches

                        if (N)                          //  at least one match must be present
                        {                               //  get actual text cursor position
                            int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();

                            if (N == 1)                 //  just highlight one and only match by text cursor selection
                            {
                                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                text_cursor->setPosition(from_array[0]);
                                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                                return;                 //  stop searching
                            }

                            bool found = false;         //  holds if appropriate match was selected

                            for (int i = 0; i < N; i++)     //  iterate again through all matches
                            {
                                if (from_array[i] <= actual && actual <= to_array[i])   //  cursor position is at location of actual match
                                {
                                    if (i)              //  actual match is not first in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[i - 1]);    //  highlight previous match by text cursor selection
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }
                                    else                //  actual match is first in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[N - 1]);    //  highlight last match of file content by text cursor selection
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }

                                    found = true;
                                    break;              //  stop searching
                                }
                                else if (actual < from_array[i])    //  cursor position is before location of actual match
                                {
                                    if (i)              //  actual match is not first in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[i - 1]);    //  highlight previous match by text cursor selection
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }
                                    else                //  actual match is first in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[N - 1]);    //  highlight last match of file content by text cursor selection
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }

                                    found = true;
                                    break;              //  stop searching
                                }
                            }

                            if (found == false)
                            {                           //  select last match if flag is not set
                                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                text_cursor->setPosition(from_array[N - 1]);    //  highlight last match of file content by text cursor selection
                                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                            }
                        }
                    }
                }
            }

            if (delete_flag)
                editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
            else if (lower_flag)
                lower_case_button_pressed();            //  convert selected text into lowercase text
            else if (upper_flag)
                upper_case_button_pressed();            //  convert selected text into uppercase text

            if (insert_flag)                            //  insert command has been used
            {
                int index = active_tabs[files->currentIndex()].index_in_tabs;

                vim_edit->setText("- -  INSERT  - -");  //  activate Vim insert mode
                editor[index].vim_active = false;       //  activate overwrite mode in text editor
                editor[index].setOverwriteMode(insert_mode);
            }
        }
    }
    else if (text == "/")                               //  Vim search mode is going to be active
    {
        vim_prefix->setText("/");
        vim_prefix->show();
        vim_edit->setText("");
        vim_edit->setReadOnly(false);
        vim_edit->setFocus();
        editor[active_tabs[files->currentIndex()].index_in_tabs].setReadOnly(true);

        return;
    }
    else if (text == "v")                               //  Vim visual mode is going to be active
    {
        if (vim_visual_flag)                            //  Vim visual mode is active
        {
            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            text_cursor->setPosition(text_cursor->position());
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

            vim_edit->clear();
            vim_visual_flag = false;                    //  disable Vim visual flag
        }
        else
        {
            vim_edit->setText("- -  VISUAL  - -");      //  use visual mode sign in Vim tray
            vim_visual_flag = true;
        }
    }
    else if (text == "i")                               //  Vim insert mode is going to be active
    {
        if (vim_visual_flag == false)                   //  Vim visual mode is inactive
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if (text == "a")                               //  Vim insert mode is going to be active
    {
        if (vim_visual_flag == false)                   //  Vim visual mode is inactive
        {
            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[active_tabs[files->currentIndex()].index_in_tabs].vim_active = false;
            editor[active_tabs[files->currentIndex()].index_in_tabs].key_press_flag = true;

            QKeyEvent * event = new QKeyEvent(QEvent::KeyPress, Qt::Key_Right, Qt::NoModifier);
            QApplication::postEvent(QApplication::focusWidget(), event);
        }
    }
    else if (text == "I")                               //  Vim insert mode is going to be active
    {
        if (vim_visual_flag == false)                   //  Vim visual mode is inactive
        {
            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[active_tabs[files->currentIndex()].index_in_tabs].vim_active = false;
            editor[active_tabs[files->currentIndex()].index_in_tabs].key_press_flag = true;

            QKeyEvent * event = new QKeyEvent(QEvent::KeyPress, Qt::Key_Home, Qt::NoModifier);
            QApplication::postEvent(QApplication::focusWidget(), event);
        }
    }
    else if (text == "A")                               //  Vim insert mode is going to be active
    {
        if (vim_visual_flag == false)                   //  Vim visual mode is inactive
        {
            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[active_tabs[files->currentIndex()].index_in_tabs].vim_active = false;
            editor[active_tabs[files->currentIndex()].index_in_tabs].key_press_flag = true;

            QKeyEvent * event = new QKeyEvent(QEvent::KeyPress, Qt::Key_End, Qt::NoModifier);
            QApplication::postEvent(QApplication::focusWidget(), event);
        }
    }
    else if (text == "o")                               //  Vim insert mode is going to be active
    {
        if (vim_visual_flag == false)                   //  Vim visual mode is inactive
        {
            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[active_tabs[files->currentIndex()].index_in_tabs].vim_active = false;
            editor[active_tabs[files->currentIndex()].index_in_tabs].key_press_flag = true;

            QKeyEvent * event = new QKeyEvent(QEvent::KeyPress, Qt::Key_End, Qt::NoModifier);
            QApplication::postEvent(QApplication::focusWidget(), event);

            editor[active_tabs[files->currentIndex()].index_in_tabs].key_press_flag = true;

            event = new QKeyEvent(QEvent::KeyPress, Qt::Key_Enter, Qt::NoModifier);
            QApplication::postEvent(QApplication::focusWidget(), event);

            editor[active_tabs[files->currentIndex()].index_in_tabs].key_press_flag = true;

            event = new QKeyEvent(QEvent::KeyPress, Qt::Key_Home, Qt::NoModifier);
            QApplication::postEvent(QApplication::focusWidget(), event);
        }
    }
    else if (text == "O")                               //  Vim insert mode is going to be active
    {
        if (vim_visual_flag == false)                   //  Vim visual mode is inactive
        {
            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[active_tabs[files->currentIndex()].index_in_tabs].vim_active = false;
            editor[active_tabs[files->currentIndex()].index_in_tabs].key_press_flag = true;

            QKeyEvent * event = new QKeyEvent(QEvent::KeyPress, Qt::Key_Up, Qt::NoModifier);
            QApplication::postEvent(QApplication::focusWidget(), event);

            editor[active_tabs[files->currentIndex()].index_in_tabs].key_press_flag = true;

            event = new QKeyEvent(QEvent::KeyPress, Qt::Key_End, Qt::NoModifier);
            QApplication::postEvent(QApplication::focusWidget(), event);

            editor[active_tabs[files->currentIndex()].index_in_tabs].key_press_flag = true;

            event = new QKeyEvent(QEvent::KeyPress, Qt::Key_Enter, Qt::NoModifier);
            QApplication::postEvent(QApplication::focusWidget(), event);

            editor[active_tabs[files->currentIndex()].index_in_tabs].key_press_flag = true;

            event = new QKeyEvent(QEvent::KeyPress, Qt::Key_Home, Qt::NoModifier);
            QApplication::postEvent(QApplication::focusWidget(), event);
        }
    }
    else if (text == ":")                               //  Vim command mode is going to be active
    {
        vim_prefix->setText(":");
        vim_prefix->show();
        vim_edit->setText("");
        vim_edit->setReadOnly(false);
        vim_edit->setFocus();
        editor[active_tabs[files->currentIndex()].index_in_tabs].setReadOnly(true);
    }
    else if ((type == Qt::Key_Left && text != "control") || text == "h" || type == Qt::Key_Backspace)   //  left cursor move command
    {
        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        int times = 1;

        QRegExp re("\\d+");

        if (re.exactMatch(vim_character_queue))         //  get multiplier value from command
           times = vim_character_queue.toInt();         //  convert characters sequence into the multiplier number

        for (int i = 0; i < times; i++)                 //  use multiplier value using loop
        {
            if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->clearSelection();          //  clear actual text cursor selection
                text_cursor->setPosition(text_cursor->position() - 1, QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                if (delete_flag)
                    editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                else if (lower_flag)
                    lower_case_button_pressed();        //  convert selected text into lowercase text
                else
                    upper_case_button_pressed();        //  convert selected text into uppercase text
            }
            else if (vim_visual_flag)                   //  Vim visual mode is active
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->setPosition(text_cursor->position() - 1, QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
            }
            else
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->setPosition(text_cursor->position() - 1);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
            }
        }

        if (insert_flag)                                //  insert command has been used
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if (type == Qt::Key_Space || (type == Qt::Key_Right && text != "control") || text == "l")  //  right cursor move command
    {
        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        int times = 1;

        QRegExp re("\\d+");

        if (re.exactMatch(vim_character_queue))         //  get multiplier value from command
           times = vim_character_queue.toInt();         //  convert characters sequence into the multiplier number

        for (int i = 0; i < times; i++)                 //  use multiplier value using loop
        {
            if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->clearSelection();          //  clear actual text cursor selection
                text_cursor->setPosition(text_cursor->position() + 1, QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                if (delete_flag)
                    editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                else if (lower_flag)
                    lower_case_button_pressed();        //  convert selected text into lowercase text
                else
                    upper_case_button_pressed();        //  convert selected text into uppercase text
            }
            else if (vim_visual_flag)                   //  Vim visual mode is active
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->setPosition(text_cursor->position() + 1, QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
            }
            else
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->setPosition(text_cursor->position() + 1);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
            }
        }

        if (insert_flag)                                //  insert command has been used
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if (type == Qt::Key_Up || text == "k")         //  up cursor move command
    {
        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        int times = 1;

        QRegExp re("\\d+");

        if (re.exactMatch(vim_character_queue))         //  get multiplier value from command
           times = vim_character_queue.toInt();         //  convert characters sequence into the multiplier number

        for (int i = 0; i < times; i++)                 //  use multiplier value using loop
        {
            int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().blockNumber();

            if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
            {
                QTextCursor line_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(actual - 1));

                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->clearSelection();          //  clear actual text cursor selection
                text_cursor->setPosition(line_cursor.position(), QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                if (delete_flag)
                    editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                else if (lower_flag)
                    lower_case_button_pressed();        //  convert selected text into lowercase text
                else
                    upper_case_button_pressed();        //  convert selected text into uppercase text
            }
            else if (vim_visual_flag)                   //  Vim visual mode is active
            {
                editor[active_tabs[files->currentIndex()].index_in_tabs].key_press_flag = true;

                QKeyEvent * event = new QKeyEvent(QEvent::KeyPress, Qt::Key_Up, Qt::ShiftModifier);
                QApplication::postEvent(QApplication::focusWidget(), event);
            }
            else
            {
                editor[active_tabs[files->currentIndex()].index_in_tabs].key_press_flag = true;

                QKeyEvent * event = new QKeyEvent(QEvent::KeyPress, Qt::Key_Up, Qt::NoModifier);
                QApplication::postEvent(QApplication::focusWidget(), event);
            }
        }

        if (insert_flag)                                //  insert command has been used
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if (type == Qt::Key_Down || text == "j")       //  down cursor move command
    {
        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        int times = 1;

        QRegExp re("\\d+");

        if (re.exactMatch(vim_character_queue))         //  get multiplier value from command
           times = vim_character_queue.toInt();         //  convert characters sequence into the multiplier number

        for (int i = 0; i < times; i++)                 //  use multiplier value using loop
        {
            int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().blockNumber();

            if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
            {
                QTextCursor line_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(actual + 2));

                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->clearSelection();          //  clear actual text cursor selection
                text_cursor->setPosition(line_cursor.position(), QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                if (delete_flag)
                    editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                else if (lower_flag)
                    lower_case_button_pressed();        //  convert selected text into lowercase text
                else
                    upper_case_button_pressed();        //  convert selected text into uppercase text
            }
            else if (vim_visual_flag)                   //  Vim visual mode is active
            {
                editor[active_tabs[files->currentIndex()].index_in_tabs].key_press_flag = true;

                QKeyEvent * event = new QKeyEvent(QEvent::KeyPress, Qt::Key_Down, Qt::ShiftModifier);
                QApplication::postEvent(QApplication::focusWidget(), event);
            }
            else
            {
                editor[active_tabs[files->currentIndex()].index_in_tabs].key_press_flag = true;

                QKeyEvent * event = new QKeyEvent(QEvent::KeyPress, Qt::Key_Down, Qt::NoModifier);
                QApplication::postEvent(QApplication::focusWidget(), event);
            }
        }

        if (insert_flag)                                //  insert command has been used
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if (text == "d" && (vim_visual_flag || vim_character_queue.right(1) == "d"))   //  delete command has been used
    {
        if (vim_visual_flag)                            //  Vim visual mode is active
        {
            vim_edit->clear();
            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();

            QString selected_text = text_cursor->selection().toPlainText();
            int lines = selected_text.count("\n") + 1;

            if (lines >= 2)
                vim_edit->setText(QString("%1 lines fewer").arg(lines));

            text_cursor->deleteChar();
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

            vim_visual_flag = false;                    //  disable Vim visual flag
        }
        else                                            //  Vim visual mode is inactive
        {
            vim_character_queue.chop(1);
            int times = 1;

            QRegExp re("\\d+");

            if (re.exactMatch(vim_character_queue))     //  get multiplier value from command
               times = vim_character_queue.toInt();     //  convert characters sequence into the multiplier number

            for (int i = 0; i < times; i++)             //  use multiplier value using loop
            {
                int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().blockNumber();

                QTextCursor line_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(actual));
                line_cursor.clearSelection();
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(line_cursor);

                QTextCursor next_line_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(actual + 1));
                next_line_cursor.setPosition(line_cursor.position(), QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(next_line_cursor);

                editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
            }
        }
    }
    else if (text == "c" && (vim_visual_flag || vim_character_queue.right(1) == "c"))   //  insert command has been used
    {
        if (vim_visual_flag)                            //  Vim visual mode is active
        {
            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            text_cursor->deleteChar();
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

            editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
            vim_visual_flag = false;                    //  disable Vim visual flag

            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
        else                                            //  Vim visual mode is inactive
        {
            vim_character_queue.chop(1);
            int times = 1;

            QRegExp re("\\d+");

            if (re.exactMatch(vim_character_queue))     //  get multiplier value from command
               times = vim_character_queue.toInt();     //  convert characters sequence into the multiplier number

            for (int i = 0; i < times; i++)             //  use multiplier value using loop
            {
                int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().blockNumber();

                QTextCursor line_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(actual));
                line_cursor.clearSelection();
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(line_cursor);

                QTextCursor next_line_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(actual + 1));
                next_line_cursor.setPosition(line_cursor.position(), QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(next_line_cursor);

                editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
            }

            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if (text == "u" && vim_visual_flag && vim_character_queue.right(1) == "g")     //  lowercase command has been used
    {
        vim_edit->clear();
        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();

        QString selected_text = text_cursor->selection().toPlainText();
        int lines = selected_text.count("\n") + 1;

        if (lines >= 2)
            vim_edit->setText(QString("%1 lines changed").arg(lines));

        lower_case_button_pressed();                    //  convert selected text into lowercase text
        vim_visual_flag = false;                        //  disable Vim visual flag
    }
    else if (text == "U" && vim_visual_flag && vim_character_queue.right(1) == "g")     //  uppercase command has been used
    {
        vim_edit->clear();
        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();

        QString selected_text = text_cursor->selection().toPlainText();
        int lines = selected_text.count("\n") + 1;

        if (lines >= 2)
            vim_edit->setText(QString("%1 lines changed").arg(lines));

        upper_case_button_pressed();                    //  convert selected text into uppercase text
        vim_visual_flag = false;                        //  disable Vim visual flag
    }
    else if (text == "}")                               //  next text block jump command
    {
        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        int times = 1;

        QRegExp re("\\d+");

        if (re.exactMatch(vim_character_queue))         //  get multiplier value from command
           times = vim_character_queue.toInt();         //  convert characters sequence into the multiplier number

        QString editor_content = editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText();
        int len = editor_content.size();
        int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position() + 1;

        for (int i = 0; i < times; i++)                 //  use multiplier value using loop
        {
            while (actual + 1 < len)
            {
                if (editor_content[actual] == '\n' && editor_content[actual + 1] == '\n')
                {
                    actual++;

                    if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->clearSelection();      //  clear actual text cursor selection
                        text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                        if (delete_flag)
                            editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                        else if (lower_flag)
                            lower_case_button_pressed();    //  convert selected text into lowercase text
                        else
                            upper_case_button_pressed();    //  convert selected text into uppercase text
                    }
                    else if (vim_visual_flag)           //  Vim visual mode is active                           //  Vim visual mode is active
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                    }
                    else
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->setPosition(actual);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                    }

                    break;
                }
                else
                    actual++;
            }
        }

        if (insert_flag)                                //  insert command has been used
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if (text == "{")                               //  previous text block jump command
    {
        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        int times = 1;

        QRegExp re("\\d+");

        if (re.exactMatch(vim_character_queue))         //  get multiplier value from command
           times = vim_character_queue.toInt();         //  convert characters sequence into the multiplier number

        QString editor_content = editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText();
        int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position() - 1;

        for (int i = 0; i < times; i++)                 //  use multiplier value using loop
        {
            while (actual)
            {
                if (editor_content[actual] == '\n' && editor_content[actual - 1] == '\n')
                {
                    if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->clearSelection();      //  clear actual text cursor selection
                        text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                        if (delete_flag)
                            editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                        else if (lower_flag)
                            lower_case_button_pressed();    //  convert selected text into lowercase text
                        else
                            upper_case_button_pressed();    //  convert selected text into uppercase text
                    }
                    else if (vim_visual_flag)           //  Vim visual mode is active                           //  Vim visual mode is active
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                    }
                    else
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->setPosition(actual);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                    }

                    actual--;
                    break;
                }
                else
                    actual--;
            }
        }

        if (insert_flag)                                //  insert command has been used
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if (text == ")")                               //  next sentence jump command
    {
        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        int times = 1;

        QRegExp re("\\d+");

        if (re.exactMatch(vim_character_queue))         //  get multiplier value from command
           times = vim_character_queue.toInt();         //  convert characters sequence into the multiplier number

        QString editor_content = editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText();
        int len = editor_content.size();
        int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();

        for (int i = 0; i < times; i++)                 //  use multiplier value using loop
        {
            while (actual + 1 < len)
            {
                if ((editor_content[actual] == '.' || editor_content[actual] == '!' || editor_content[actual] == '?') && editor_content[actual + 1] == '\n')
                {
                    actual += 2;

                    while (actual < len && (editor_content[actual] == ' ' || editor_content[actual] == '\t'))
                        actual++;

                    if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->clearSelection();      //  clear actual text cursor selection
                        text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                        if (delete_flag)
                            editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                        else if (lower_flag)
                            lower_case_button_pressed();    //  convert selected text into lowercase text
                        else
                            upper_case_button_pressed();    //  convert selected text into uppercase text
                    }
                    else if (vim_visual_flag)           //  Vim visual mode is active                           //  Vim visual mode is active
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                    }
                    else
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->setPosition(actual);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                    }

                    break;
                }
                else if (editor_content[actual] == '\n' && editor_content[actual + 1] == '\n')
                {
                    while (actual < len && editor_content[actual] == '\n')
                        actual++;

                    actual--;

                    if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->clearSelection();      //  clear actual text cursor selection
                        text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                        if (delete_flag)
                            editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                        else if (lower_flag)
                            lower_case_button_pressed();    //  convert selected text into lowercase text
                        else
                            upper_case_button_pressed();    //  convert selected text into uppercase text
                    }
                    else if (vim_visual_flag)           //  Vim visual mode is active                           //  Vim visual mode is active
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                    }
                    else
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->setPosition(actual);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                    }

                    break;
                }
                else if (editor_content[actual] == '\n' && editor_content[actual - 1] == '\n')
                {
                    while (actual < len && editor_content[actual].isSpace())
                        actual++;

                    if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->clearSelection();      //  clear actual text cursor selection
                        text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                        if (delete_flag)
                            editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                        else if (lower_flag)
                            lower_case_button_pressed();    //  convert selected text into lowercase text
                        else
                            upper_case_button_pressed();    //  convert selected text into uppercase text
                    }
                    else if (vim_visual_flag)           //  Vim visual mode is active                           //  Vim visual mode is active
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                    }
                    else
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->setPosition(actual);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                    }

                    break;
                }
                else
                    actual++;
            }
        }

        if (insert_flag)                                //  insert command has been used
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if (text == "(")                               //  previous sentence jump command
    {
        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        int times = 1;

        QRegExp re("\\d+");

        if (re.exactMatch(vim_character_queue))         //  get multiplier value from command
           times = vim_character_queue.toInt();         //  convert characters sequence into the multiplier number

        QString editor_content = editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText();
        int len = editor_content.size();
        int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();
        int original = actual;

        for (int i = 0; i < times; i++)                 //  use multiplier value using loop
        {
            while (actual >= 0)
            {
                if ((editor_content[actual] == '.' || editor_content[actual] == '!' || editor_content[actual] == '?') && editor_content[actual + 1] == '\n')
                {
                    if (actual == original)
                    {
                        actual--;
                        continue;
                    }

                    if (actual + 1 == original)
                    {
                        actual -= 2;
                        continue;
                    }

                    int old = actual;
                    actual += 2;

                    while (actual < len && editor_content[actual].isSpace())
                        actual++;

                    if (actual >= original)
                    {
                        actual = old - 1;
                        continue;
                    }

                    if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->clearSelection();      //  clear actual text cursor selection
                        text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                        if (delete_flag)
                            editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                        else if (lower_flag)
                            lower_case_button_pressed();    //  convert selected text into lowercase text
                        else
                            upper_case_button_pressed();    //  convert selected text into uppercase text
                    }
                    else if (vim_visual_flag)           //  Vim visual mode is active                           //  Vim visual mode is active
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                    }
                    else
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->setPosition(actual);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                    }

                    break;
                }
                else if (editor_content[actual] == '\n' && editor_content[actual + 1] == '\n' && editor_content[actual - 1] != '\n')
                {
                    if (actual + 1 == original)
                    {
                        actual--;
                        continue;
                    }

                    int old = actual;
                    actual += 2;

                    while (actual < len && editor_content[actual].isSpace())
                        actual++;

                    if (actual >= original)
                        actual = old + 1;

                    if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->clearSelection();      //  clear actual text cursor selection
                        text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                        if (delete_flag)
                            editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                        else if (lower_flag)
                            lower_case_button_pressed();    //  convert selected text into lowercase text
                        else
                            upper_case_button_pressed();    //  convert selected text into uppercase text
                    }
                    else if (vim_visual_flag)           //  Vim visual mode is active                           //  Vim visual mode is active
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                    }
                    else
                    {
                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                        text_cursor->setPosition(actual);
                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                    }

                    break;
                }
                else
                    actual--;
            }
        }

        if (insert_flag)                                //  insert command has been used
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if ((type == Qt::Key_Right && text == "control") || text == "w")   //  next word move command
    {
        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        int times = 1;

        QRegExp re("\\d+");

        if (re.exactMatch(vim_character_queue))         //  get multiplier value from command
           times = vim_character_queue.toInt();         //  convert characters sequence into the multiplier number

        QString editor_content = editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText();
        int len = editor_content.size();

        for (int i = 0; i < times; i++)                 //  use multiplier value using loop
        {
            int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();

            if (actual < len && editor_content[actual].isLetter())  //  actual character is letter
            {
                actual++;

                while (true)
                {
                    if (actual < len && editor_content[actual].isLetter())  //  continue while actual character is letter
                        actual++;
                    else
                        break;
                }
            }
            else if (actual < len && editor_content[actual].isDigit())  //  while actual character is digit
            {
                actual++;

                while (true)
                {
                    if (actual < len && editor_content[actual].isDigit())   //  continue while actual character is digit
                        actual++;
                    else
                        break;
                }
            }
            else if (actual < len && !editor_content[actual].isSpace())
            {
                actual++;

                while (true)
                {
                    if (actual < len && !editor_content[actual].isSpace() && !editor_content[actual].isLetterOrNumber())
                        actual++;
                    else
                        break;
                }
            }

            while (actual < len && editor_content[actual].isSpace())    //  ignore space characters between words
                actual++;

            if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->clearSelection();          //  clear actual text cursor selection
                text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                if (delete_flag)
                    editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                else if (lower_flag)
                    lower_case_button_pressed();        //  convert selected text into lowercase text
                else
                    upper_case_button_pressed();        //  convert selected text into uppercase text
            }
            else if (vim_visual_flag)                   //  Vim visual mode is active
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
            }
            else
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->setPosition(actual);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
            }
        }

        if (insert_flag)                                //  insert command has been used
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if (text == "e")                               //  begin of next word move command
    {
        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        int times = 1;

        QRegExp re("\\d+");

        if (re.exactMatch(vim_character_queue))         //  get multiplier value from command
           times = vim_character_queue.toInt();         //  convert characters sequence into the multiplier number

        QString editor_content = editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText();
        int len = editor_content.size();

        for (int i = 0; i < times; i++)                 //  use multiplier value using loop
        {
            int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();
            actual++;

            while (actual < len && editor_content[actual].isSpace())    //  ignore space characters between words
                actual++;

            if (actual < len && editor_content[actual].isLetter())  //  actual character is letter
            {
                actual++;

                while (true)
                {
                    if (actual < len && editor_content[actual].isLetter())  //  continue while actual character is letter
                        actual++;
                    else
                        break;
                }
            }
            else if (actual < len && editor_content[actual].isDigit())  //  actual character is digit
            {
                actual++;

                while (true)
                {
                    if (actual < len && editor_content[actual].isDigit())   //  continue while actual character is digit
                        actual++;
                    else
                        break;
                }
            }
            else if (actual < len && !editor_content[actual].isSpace())
            {
                actual++;

                while (true)
                {
                    if (actual < len && !editor_content[actual].isSpace() && !editor_content[actual].isLetterOrNumber())
                        actual++;
                    else
                        break;
                }
            }

            if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->clearSelection();          //  clear actual text cursor selection
                text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                if (delete_flag)
                    editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                else if (lower_flag)
                    lower_case_button_pressed();        //  convert selected text into lowercase text
                else
                    upper_case_button_pressed();        //  convert selected text into uppercase text
            }
            else if (vim_visual_flag)                   //  Vim visual mode is active
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->setPosition(actual - 1, QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
            }
            else
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->setPosition(actual - 1);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
            }
        }

        if (insert_flag)                                //  insert command has been used
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if ((type == Qt::Key_Left && text == "control") || text == "b")    //  previous word move command
    {
        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        int times = 1;

        QRegExp re("\\d+");

        if (re.exactMatch(vim_character_queue))         //  get multiplier value from command
           times = vim_character_queue.toInt();         //  convert characters sequence into the multiplier number

        QString editor_content = editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText();
        int len = editor_content.size();

        for (int i = 0; i < times; i++)                 //  use multiplier value using loop
        {
            int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();
            actual--;

            while (actual && editor_content[actual].isSpace())      //  ignore space characters between words
                actual--;

            if (actual && editor_content[actual].isLetter())    //  actual character is letter
            {
                actual--;

                while (true)
                {
                    if (actual && editor_content[actual].isLetter())    //  continue while actual character is letter
                        actual--;
                    else
                        break;
                }
            }
            else if (actual < len && editor_content[actual].isDigit())  //  actual character is digit
            {
                actual--;

                while (true)
                {
                    if (actual && editor_content[actual].isDigit())     //  continue while actual character is letter
                        actual--;
                    else
                        break;
                }
            }
            else if (actual < len && !editor_content[actual].isSpace())
            {
                actual--;

                while (true)
                {
                    if (actual && !editor_content[actual].isSpace() && !editor_content[actual].isLetterOrNumber())
                        actual--;
                    else
                        break;
                }
            }

            if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->clearSelection();          //  clear actual text cursor selection
                text_cursor->setPosition(actual + 1, QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                if (delete_flag)
                    editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                else if (lower_flag)
                    lower_case_button_pressed();        //  convert selected text into lowercase text
                else
                    upper_case_button_pressed();        //  convert selected text into uppercase text
            }
            else if (vim_visual_flag)                   //  Vim visual mode is active
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->setPosition(actual + 1, QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
            }
            else
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->setPosition(actual + 1);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
            }
        }

        if (insert_flag)                                //  insert command has been used
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if (text == "W")                               //  next word move command(without blank characters)
    {
        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        int times = 1;

        QRegExp re("\\d+");

        if (re.exactMatch(vim_character_queue))         //  get multiplier value from command
           times = vim_character_queue.toInt();         //  convert characters sequence into the multiplier number

        QString editor_content = editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText();
        int len = editor_content.size();

        for (int i = 0; i < times; i++)                 //  use multiplier value using loop
        {
            int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();

            if (actual < len && !editor_content[actual].isSpace())
            {
                actual++;

                while (true)
                {
                    if (actual < len && !editor_content[actual].isSpace())
                        actual++;
                    else
                        break;
                }
            }

            while (actual < len && editor_content[actual].isSpace())
                actual++;

            if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->clearSelection();          //  clear actual text cursor selection
                text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                if (delete_flag)
                    editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                else if (lower_flag)
                    lower_case_button_pressed();        //  convert selected text into lowercase text
                else
                    upper_case_button_pressed();        //  convert selected text into uppercase text
            }
            else if (vim_visual_flag)                   //  Vim visual mode is active
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->setPosition(actual - 1, QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
            }
            else
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->setPosition(actual - 1);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
            }
        }

        if (insert_flag)                                //  insert command has been used
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if (text == "E")                               //  begin of next word move command(without blank characters)
    {
        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        int times = 1;

        QRegExp re("\\d+");

        if (re.exactMatch(vim_character_queue))         //  get multiplier value from command
           times = vim_character_queue.toInt();         //  convert characters sequence into the multiplier number

        QString editor_content = editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText();
        int len = editor_content.size();

        for (int i = 0; i < times; i++)                 //  use multiplier value using loop
        {
            int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();
            actual++;

            while (actual < len && editor_content[actual].isSpace())
                actual++;

            if (actual < len && !editor_content[actual].isSpace())
            {
                actual++;

                while (true)
                {
                    if (actual < len && !editor_content[actual].isSpace())
                        actual++;
                    else
                        break;
                }
            }

            if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->clearSelection();          //  clear actual text cursor selection
                text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                if (delete_flag)
                    editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                else if (lower_flag)
                    lower_case_button_pressed();        //  convert selected text into lowercase text
                else
                    upper_case_button_pressed();        //  convert selected text into uppercase text
            }
            else if (vim_visual_flag)                   //  Vim visual mode is active
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->setPosition(actual - 1, QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
            }
            else
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->setPosition(actual - 1);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
            }
        }

        if (insert_flag)                                //  insert command has been used
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if (text == "B")                               //  previous word move command(without blank characters)
    {
        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        int times = 1;

        QRegExp re("\\d+");

        if (re.exactMatch(vim_character_queue))         //  get multiplier value from command
           times = vim_character_queue.toInt();         //  convert characters sequence into the multiplier number

        QString editor_content = editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText();
        int len = editor_content.size();

        for (int i = 0; i < times; i++)                 //  use multiplier value using loop
        {
            int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();
            actual--;

            while (actual && editor_content[actual].isSpace())
                actual--;

            if (actual < len && !editor_content[actual].isSpace())
            {
                actual--;

                while (true)
                {
                    if (actual && !editor_content[actual].isSpace())
                        actual--;
                    else
                        break;
                }
            }

            if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->clearSelection();          //  clear actual text cursor selection
                text_cursor->setPosition(actual + 1, QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                if (delete_flag)
                    editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                else if (lower_flag)
                    lower_case_button_pressed();        //  convert selected text into lowercase text
                else
                    upper_case_button_pressed();        //  convert selected text into uppercase text
            }
            else if (vim_visual_flag)                   //  Vim visual mode is active
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->setPosition(actual + 1, QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
            }
            else
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->setPosition(actual + 1);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
            }
        }

        if (insert_flag)                                //  insert command has been used
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if (text == "g" && vim_character_queue.right(1) == "g")    //  line jump command has been used
    {
        vim_character_queue.chop(1);

        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        int line = 0;

        QRegExp re("\\d+");

        if (re.exactMatch(vim_character_queue))         //  get multiplier value from command
            line = vim_character_queue.toInt();

        if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
        {
            QTextCursor line_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(line - 1));

            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            text_cursor->clearSelection();              //  clear actual text cursor selection
            text_cursor->setPosition(line_cursor.position(), QTextCursor::KeepAnchor);
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

            if (delete_flag)
                editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
            else if (lower_flag)
                lower_case_button_pressed();            //  convert selected text into lowercase text
            else
                upper_case_button_pressed();            //  convert selected text into uppercase text
        }
        else if (vim_visual_flag)                       //  Vim visual mode is active
        {
            QTextCursor line_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(line - 1));

            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            text_cursor->setPosition(line_cursor.position(), QTextCursor::KeepAnchor);
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
        }
        else
        {
            QTextCursor text_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(line - 1));
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(text_cursor);
        }

        if (insert_flag)                                //  insert command has been used
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if (text == "G")                               //  jump to the end of text
    {
        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        int lines = editor[active_tabs[files->currentIndex()].index_in_tabs].blockCount() - 1;

        if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
        {
            QTextCursor line_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(lines));

            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            text_cursor->clearSelection();              //  clear actual text cursor selection
            text_cursor->setPosition(line_cursor.position(), QTextCursor::KeepAnchor);
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

            if (delete_flag)
                editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
            else if (lower_flag)
                lower_case_button_pressed();            //  convert selected text into lowercase text
            else
                upper_case_button_pressed();            //  convert selected text into uppercase text
        }
        else if (vim_visual_flag)                       //  Vim visual mode is active
        {
            QTextCursor line_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(lines));

            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            text_cursor->setPosition(line_cursor.position(), QTextCursor::KeepAnchor);
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
        }
        else
        {
            QTextCursor text_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(lines));
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(text_cursor);
        }

        if (insert_flag)                                //  insert command has been used
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if (text == "0")                               //  line begin move command
    {
        QRegExp re("\\d+");

        if (re.exactMatch(vim_character_queue))         //  get multiplier value from command
        {
            vim_character_queue += "0";
            return;
        }
        else
        {
            bool delete_flag = false;                   //  clear appropriate flags
            bool insert_flag = false;
            bool lower_flag = false;
            bool upper_flag = false;

            if (vim_character_queue.right(1) == "d")    //  delete command has been combined with desired command
            {
                delete_flag = true;                     //  set delete flag
                vim_character_queue.chop(1);
            }
            else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
            {
                delete_flag = true;                     //  set delete flag
                insert_flag = true;                     //  set insert flag
                vim_character_queue.chop(1);
            }
            else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
            {
                lower_flag = true;                      //  set lowercase flag
                vim_character_queue.chop(2);
            }
            else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
            {
                upper_flag = true;                      //  set uppercase flag
                vim_character_queue.chop(2);
            }

            int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().blockNumber();

            if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
            {
                QTextCursor line_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(actual));

                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->clearSelection();          //  clear actual text cursor selection
                text_cursor->setPosition(line_cursor.position(), QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                if (delete_flag)
                    editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
                else if (lower_flag)
                    lower_case_button_pressed();        //  convert selected text into lowercase text
                else
                    upper_case_button_pressed();        //  convert selected text into uppercase text
            }
            else if (vim_visual_flag)                   //  Vim visual mode is active
            {
                QTextCursor line_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(actual));

                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->setPosition(line_cursor.position(), QTextCursor::KeepAnchor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
            }
            else
            {
                QTextCursor text_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(actual));
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(text_cursor);
            }

            if (insert_flag)                            //  insert command has been used
            {
                int index = active_tabs[files->currentIndex()].index_in_tabs;

                vim_edit->setText("- -  INSERT  - -");  //  activate Vim insert mode
                editor[index].vim_active = false;       //  activate overwrite mode in text editor
                editor[index].setOverwriteMode(insert_mode);
            }
        }
    }
    else if (text == "^")                               //  begin of text on line command
    {
        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        QString editor_content = editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText();
        int len = editor_content.size();
        int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().blockNumber();

        if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
        {
            QTextCursor line_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(actual));

            int actual = line_cursor.position();

            while (actual < len && (editor_content[actual] == ' ' || editor_content[actual] == '\t'))
                actual++;

            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            text_cursor->clearSelection();              //  clear actual text cursor selection
            text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

            if (delete_flag)
                editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
            else if (lower_flag)
                lower_case_button_pressed();            //  convert selected text into lowercase text
            else
                upper_case_button_pressed();            //  convert selected text into uppercase text
        }
        else if (vim_visual_flag)                       //  Vim visual mode is active
        {
            QTextCursor line_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(actual));

            int actual = line_cursor.position();

            while (actual < len && (editor_content[actual] == ' ' || editor_content[actual] == '\t'))
                actual++;

            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
        }
        else
        {
            QTextCursor line_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(actual));

            int actual = line_cursor.position();

            while (actual < len && (editor_content[actual] == ' ' || editor_content[actual] == '\t'))
                actual++;

            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            text_cursor->setPosition(actual);
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
        }

        if (insert_flag)                                //  insert command has been used
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if (text == "$")                               //  end of the line command
    {
        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        int times = 0;

        QRegExp re("\\d+");

        if (re.exactMatch(vim_character_queue))         //  get multiplier value from command
           times = vim_character_queue.toInt() - 1;

        QString editor_content = editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText();
        int len = editor_content.size();
        int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().blockNumber();

        if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
        {
            QTextCursor line_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(actual + times));

            int actual = line_cursor.position();

            while (actual < len && editor_content[actual] != '\n')
                actual++;

            actual--;

            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            text_cursor->clearSelection();              //  clear actual text cursor selection
            text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

            if (delete_flag)
                editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
            else if (lower_flag)
                lower_case_button_pressed();            //  convert selected text into lowercase text
            else
                upper_case_button_pressed();            //  convert selected text into uppercase text
        }
        else if (vim_visual_flag)                       //  Vim visual mode is active
        {
            QTextCursor line_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(actual + times));

            int actual = line_cursor.position();

            while (actual < len && editor_content[actual] != '\n')
                actual++;

            actual--;

            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            text_cursor->setPosition(actual, QTextCursor::KeepAnchor);
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
        }
        else
        {
            QTextCursor line_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(actual + times));

            int actual = line_cursor.position();

            while (actual < len && editor_content[actual] != '\n')
                actual++;

            actual--;

            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            text_cursor->setPosition(actual);
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
        }

        if (insert_flag)                                //  insert command has been used
        {
            int index = active_tabs[files->currentIndex()].index_in_tabs;

            vim_edit->setText("- -  INSERT  - -");      //  activate Vim insert mode
            editor[index].vim_active = false;           //  activate overwrite mode in text editor
            editor[index].setOverwriteMode(insert_mode);
        }
    }
    else if (text == ">")                               //  increase indentation on actual line
    {
        if (vim_visual_flag)                            //  Vim visual mode is active
        {
            handle_tab_press();

            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            text_cursor->clearSelection();              //  clear actual text cursor selection
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

            vim_edit->clear();
            vim_visual_flag = false;                    //  disable Vim visual flag
            vim_replace_flag = false;                   //  disable Vim replace flag
        }
        else
        {
            int times = 1;

            QRegExp re("\\d+");

            if (re.exactMatch(vim_character_queue))     //  get multiplier value from command
               times = vim_character_queue.toInt();     //  convert characters sequence into the multiplier number

            QString editor_content = editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText();
            int len = editor_content.size();
            int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().blockNumber();

            for (int i = times - 1; i >= 0; i--)
            {
                QTextCursor text_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(actual + i));
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(text_cursor);
                editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("\t");
            }

            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            actual = text_cursor->position();

            while (actual < len && (editor_content[actual] == ' ' || editor_content[actual] == '\t'))
                actual++;

            actual++;

            text_cursor->setPosition(actual);
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
        }

    }
    else if (text == "<")                               //  decrease indentation on actual line
    {
        if (vim_visual_flag)                            //  Vim visual mode is active
        {
            handle_shift_tab_press();

            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            text_cursor->clearSelection();              //  clear actual text cursor selection
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

            vim_edit->clear();
            vim_visual_flag = false;                    //  disable Vim visual flag
            vim_replace_flag = false;                   //  disable Vim replace flag
        }
        else
        {
            int times = 1;

            QRegExp re("\\d+");

            if (re.exactMatch(vim_character_queue))     //  get multiplier value from command
               times = vim_character_queue.toInt();     //  convert characters sequence into the multiplier number

            QString editor_content = editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText();
            int len = editor_content.size();
            int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().blockNumber();

            for (int i = times - 1; i >= 0; i--)
            {
                QTextCursor text_cursor(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->findBlockByLineNumber(actual + i));

                if (editor_content[text_cursor.position()] == '\t')
                    text_cursor.deleteChar();

                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(text_cursor);
            }

            * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
            editor_content = editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText();
            len = editor_content.size();
            actual = text_cursor->position();

            while (actual < len && (editor_content[actual] == ' ' || editor_content[actual] == '\t'))
                actual++;

            text_cursor->setPosition(actual);
            editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
        }

    }
    else if (text == "*")                               //  jump to next position of word under text cursor
    {
        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
        text_cursor->select(QTextCursor::WordUnderCursor);
        QString word = text_cursor->selectedText();

        if (word.size())
        {
            int times = 1;

            QRegExp re("\\d+");

            if (re.exactMatch(vim_character_queue))     //  get multiplier value from command
               times = vim_character_queue.toInt();     //  convert characters sequence into the multiplier number

            if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->clearSelection();          //  clear actual text cursor selection
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
            }

            for (int j = 1; j <= times; j++)
            {
                if (delete_flag || lower_flag || upper_flag || vim_visual_flag)
                {
                    QString find_pattern = word;        //  get content of vim edit
                    find_pattern = QRegularExpression::escape(find_pattern);    //  escape search string if searching by regular expression is disabled
                    find_pattern = "\\b" + find_pattern + "\\b";    //  find whole word if boundary flag is active

                    QRegularExpression expr(find_pattern);
                    expr.setPatternOptions(QRegularExpression::DotMatchesEverythingOption);     //  allow multiline match for regular expression
                    expr.optimize();

                    if (expr.isValid())                 //  check if regular expression is valid
                    {
                        vector<int> from_array;         //  array with starting positions of all regular expression matches
                        vector<int> to_array;           //  array with ending positions of all regular expression matches

                        QRegularExpressionMatchIterator iter = expr.globalMatch(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText());
                                                        //  check for global match of regular expression and save result into match iterator
                        while (iter.hasNext())          //  iterate through all matches
                        {
                            QRegularExpressionMatch match = iter.next();

                            if (match.hasMatch())       //  regular expression match found
                            {
                                from_array.push_back(match.capturedStart(0));   //  push coordinates of match into appropriate arrays
                                to_array.push_back(match.capturedEnd(0));
                            }
                        }

                        int N = from_array.size();      //  get number of regular expression matches

                        if (N)                          //  at least one match must be present
                        {                               //  get actual text cursor position
                            int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();

                            if (N == 1)                 //  just highlight one and only match by text cursor selection
                            {
                                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                text_cursor->setPosition(from_array[0], QTextCursor::KeepAnchor);
                                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                                return;                 //  stop searching
                            }

                            bool found = false;         //  holds if appropriate match was selected

                            for (int i = 0; i < N; i++)     //  iterate again through all matches
                            {
                                if (from_array[i] <= actual && actual <= to_array[i])   //  cursor position is at location of actual match
                                {
                                    if (i == N - 1)     //  actual match is last in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[0], QTextCursor::KeepAnchor);    //  highlight first match of file content
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }
                                    else                //  actual match is not last in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[i + 1], QTextCursor::KeepAnchor);    //  highlight next match
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }

                                    found = true;
                                    break;              //  stop searching
                                }
                                else if (actual < from_array[i])    //  cursor position is before location of actual match
                                {
                                    * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                    text_cursor->setPosition(from_array[i], QTextCursor::KeepAnchor);    //  highlight actual match
                                    editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                                    found = true;
                                    break;              //  stop searching
                                }
                            }

                            if (found == false)
                            {                           //  select first match if flag is not set
                                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                text_cursor->setPosition(from_array[0], QTextCursor::KeepAnchor);    //  highlight first match of file content
                                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                            }
                        }
                    }
                }
                else
                {
                    QString find_pattern = word;        //  get content of vim edit
                    find_pattern = QRegularExpression::escape(find_pattern);    //  escape search string if searching by regular expression is disabled
                    find_pattern = "\\b" + find_pattern + "\\b";    //  find whole word if boundary flag is active

                    QRegularExpression expr(find_pattern);
                    expr.setPatternOptions(QRegularExpression::DotMatchesEverythingOption);     //  allow multiline match for regular expression
                    expr.optimize();

                    if (expr.isValid())                 //  check if regular expression is valid
                    {
                        vector<int> from_array;         //  array with starting positions of all regular expression matches
                        vector<int> to_array;           //  array with ending positions of all regular expression matches

                        QRegularExpressionMatchIterator iter = expr.globalMatch(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText());
                                                        //  check for global match of regular expression and save result into match iterator
                        while (iter.hasNext())          //  iterate through all matches
                        {
                            QRegularExpressionMatch match = iter.next();

                            if (match.hasMatch())       //  regular expression match found
                            {
                                from_array.push_back(match.capturedStart(0));   //  push coordinates of match into appropriate arrays
                                to_array.push_back(match.capturedEnd(0));
                            }
                        }

                        int N = from_array.size();      //  get number of regular expression matches

                        if (N)                          //  at least one match must be present
                        {                               //  get actual text cursor position
                            int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();

                            if (N == 1)                 //  just highlight one and only match by text cursor selection
                            {
                                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                text_cursor->setPosition(from_array[0]);
                                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                                return;                 //  stop searching
                            }

                            bool found = false;         //  holds if appropriate match was selected

                            for (int i = 0; i < N; i++)     //  iterate again through all matches
                            {
                                if (from_array[i] <= actual && actual <= to_array[i])   //  cursor position is at location of actual match
                                {
                                    if (i == N - 1)     //  actual match is last in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[0]);    //  highlight first match of file content by text cursor selection
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }
                                    else                //  actual match is not last in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[i + 1]);    //  highlight next match by text cursor selection
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }

                                    found = true;
                                    break;              //  stop searching
                                }
                                else if (actual < from_array[i])    //  cursor position is before location of actual match
                                {
                                    * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                    text_cursor->setPosition(from_array[i]);    //  highlight actual match by text cursor selection
                                    editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                                    found = true;
                                    break;              //  stop searching
                                }
                            }

                            if (found == false)
                            {                           //  select first match if flag is not set
                                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                text_cursor->setPosition(from_array[0]);    //  highlight first match of file content by text cursor selection
                                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                            }
                        }
                    }
                }
            }

            if (delete_flag)
                editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
            else if (lower_flag)
                lower_case_button_pressed();            //  convert selected text into lowercase text
            else if (upper_flag)
                upper_case_button_pressed();            //  convert selected text into uppercase text

            if (insert_flag)                            //  insert command has been used
            {
                int index = active_tabs[files->currentIndex()].index_in_tabs;

                vim_edit->setText("- -  INSERT  - -");  //  activate Vim insert mode
                editor[index].vim_active = false;       //  activate overwrite mode in text editor
                editor[index].setOverwriteMode(insert_mode);
            }
        }
    }
    else if (text == "#")                               //  jump to previous position of word under text cursor
    {
        bool delete_flag = false;                       //  clear appropriate flags
        bool insert_flag = false;
        bool lower_flag = false;
        bool upper_flag = false;

        if (vim_character_queue.right(1) == "d")        //  delete command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(1) == "c")   //  insert command has been combined with desired command
        {
            delete_flag = true;                         //  set delete flag
            insert_flag = true;                         //  set insert flag
            vim_character_queue.chop(1);
        }
        else if (vim_character_queue.right(2) == "gu")  //  lowercase command has been combined with desired command
        {
            lower_flag = true;                          //  set lowercase flag
            vim_character_queue.chop(2);
        }
        else if (vim_character_queue.right(2) == "gU")  //  uppercase command has been combined with desired command
        {
            upper_flag = true;                          //  set uppercase flag
            vim_character_queue.chop(2);
        }

        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
        text_cursor->select(QTextCursor::WordUnderCursor);
        QString word = text_cursor->selectedText();

        if (word.size())
        {
            int times = 1;

            QRegExp re("\\d+");

            if (re.exactMatch(vim_character_queue))     //  get multiplier value from command
               times = vim_character_queue.toInt();     //  convert characters sequence into the multiplier number

            if (delete_flag || lower_flag || upper_flag)    //  delete, lowercase or uppercase flag is active
            {
                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                text_cursor->clearSelection();          //  clear actual text cursor selection
                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
            }

            for (int j = 1; j <= times; j++)
            {
                if (delete_flag || lower_flag || upper_flag || vim_visual_flag)
                {
                    QString find_pattern = word;        //  get content of vim edit
                    find_pattern = QRegularExpression::escape(find_pattern);    //  escape search string if searching by regular expression is disabled
                    find_pattern = "\\b" + find_pattern + "\\b";    //  find whole word if boundary flag is active

                    QRegularExpression expr(find_pattern);
                    expr.setPatternOptions(QRegularExpression::DotMatchesEverythingOption);     //  allow multiline match for regular expression
                    expr.optimize();

                    if (expr.isValid())                 //  check if regular expression is valid
                    {
                        vector<int> from_array;         //  array with starting positions of all regular expression matches
                        vector<int> to_array;           //  array with ending positions of all regular expression matches

                        QRegularExpressionMatchIterator iter = expr.globalMatch(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText());
                                                        //  check for global match of regular expression and save result into match iterator
                        while (iter.hasNext())          //  iterate through all matches
                        {
                            QRegularExpressionMatch match = iter.next();

                            if (match.hasMatch())       //  regular expression match found
                            {
                                from_array.push_back(match.capturedStart(0));   //  push coordinates of match into appropriate arrays
                                to_array.push_back(match.capturedEnd(0));
                            }
                        }

                        int N = from_array.size();      //  get number of regular expression matches

                        if (N)                          //  at least one match must be present
                        {                               //  get actual text cursor position
                            int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();

                            if (N == 1)                 //  just highlight one and only match by text cursor selection
                            {
                                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                text_cursor->setPosition(from_array[0], QTextCursor::KeepAnchor);
                                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                                return;                 //  stop searching
                            }

                            bool found = false;         //  holds if appropriate match was selected

                            for (int i = 0; i < N; i++)     //  iterate again through all matches
                            {
                                if (from_array[i] <= actual && actual <= to_array[i])   //  cursor position is at location of actual match
                                {
                                    if (i)              //  actual match is not first in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[i - 1], QTextCursor::KeepAnchor);    //  highlight previous match
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }
                                    else                //  actual match is first in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[N - 1], QTextCursor::KeepAnchor);    //  highlight last match of file content
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }

                                    found = true;
                                    break;              //  stop searching
                                }
                                else if (actual < from_array[i])    //  cursor position is before location of actual match
                                {
                                    if (i)              //  actual match is not first in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[i - 1], QTextCursor::KeepAnchor);    //  highlight previous match
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }
                                    else                //  actual match is first in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[N - 1], QTextCursor::KeepAnchor);    //  highlight last match of file content
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }

                                    found = true;
                                    break;              //  stop searching
                                }
                            }

                            if (found == false)
                            {                           //  select last match if flag is not set
                                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                text_cursor->setPosition(from_array[N - 1], QTextCursor::KeepAnchor);    //  highlight last match of file content
                                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                            }
                        }
                    }
                }
                else
                {
                    QString find_pattern = word;        //  get content of vim edit
                    find_pattern = QRegularExpression::escape(find_pattern);    //  escape search string if searching by regular expression is disabled
                    find_pattern = "\\b" + find_pattern + "\\b";    //  find whole word if boundary flag is active

                    QRegularExpression expr(find_pattern);
                    expr.setPatternOptions(QRegularExpression::DotMatchesEverythingOption);     //  allow multiline match for regular expression
                    expr.optimize();

                    if (expr.isValid())                 //  check if regular expression is valid
                    {
                        vector<int> from_array;         //  array with starting positions of all regular expression matches
                        vector<int> to_array;           //  array with ending positions of all regular expression matches

                        QRegularExpressionMatchIterator iter = expr.globalMatch(editor[active_tabs[files->currentIndex()].index_in_tabs].document()->toPlainText());
                                                        //  check for global match of regular expression and save result into match iterator
                        while (iter.hasNext())          //  iterate through all matches
                        {
                            QRegularExpressionMatch match = iter.next();

                            if (match.hasMatch())       //  regular expression match found
                            {
                                from_array.push_back(match.capturedStart(0));   //  push coordinates of match into appropriate arrays
                                to_array.push_back(match.capturedEnd(0));
                            }
                        }

                        int N = from_array.size();      //  get number of regular expression matches

                        if (N)                          //  at least one match must be present
                        {                               //  get actual text cursor position
                            int actual = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor().position();

                            if (N == 1)                 //  just highlight one and only match by text cursor selection
                            {
                                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                text_cursor->setPosition(from_array[0]);
                                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);

                                return;                 //  stop searching
                            }

                            bool found = false;         //  holds if appropriate match was selected

                            for (int i = 0; i < N; i++)     //  iterate again through all matches
                            {
                                if (from_array[i] <= actual && actual <= to_array[i])   //  cursor position is at location of actual match
                                {
                                    if (i)              //  actual match is not first in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[i - 1]);    //  highlight previous match by text cursor selection
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }
                                    else                //  actual match is first in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[N - 1]);    //  highlight last match of file content by text cursor selection
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }

                                    found = true;
                                    break;              //  stop searching
                                }
                                else if (actual < from_array[i])    //  cursor position is before location of actual match
                                {
                                    if (i)              //  actual match is not first in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[i - 1]);    //  highlight previous match by text cursor selection
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }
                                    else                //  actual match is first in file content
                                    {
                                        * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                        text_cursor->setPosition(from_array[N - 1]);    //  highlight last match of file content by text cursor selection
                                        editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                                    }

                                    found = true;
                                    break;              //  stop searching
                                }
                            }

                            if (found == false)
                            {                           //  select last match if flag is not set
                                * text_cursor = editor[active_tabs[files->currentIndex()].index_in_tabs].textCursor();
                                text_cursor->setPosition(from_array[N - 1]);    //  highlight last match of file content by text cursor selection
                                editor[active_tabs[files->currentIndex()].index_in_tabs].setTextCursor(* text_cursor);
                            }
                        }
                    }
                }
            }

            if (delete_flag)
                editor[active_tabs[files->currentIndex()].index_in_tabs].insertPlainText("");
            else if (lower_flag)
                lower_case_button_pressed();            //  convert selected text into lowercase text
            else if (upper_flag)
                upper_case_button_pressed();            //  convert selected text into uppercase text

            if (insert_flag)                            //  insert command has been used
            {
                int index = active_tabs[files->currentIndex()].index_in_tabs;

                vim_edit->setText("- -  INSERT  - -");  //  activate Vim insert mode
                editor[index].vim_active = false;       //  activate overwrite mode in text editor
                editor[index].setOverwriteMode(insert_mode);
            }
        }
    }
    else
    {
        vim_character_queue += text;
        return;
    }

    vim_character_queue = "";
}


/// Handle save of new user language
void Spade::language_saved()
{
    Language user_language;
    ui->widget->get_language(user_language);            //  get language from language editor

    int index = find_language(user_language.name);

    if (index == -1)                                    //  language with same name not exist
    {
        push_language(user_language);                   //  push new language
        custom_languages->addItem(user_language.name);
        languages->addItem(user_language.name);
    }
    else                                                //  language with same name already exists
    {
        int N = active_tabs.size();                     //  get number of active tabs

        for (int i = 0; i < N; i++)                     //  iterate through all tabs of text editor
        {
            if (active_tabs[i].language == index + builtInLanguages)
                return;
        }

        update_language(user_language, index);          //  replace old language on appropriate position with new one
    }

    ui->widget->reset_interface();
    ui->scrollArea->verticalScrollBar()->setSliderPosition(ui->scrollArea->verticalScrollBar()->minimum());
    ui->scrollArea->horizontalScrollBar()->setSliderPosition(ui->scrollArea->horizontalScrollBar()->minimum());
    ui->tabs->setCurrentIndex(active_tabs[files->currentIndex()].index_in_tabs);    //  move back to actual tab in text editor
    show_language_tray();                               //  show language tray

    language_flag = false;                              //  disable language flag
}


/// Handle cancel of new user language
void Spade::language_canceled()
{
    ui->scrollArea->verticalScrollBar()->setSliderPosition(ui->scrollArea->verticalScrollBar()->minimum());
    ui->tabs->setCurrentIndex(active_tabs[files->currentIndex()].index_in_tabs);    //  move back to actual tab in text editor
    show_language_tray();                               //  show language tray

    language_flag = false;                              //  disable language flag
}
